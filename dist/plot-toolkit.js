/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/css-loader/dist/cjs.js!./abstract-layer/style.css":
/*!*************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./abstract-layer/style.css ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"axis-layer svg,\\nline-bin-layer svg,\\nline-point-layer svg,\\nline-formula-layer svg,\\nline-gaussian-layer svg,\\ncontrol-marker-layer svg,\\nhistogram-layer svg,\\nscatter-layer canvas,\\npolygon-layer svg,\\ntooltip-layer svg,\\nsegment-layer svg,\\nclick-layer svg,\\nbarchart-layer svg,\\noverlay-line-layer canvas,\\ncanvas-barchart-layer canvas,\\nheat-map canvas,\\ncurve-view-layer canvas\\n{\\n    position: absolute;\\n    top:0;\\n    left:0;\\n    overflow: visible;\\n    pointer-events: none;\\n}\\naxis-layer, axis-layer > div,\\nline-bin-layer, line-bin-layer > div,\\nline-point-layer, line-point-layer > div,\\nline-formula-layer, line-formula-layer > div,\\nline-gaussian-layer, line-gaussian-layer > div,\\ncontrol-marker-layer, control-marker-layer > div,\\nhistogram-layer, histogram-layer > div,\\nscatter-layer, scatter-layer > div,\\npolygon-layer, polygon-layer > div,\\ntooltip-layer, tooltip-layer > div,\\nsegment-layer, segment-layer > div,\\nclick-layer, click-layer > div,\\nbarchart-layer, barchart-layer > div,\\noverlay-line-layer, overlay-line-layer > div,\\ncanvas-barchart-layer, barchart-layer > div, \\nheat-map > div,\\ncurve-view-layer > div\\n{\\n    flex:1;\\n    display: flex;\\n}\\naxis-layer,\\nline-bin-layer,\\nline-point-layer,\\nline-formula-layer,\\nline-gaussian-layer,\\ncontrol-marker-layer,\\nhistogram-layer,\\nscatter-layer,\\npolygon-layer,\\ntooltip-layer,\\nsegment-layer,\\nclick-layer,\\nbarchart-layer,\\noverlay-line-layer,\\ncanvas-barchart-layer,\\nheat-map,\\ncurve-view-layer\\n{\\n    position:static !important;\\n    pointer-events:none;\\n}\\n\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./abstract-layer/style.css?../node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!./axis-layer/style.css":
/*!*********************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./axis-layer/style.css ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"axis-layer .layer .tick line {\\n    /* stroke: rgba(34, 139, 34, 0.5); */\\n    stroke: #555;\\n    stroke-width: 1;\\n    stroke-opacity: 1;\\n}\\n\\naxis-layer .layer .minor line {\\n    /* stroke: rgba(34, 139, 34, 0.5); */\\n    stroke: #333;\\n    stroke-width: 0.7;\\n    stroke-opacity: 0.7;\\n}\\n\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./axis-layer/style.css?../node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!./barchart-layer/style.css":
/*!*************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./barchart-layer/style.css ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"barchart-layer svg rect {\\n    stroke: gray;\\n    stroke-width: 0.3;\\n}\\n\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./barchart-layer/style.css?../node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!./canvas-barchart-layer/style.css":
/*!********************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./canvas-barchart-layer/style.css ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"canvas-barchart-layer svg rect {\\n    stroke: gray;\\n    stroke-width: 0.3;\\n}\\n\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./canvas-barchart-layer/style.css?../node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!./click-layer/style.css":
/*!**********************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./click-layer/style.css ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"click-layer svg.clickable {\\n    pointer-events:all;\\n}\\n\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./click-layer/style.css?../node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!./control-marker-layer/style.css":
/*!*******************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./control-marker-layer/style.css ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"control-marker-layer svg > g{\\n    pointer-events: all;\\n}\\ncontrol-marker-layer svg {\\n    pointer-events: all;\\n}\\n\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./control-marker-layer/style.css?../node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!./curve-view-layer/style.css":
/*!***************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./curve-view-layer/style.css ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./curve-view-layer/style.css?../node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!./heat-map/style.css":
/*!*******************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./heat-map/style.css ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./heat-map/style.css?../node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!./interactive-layer/style.css":
/*!****************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./interactive-layer/style.css ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"segment-layer svg.edit-point,\\npolygon-layer svg.edit-point \\n{\\n    background-color: rgba(128, 128, 255, 0.5);\\n    cursor: crosshair;\\n    pointer-events: all;\\n    z-index: 2;\\n}\\nsegment-layer svg.edit-point.del-point,\\npolygon-layer svg.edit-point.del-point \\n{\\n    cursor: alias;\\n}\\nsegment-layer svg.edit-point.add-point,\\npolygon-layer svg.edit-point.add-point \\n{\\n    cursor: copy;\\n}\\nsegment-layer div.status,\\npolygon-layer div.status\\n{\\n    position: absolute;\\n    bottom: 10px;\\n    right: 10px;\\n}\\n\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./interactive-layer/style.css?../node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!./layer-collection/style.css":
/*!***************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./layer-collection/style.css ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"layer-collection, layer-collection > div {\\n    display: flex;\\n    flex: 1;\\n    width: 100%;\\n}\\nlayer-collection div.notification {\\n    display: block;\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    bottom: 0;\\n    right: 0;\\n    pointer-events:none;\\n}\\nlayer-collection div.notification > div {\\n    background-color: rgba(32,32,32,0.5);\\n    width: 70px;\\n    height: 65px;\\n    font-size: 200%;\\n    color: white;\\n    text-align: center;\\n    border-radius: 15px;\\n    padding-top: 5px;\\n    position: absolute;\\n    top: 50%;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n    transition: opacity 1s ease-in-out;\\n}\\nlayer-collection div.tooltip\\n{\\n    display: inline-block;\\n    width: auto;\\n    position: absolute;\\n    pointer-events:none;\\n    background-color: rgba(32,32,32,0.5);\\n    color: white;\\n}\\n\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./layer-collection/style.css?../node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!./line-formula-layer/style.css":
/*!*****************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./line-formula-layer/style.css ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"line-formula-layer div.equation-holder {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    width: auto;\\n    cursor: pointer;\\n    pointer-events: all;\\n    z-index: 1;\\n}\\n\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./line-formula-layer/style.css?../node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!./line-gaussian-layer/style.css":
/*!******************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./line-gaussian-layer/style.css ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./line-gaussian-layer/style.css?../node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!./line-layer/style.css":
/*!*********************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./line-layer/style.css ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./line-layer/style.css?../node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!./segment-layer/style.css":
/*!************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./segment-layer/style.css ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"segment-layer div.equation {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    width: auto;\\n    cursor: pointer;\\n    pointer-events: all;\\n    z-index: 1;\\n}\\n\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./segment-layer/style.css?../node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!./tooltip-layer/style.css":
/*!************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./tooltip-layer/style.css ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"tooltip-layer svg \\n{\\n    pointer-events: all;\\n}\\ntooltip-layer div.status\\n{\\n    position: absolute;\\n    bottom: 10px;\\n    right: 10px;\\n}\\n\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./tooltip-layer/style.css?../node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/css-loader/dist/runtime/api.js":
/*!******************************************************!*\
  !*** ../node_modules/css-loader/dist/runtime/api.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return '@media ' + item[2] + '{' + content + '}';\n      } else {\n        return content;\n      }\n    }).join('');\n  }; // import a list of modules into the list\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (i = 0; i < modules.length; i++) {\n      var item = modules[i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || '';\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n  return '/*# ' + data + ' */';\n}\n\n//# sourceURL=webpack:///../node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "../node_modules/lodash/lodash.js":
/*!****************************************************************************!*\
  !*** delegated ./node_modules/lodash/lodash.js from dll-reference library ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = (__webpack_require__(/*! dll-reference library */ \"dll-reference library\"))(1);\n\n//# sourceURL=webpack:///delegated_./node_modules/lodash/lodash.js_from_dll-reference_library?");

/***/ }),

/***/ "../node_modules/resize-sensor/ResizeSensor.min.js":
/*!*********************************************************************************************!*\
  !*** delegated ./node_modules/resize-sensor/ResizeSensor.min.js from dll-reference library ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = (__webpack_require__(/*! dll-reference library */ \"dll-reference library\"))(4);\n\n//# sourceURL=webpack:///delegated_./node_modules/resize-sensor/ResizeSensor.min.js_from_dll-reference_library?");

/***/ }),

/***/ "../node_modules/style-loader/lib/addStyles.js":
/*!*****************************************************!*\
  !*** ../node_modules/style-loader/lib/addStyles.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"../node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n//# sourceURL=webpack:///../node_modules/style-loader/lib/addStyles.js?");

/***/ }),

/***/ "../node_modules/style-loader/lib/urls.js":
/*!************************************************!*\
  !*** ../node_modules/style-loader/lib/urls.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n//# sourceURL=webpack:///../node_modules/style-loader/lib/urls.js?");

/***/ }),

/***/ "../vendor/RGraph.common.core.js":
/*!***************************************!*\
  !*** ../vendor/RGraph.common.core.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// version: 2019-10-11\n    // o--------------------------------------------------------------------------------o\n    // | This file is part of the RGraph package - you can learn more at:               |\n    // |                                                                                |\n    // |                         https://www.rgraph.net                                 |\n    // |                                                                                |\n    // | RGraph is licensed under the Open Source MIT license. That means that it's     |\n    // | totally free to use and there are no restrictions on what you can do with it!  |\n    // o--------------------------------------------------------------------------------o\n\n    window.RGraph = window.RGraph || {isRGraph: true};\n\n// Module pattern\n(function (win, doc, undefined)\n{\n    // A short name variable\n    var ua  = navigator.userAgent;\n\n    //\n    // Initialise the various objects\n    //\n    RGraph.Highlight      = {};\n    RGraph.Registry       = {};\n    RGraph.Registry.store = [];\n    RGraph.Registry.store['event.handlers']       = [];\n    RGraph.Registry.store['__rgraph_event_listeners__'] = []; // Used in the new system for tooltips\n    RGraph.Background     = {};\n    RGraph.background     = {};\n    RGraph.objects        = [];\n    RGraph.Resizing       = {};\n    RGraph.events         = [];\n    RGraph.cursor         = [];\n    RGraph.Effects        = RGraph.Effects || {};\n    RGraph.cache          = [];\n\n    RGraph.ObjectRegistry                    = {};\n    RGraph.ObjectRegistry.objects            = {};\n    RGraph.ObjectRegistry.objects.byUID      = [];\n    RGraph.ObjectRegistry.objects.byCanvasID = [];\n    RGraph.OR                                = RGraph.ObjectRegistry;\n\n\n\n\n    //\n    // Some \"constants\". The ua variable is navigator.userAgent (definedabove)\n    //\n    RGraph.PI       = Math.PI;\n    RGraph.HALFPI   = RGraph.PI / 2;\n    RGraph.TWOPI    = RGraph.PI * 2;\n\n    RGraph.ISFF     = ua.indexOf('Firefox') != -1;\n    RGraph.ISOPERA  = ua.indexOf('Opera') != -1;\n    RGraph.ISCHROME = ua.indexOf('Chrome') != -1;\n    RGraph.ISSAFARI = ua.indexOf('Safari') != -1 && !RGraph.ISCHROME;\n    RGraph.ISWEBKIT = ua.indexOf('WebKit') != -1;\n\n    RGraph.ISIE   = ua.indexOf('Trident') > 0 || navigator.userAgent.indexOf('MSIE') > 0;\n    RGraph.ISIE6  = ua.indexOf('MSIE 6') > 0;\n    RGraph.ISIE7  = ua.indexOf('MSIE 7') > 0;\n    RGraph.ISIE8  = ua.indexOf('MSIE 8') > 0;\n    RGraph.ISIE9  = ua.indexOf('MSIE 9') > 0;\n    RGraph.ISIE10 = ua.indexOf('MSIE 10') > 0;\n    RGraph.ISOLD  = RGraph.ISIE6 || RGraph.ISIE7 || RGraph.ISIE8; // MUST be here\n    \n    RGraph.ISIE11UP = ua.indexOf('MSIE') == -1 && ua.indexOf('Trident') > 0;\n    RGraph.ISIE10UP = RGraph.ISIE10 || RGraph.ISIE11UP;\n    RGraph.ISIE9UP  = RGraph.ISIE9 || RGraph.ISIE10UP;\n\n\n\n\n    //\n    // Returns five values which are used as a nice scale\n    // \n    // 11/12/2018\n    // ==========\n    // This funtction doesn't appear to be being used\n    // any more - could remove it.\n    // \n    // @param  max int    The maximum value of the graph\n    // @param  obj object The graph object\n    // @return     array   An appropriate scale\n    //\n//    RGraph.getScale = function (max, obj)\n//    {\n//        var prefix = obj.type === 'hbar' ? 'xaxis' : 'yaxis';\n//\n//        //\n//        // Special case for 0\n//        //\n//        if (max == 0) {\n//            return ['0.2', '0.4', '0.6', '0.8', '1.0'];\n//        }\n//\n//        var original_max = max;\n//\n//        //\n//        // Manually do decimals\n//        //\n//        if (max <= 1) {\n//            if (max > 0.5) {\n//                return [0.2,0.4,0.6,0.8, Number(1).toFixed(1)];\n//\n//            } else if (max >= 0.1) {\n//                return obj.get(prefix + 'ScaleRound') ? [0.2,0.4,0.6,0.8,1] : [0.1,0.2,0.3,0.4,0.5];\n//\n//            } else {\n//\n//                var tmp = max;\n//                var exp = 0;\n//\n//                while (tmp < 1.01) {\n//                    exp += 1;\n//                    tmp *= 10;\n//                }\n//\n//                var ret = ['2e-' + exp, '4e-' + exp, '6e-' + exp, '8e-' + exp, '10e-' + exp];\n//\n//\n//                if (max <= ('5e-' + exp)) {\n//                    ret = ['1e-' + exp, '2e-' + exp, '3e-' + exp, '4e-' + exp, '5e-' + exp];\n//                }\n//\n//                return ret;\n//            }\n//        }\n//\n//        // Take off any decimals\n//        if (String(max).indexOf('.') > 0) {\n//            max = String(max).replace(/\\.\\d+$/, '');\n//        }\n//\n//        var interval = Math.pow(10, Number(String(Number(max)).length - 1));\n//        var topValue = interval;\n//\n//        while (topValue < max) {\n//            topValue += (interval / 2);\n//        }\n//\n//        // Handles cases where the max is (for example) 50.5\n//        if (Number(original_max) > Number(topValue)) {\n//            topValue += (interval / 2);\n//        }\n//\n//        // Custom if the max is greater than 5 and less than 10\n//        if (max < 10) {\n//            topValue = (Number(original_max) <= 5 ? 5 : 10);\n//        }\n//        \n//        //\n//        // Added 02/11/2010 to create \"nicer\" scales\n//        //\n//        if (obj && typeof(obj.get(prefix + 'ScaleRound')) == 'boolean' && obj.get(prefix + 'ScaleRound')) {\n//            topValue = 10 * interval;\n//        }\n//\n//        return [topValue * 0.2, topValue * 0.4, topValue * 0.6, topValue * 0.8, topValue];\n//    };\n\n\n\n\n\n\n\n\n    //\n    // Returns an appropriate scale. The return value is actualy an object consisting of:\n    //  scale.max\n    //  scale.min\n    //  scale.scale\n    // \n    // @param  obj opt An object obj object  The graph object\n    // @param  prop object An object consisting of configuration properties\n    //\n    // OR\n    //\n    // @param  opt object An object consisting of:\n    //                     object  - The chart object\n    //                     options - Options for the function\n    //\n    // @return     object  An object containg scale information\n    //\n    RGraph.getScale2 =\n    RGraph.getScale  = function (args)\n    {\n        var prop         = args.object.properties,\n            numlabels    = typeof args.options['scale.labels.count'] == 'number' ? args.options['scale.labels.count'] : 5,\n            units_pre    = typeof args.options['scale.units.pre'] == 'string' ? args.options['scale.units.pre'] : '',\n            units_post   = typeof args.options['scale.units.post'] == 'string' ? args.options['scale.units.post'] : '',\n            max          = Number(args.options['scale.max']),\n            min          = typeof args.options['scale.min'] == 'number' ? args.options['scale.min'] : 0,\n            strict       = args.options['scale.strict'],\n            decimals     = Number(args.options['scale.decimals']), // Sometimes the default is null\n            point        = args.options['scale.point'], // Default is a string in all chart libraries so no need to cast it\n            thousand     = args.options['scale.thousand'], // Default is a string in all chart libraries so no need to cast it\n            original_max = max,\n            round        = args.options['scale.round'],\n            scale        = {max:1,labels:[],values:[]},\n            formatter    = args.options['scale.formatter'];\n\n            // Determine any prefix to use\n            prefix = args.object.type === 'hbar' ? 'xaxis' : 'yaxis';\n            prefix = args.object.type === 'odo' ? '' : prefix;\n\n\n\n\n\n        //\n        // Special case for 0\n        // \n        // ** Must be first **\n        //\n        if (!max) {\n\n            var max   = 1;\n\n            for (var i=0; i<numlabels; ++i) {\n\n                var label = ((((max - min) / numlabels) + min) * (i + 1)).toFixed(decimals);\n\n                scale.labels.push(units_pre + label + units_post);\n                scale.values.push(parseFloat(label))\n            }\n\n        //\n        // Manually do decimals\n        //\n        } else if (max <= 1 && !strict) {\n\n            var arr = [\n                1,0.5,\n                0.10,0.05,\n                0.010,0.005,\n                0.0010,0.0005,\n                0.00010,0.00005,\n                0.000010,0.000005,\n                0.0000010,0.0000005,\n                0.00000010,0.00000005,\n                0.000000010,0.000000005,\n                0.0000000010,0.0000000005,\n                0.00000000010,0.00000000005,\n                0.000000000010,0.000000000005,\n                0.0000000000010,0.0000000000005\n            ], vals = [];\n\n\n\n            for (var i=0; i<arr.length; ++i) {\n                if (max > arr[i]) {\n                    i--;\n                    break;\n                }\n            }\n\n\n            scale.max = arr[i]\n            scale.labels = [];\n            scale.values = [];\n        \n            for (var j=0; j<numlabels; ++j) {\n\n                var value = ((((arr[i] - min) / numlabels) * (j + 1)) + min).toFixed(decimals);\n\n                scale.values.push(value);\n                scale.labels.push(RGraph.numberFormat({\n                    object:    args.object,\n                    number:    value,\n                    unitspre:  units_pre,\n                    unitspost: units_post,\n                    thousand:  thousand,\n                    point:     point,\n                    formatter: formatter,\n                    decimals:  decimals\n                }));\n            }\n\n\n\n\n        } else if (!strict) {\n\n            //\n            // Now comes the scale handling for integer values\n            //\n\n            // This accommodates decimals by rounding the max up to the next integer\n            max = Math.ceil(max);\n\n            var interval = Math.pow(10, Math.max(1, Number(String(Number(max) - Number(min)).length - 1)) );\n\n            var topValue = interval;\n\n            while (topValue < max) {\n                topValue += (interval / 2);\n            }\n\n            // Handles cases where the max is (for example) 50.5\n            if (Number(original_max) > Number(topValue)) {\n                topValue += (interval / 2);\n            }\n\n            // Custom if the max is greater than 5 and less than 10\n            if (max <= 10) {\n                topValue = (Number(original_max) <= 5 ? 5 : 10);\n            }\n    \n    \n            // Added 02/11/2010 to create \"nicer\" scales\n            if (args.object && typeof round == 'boolean' && round) {\n                topValue = 10 * interval;\n            }\n\n            scale.max = topValue;\n\n            // Now generate the scale. Temporarily set the objects scaleDecimal and scalePoint to those\n            // that we've been given as the number_format functuion looks at those instead of using\n            // arguments.\n            var tmp_point    = prop[prefix + 'ScalePoint'];\n            var tmp_thousand = prop[prefix + 'ScaleThousand'];\n\n            args.object.set(prefix + 'scaleThousand', thousand);\n            args.object.set(prefix + 'scalePoint', point);\n\n\n            for (var i=0; i<numlabels; ++i) {\n                scale.labels.push(RGraph.numberFormat({\n                    object:    args.object,\n                    number:    ((((i+1) / numlabels) * (topValue - min)) + min).toFixed(decimals),\n                    unitspre:  units_pre,\n                    unitspost: units_post,\n                    point:     point,\n                    thousand:  thousand,\n                    formatter: formatter\n                }) );\n                scale.values.push(((((i+1) / numlabels) * (topValue - min)) + min).toFixed(decimals));\n            }\n\n            args.object.set(prefix + 'scaleThousand', tmp_thousand);\n            args.object.set(prefix + 'scalePoint', tmp_point);\n\n        } else if (typeof max == 'number' && strict) {\n\n            //\n            // ymax is set and also strict\n            //\n            for (var i=0; i<numlabels; ++i) {\n                scale.labels.push(RGraph.numberFormat({\n                    object:    args.object,\n                    number:    ((((i+1) / numlabels) * (max - min)) + min).toFixed(decimals),\n                    unitspre:  units_pre,\n                    unitspost: units_post,\n                    thousand:  thousand,\n                    point:     point,\n                    formatter: formatter\n                }));\n\n                scale.values.push(\n                    ((((i+1) / numlabels) * (max - min)) + min).toFixed(decimals)\n                );\n            }\n\n            // ???\n            scale.max = max;\n        }\n\n\n        scale.units_pre  = units_pre;\n        scale.units_post = units_post;\n        scale.point      = point;\n        scale.decimals   = decimals;\n        scale.thousand   = thousand;\n        scale.numlabels  = numlabels;\n        scale.round      = Boolean(round);\n        scale.min        = min;\n        scale.formatter  = formatter;\n\n        //\n        // Convert all of the scale values to numbers\n        //\n        for (var i=0; i<scale.values.length; ++i) {\n            scale.values[i] = parseFloat(scale.values[i]);\n        }\n\n        return scale;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Parse a gradient thats in JSON format like this:\n    //\n    // Gradient({colors: [\"red\",\"white\"],x1:0,y1:25,x2:0,y2:275})\n    //\n    RGraph.parseJSONGradient = function (args)\n    {\n        var obj      = args.object,\n            def      = args.def, // The gradient definition\n            context  = args.object.context;\n\n        // Evaluate the JSON\n        def = eval(\"(\" + def + \")\");\n\n\n\n\n\n        // Create a radial gradient\n        if (typeof def.r1 === 'number' && typeof def.r2 === 'number') {\n            // Create the gradient\n            var grad = context.createRadialGradient(\n                def.x1, def.y1, def.r1,\n                def.x2, def.y2, def.r2\n            );\n        // Create a linear gradient\n        } else {\n            var grad = context.createLinearGradient(\n                def.x1, def.y1,\n                def.x2, def.y2\n            );\n        }\n\n\n\n\n        // Add the parts to the gradient\n        var diff = 1 / (def.colors.length - 1);\n        \n        grad.addColorStop(0, RGraph.trim(def.colors[0]));\n        \n        for (var j=1,len=def.colors.length; j<len; ++j) {\n            grad.addColorStop(j * diff, RGraph.trim(def.colors[j]));\n        }\n\n        return grad;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Converts an the truthy values to falsey values and vice-versa\n    //\n    RGraph.arrayInvert = function (arr)\n    {\n        for (var i=0,len=arr.length; i<len; ++i) {\n            arr[i] = !arr[i];\n        }\n\n        return arr;\n    };\n\n\n\n\n\n\n\n\n    //\n    // An arrayTrim function that removes the empty elements off\n    //both ends\n    //\n    RGraph.arrayTrim = function (arr)\n    {\n        var out = [], content = false;\n\n        // Trim the start\n        for (var i=0; i<arr.length; i++) {\n        \n            if (arr[i]) {\n                content = true;\n            }\n        \n            if (content) {\n                out.push(arr[i]);\n            }\n        }\n        \n        // Reverse the array and trim the start again\n        out = RGraph.arrayReverse(out);\n\n        var out2 = [], content = false ;\n        for (var i=0; i<out.length; i++) {\n        \n            if (out[i]) {\n                content = true;\n            }\n        \n            if (content) {\n                out2.push(out[i]);\n            }\n        }\n        \n        // Now reverse the array and return it\n        out2 = RGraph.arrayReverse(out2);\n\n        return out2;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Makes a clone of an ARRAY\n    // \n    // @param obj val The object to clone\n    //\n    RGraph.arrayClone =\n    RGraph.array_clone = function (obj)\n    {\n        if(obj === null || typeof obj !== 'object') {\n            return obj;\n        }\n\n        var temp = RGraph.isArray(obj) ? [] : {};\n\n        for (var i in obj) {\n            if (typeof i === 'string' || typeof i === 'number' ) {\n                if (typeof obj[i]  === 'number') {\n                    temp[i] = (function (arg) {return Number(arg);})(obj[i]);\n                \n                } else if (typeof obj[i]  === 'string') {\n                    temp[i] = (function (arg) {return String(arg);})(obj[i]);\n                \n                } else if (typeof obj[i] === 'function') {\n                    temp[i] = obj[i];\n                \n                } else {\n                    temp[i] = RGraph.arrayClone(obj[i]);\n                }\n            }\n        }\n\n        return temp;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Returns the maximum numeric value which is in an array. This function IS NOT\n    // recursive\n    // \n    // @param  array arr The array (can also be a number, in which case it's returned as-is)\n    // @param  int       Whether to ignore signs (ie negative/positive)\n    // @return int       The maximum value in the array\n    //\n    RGraph.arrayMax =\n    RGraph.array_max = function (arr)\n    {\n        var max = null,\n            ma  = Math\n        \n        if (typeof arr === 'number') {\n            return arr;\n        }\n        \n        if (RGraph.isNull(arr)) {\n            return 0;\n        }\n\n        for (var i=0,len=arr.length; i<len; ++i) {\n            if (typeof arr[i] === 'number' && !isNaN(arr[i])) {\n\n                var val = arguments[1] ? Math.abs(arr[i]) : arr[i];\n                \n                if (typeof max === 'number') {\n                    max = Math.max(max, val);\n                } else {\n                    max = val;\n                }\n            }\n        }\n\n        return max;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Returns the minimum numeric value which is in an array\n    // \n    // @param  array arr The array (can also be a number, in which case it's returned as-is)\n    // @param  int       Whether to ignore signs (ie negative/positive)\n    // @return int       The minimum value in the array\n    //\n    RGraph.arrayMin = function (arr)\n    {\n        var max = null,\n            min = null,\n            ma  = Math;\n        \n        if (typeof arr === 'number') {\n            return arr;\n        }\n        \n        if (RGraph.isNull(arr)) {\n            return 0;\n        }\n\n        for (var i=0,len=arr.length; i<len; ++i) {\n            if (typeof arr[i] === 'number') {\n\n                var val = arguments[1] ? Math.abs(arr[i]) : arr[i];\n                \n                if (typeof min === 'number') {\n                    min = Math.min(min, val);\n                } else {\n                    min = val;\n                }\n            }\n        }\n\n        return min;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Returns the maximum value which is in an array\n    // \n    // @param  array arr The array\n    // @param  int   len The length to pad the array to\n    // @param  mixed     The value to use to pad the array (optional)\n    //\n    RGraph.arrayPad =\n    RGraph.array_pad = function (arr, len)\n    {\n        if (arr.length < len) {\n            var val = arguments[2] ? arguments[2] : null;\n            \n            for (var i=arr.length; i<len; i+=1) {\n                arr[i] = val;\n            }\n        }\n        \n        return arr;\n    };\n\n\n\n\n\n\n\n\n    //\n    // An array sum function\n    // \n    // @param  array arr The  array to calculate the total of\n    // @return int       The summed total of the arrays elements\n    //\n    RGraph.arraySum =\n    RGraph.array_sum = function (arr)\n    {\n        // Allow integers\n        if (typeof arr === 'number') {\n            return arr;\n        }\n        \n        // Account for null\n        if (RGraph.isNull(arr)) {\n            return 0;\n        }\n\n        var i, sum, len = arr.length;\n\n        for(i=0,sum=0;i<len;sum+=(arr[i++]||0));\n\n        return sum;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Takes any number of arguments and adds them to one big linear array\n    // which is then returned\n    // \n    // @param ... mixed The data to linearise. You can strings, booleans, numbers or arrays\n    //\n    RGraph.arrayLinearize =\n    RGraph.array_linearize = function ()\n    {\n        var arr  = [],\n            args = arguments\n\n        for (var i=0,len=args.length; i<len; ++i) {\n\n            if (typeof args[i] === 'object' && args[i]) {\n                for (var j=0,len2=args[i].length; j<len2; ++j) {\n                    var sub = RGraph.arrayLinearize(args[i][j]);\n                    \n                    for (var k=0,len3=sub.length; k<len3; ++k) {\n                        arr.push(sub[k]);\n                    }\n                }\n            } else {\n                arr.push(args[i]);\n            }\n        }\n\n        return arr;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Takes one off the front of the given array and returns the new array.\n    // \n    // @param array arr The array from which to take one off the front of array \n    // \n    // @return array The new array\n    //\n    RGraph.arrayShift =\n    RGraph.array_shift = function(arr)\n    {\n        var ret = [];\n        \n        for(var i=1,len=arr.length; i<len; ++i) {\n            ret.push(arr[i]);\n        }\n        \n        return ret;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Reverses the order of an array\n    // \n    // @param array arr The array to reverse\n    //\n    RGraph.arrayReverse =\n    RGraph.array_reverse = function (arr)\n    {\n        if (!arr) {\n            return;\n        }\n\n        var newarr=[];\n\n        for(var i=arr.length - 1; i>=0; i-=1) {\n            newarr.push(arr[i]);\n        }\n        \n        return newarr;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Returns the absolute value of a number. You can also pass in an\n    // array and it will run the abs() function on each element. It\n    // operates recursively so sub-arrays are also traversed.\n    // \n    // @param array arr The number or array to work on\n    //\n    RGraph.abs = function (value)\n    {\n        if (typeof value === 'string') {\n            value = parseFloat(value) || 0;\n        }\n\n        if (typeof value === 'number') {\n            return Math.abs(value);\n        }\n\n        if (typeof value === 'object') {\n            for (i in value) {\n                if (   typeof i === 'string'\n                    || typeof i === 'number'\n                    || typeof i === 'object') {\n\n                    value[i] = RGraph.abs(value[i]);\n                }\n            }\n            \n            return value;\n        }\n        \n        return 0;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Clears the canvas by setting the width. You can specify a colour if you wish.\n    // \n    // @param object canvas The canvas to clear\n    // @param mixed         Usually a color string to use to clear the canvas\n    //                      with - could also be a gradient object\n    //\n    RGraph.clear =\n    RGraph.Clear = function (canvas)\n    {\n        var obj     = canvas.__object__;\n        var context = canvas.getContext('2d');\n        var color   = arguments[1] || (obj && obj.get('clearto'));\n\n        if (!canvas) {\n            return;\n        }\n        \n        RGraph.fireCustomEvent(obj, 'onbeforeclear');\n\n        //\n        // Set the CSS display: to none for DOM text\n        //\n        if (RGraph.text.domNodeCache && RGraph.text.domNodeCache[canvas.id]) {\n            for (var i in RGraph.text.domNodeCache[canvas.id]) {\n                \n                var el = RGraph.text.domNodeCache[canvas.id][i];\n    \n                if (el && el.style) {\n                    el.style.display = 'none';\n                }\n            }\n        }\n\n        //\n        // Can now clear the canvas back to fully transparent\n        //\n        if (   !color\n            || (color && color === 'rgba(0,0,0,0)' || color === 'transparent')\n            ) {\n\n            context.clearRect(-100,-100,canvas.width + 200, canvas.height + 200);\n\n            // Reset the globalCompositeOperation\n            context.globalCompositeOperation = 'source-over';\n\n        } else if (color) {\n\n            RGraph.path(\n                context,\n                'fs % fr -100 -100 % %',\n                color,\n                canvas.width + 200,\n                canvas.height + 200\n            );\n        \n        } else {\n            RGraph.path(\n                context,\n                'fs % fr -100 -100 % %',\n                obj.get('clearto'),\n                canvas.width + 200,\n                canvas.height + 200\n            );\n        }\n        \n        //if (RGraph.clearAnnotations) {\n            //RGraph.clearAnnotations(canvas.id);\n        //}\n        \n        //\n        // This removes any background image that may be present\n        //\n        if (RGraph.Registry.get('background.image.' + canvas.id)) {\n            var img = RGraph.Registry.get('background.image.' + canvas.id);\n            img.style.position = 'absolute';\n            img.style.left     = '-10000px';\n            img.style.top      = '-10000px';\n        }\n        \n        //\n        // This hides the tooltip that is showing IF it has the same canvas ID as\n        // that which is being cleared\n        //\n        if (RGraph.Registry.get('tooltip') && obj && !obj.get('tooltipsNohideonclear')) {\n            RGraph.hideTooltip(canvas);\n        }\n\n        //\n        // Set the cursor to default\n        //\n        canvas.style.cursor = 'default';\n\n        RGraph.fireCustomEvent(obj, 'onclear');\n    };\n\n\n\n\n\n\n\n\n    //\n    // Draws the title of the graph\n    // \n    // @param object  canvas The canvas object\n    // @param string  text   The title to write\n    // @param integer margin The size of the margin\n    // @param integer        The center X point (optional - if not given it will be generated from the canvas width)\n    // @param integer        Size of the text. If not given it will be 14\n    // @param object         An optional object which has canvas and context properties to use instead of those on\n    //                       the obj argument (so as to enable caching)\n    //\n    RGraph.drawTitle =\n    RGraph.DrawTitle = function (obj, text, marginTop)\n    {\n        var canvas       = obj.canvas,\n            context      = obj.context,\n            prop         = obj.properties,\n            marginLeft   = prop.marginLeft,\n            marginRight  = prop.marginRight,\n            marginTop    = marginTop,\n            marginBottom = prop.marginBottom,\n            centerx      = (arguments[3] ? arguments[3] : ((canvas.width - marginLeft - marginRight) / 2) + marginLeft),\n            keypos       = prop.keyPosition,\n            vpos         = prop.titleVpos,\n            hpos         = prop.titleHpos,\n            bgcolor      = prop.titleBackground,\n            x            = prop.titleX,\n            y            = prop.titleY,\n            halign       = 'center',\n            valign       = 'center',\n            \n            textConf = RGraph.getTextConf({\n                object: obj,\n                prefix: 'title'\n            });\n\n            var size   = textConf.size,\n                bold   = textConf.bold,\n                italic = textConf.italic;\n                \n                // Set bold to true for the title if it hasn't been set by\n                // the user \n                if (RGraph.isNull(bold)) {\n                    textConf.bold = true;\n                    bold          = true;\n                }\n\n\n\n        // Account for 3D effect by faking the key position\n        if (obj.type == 'bar' && prop.variant == '3d') {\n            keypos = 'margin';\n        }\n\n        context.beginPath();\n        context.fillStyle = textConf.color ? textConf.color : 'black';\n\n\n        //\n        // Vertically center the text if the key is not present\n        //\n        if (keypos && keypos != 'margin') {\n            var valign = 'center';\n\n        } else if (!keypos) {\n            var valign = 'center';\n\n       } else {\n            var valign = 'bottom';\n        }\n\n\n\n\n\n        // if titleVpos is a number, use that\n        if (typeof prop.titleVpos === 'number') {\n            vpos = prop.titleVpos * marginTop;\n\n            if (prop.xaxisPosition === 'top') {\n                vpos = prop.titleVpos * marginBottom + marginTop + (canvas.height - marginTop - marginBottom);\n            }\n\n        } else {\n            vpos = marginTop - size - 5;\n\n            if (prop.xaxisPosition === 'top') {\n                vpos = canvas.height  - marginBottom + size + 5;\n            }\n        }\n\n        // if titleHpos is a number, use that. It's multiplied with the (entire) canvas width\n        if (typeof hpos === 'number') {\n            centerx = hpos * canvas.width;\n        }\n\n        //\n        // Now the titleX and titleY settings override (is set) the above\n        //\n        if (typeof x === 'number') centerx = x;\n        if (typeof y === 'number') vpos    = y;\n        \n        if (typeof x === 'string') centerx += parseFloat(x);\n        if (typeof y === 'string') vpos    += parseFloat(y);\n\n\n\n\n        //\n        // Horizontal alignment can now (Jan 2013) be specified\n        //\n        if (typeof prop.titleHalign === 'string') {\n            halign = prop.titleHalign;\n        }\n        \n        //\n        // Vertical alignment can now (Jan 2013) be specified\n        //\n        if (typeof prop.titleValign === 'string') {\n            valign = prop.titleValign;\n        }\n\n\n\n\n        \n        // Set the colour\n        if (typeof textConf.color !== null) {\n            \n            var oldColor = context.fillStyle,\n                newColor = textConf.color;\n            \n            context.fillStyle = newColor ? newColor : 'black';\n        }\n\n        // Draw the title\n        var ret = RGraph.text({\n        \n            object: obj,\n\n            font:    textConf.font,\n            size:    textConf.size,\n            color:   textConf.color,\n            bold:    textConf.bold,\n            italic:  textConf.italic,\n\n            x:       centerx,\n            y:       vpos,\n            text:    text,\n            valign:  valign,\n            halign:  halign,\n            bounding:bgcolor != null,\n            'bounding.fill':bgcolor,\n            tag:     'title',\n            marker:  false\n        });\n\n        // Reset the fill colour\n        context.fillStyle = oldColor;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Gets the mouse X/Y coordinates relative to the canvas\n    // \n    // @param object e The event object. As such this method should be used in an event listener.\n    //\n    RGraph.getMouseXY = function(e)\n    {\n        // This is necessary foe IE9\n        if (!e.target) {\n            return;\n        }\n\n        var el      = e.target,\n            canvas  = el,\n            caStyle = canvas.style,\n            offsetX = 0,\n            offsetY = 0,\n            x,\n            y,\n            borderLeft  = parseInt(caStyle.borderLeftWidth) || 0,\n            borderTop   = parseInt(caStyle.borderTopWidth) || 0,\n            paddingLeft = parseInt(caStyle.paddingLeft) || 0,\n            paddingTop  = parseInt(caStyle.paddingTop) || 0,\n            additionalX = borderLeft + paddingLeft,\n            additionalY = borderTop + paddingTop;\n\n\n        if (typeof e.offsetX === 'number' && typeof e.offsetY === 'number') {\n\n\n            if (!RGraph.ISIE && !RGraph.ISOPERA) {\n                x = e.offsetX - borderLeft - paddingLeft;\n                y = e.offsetY - borderTop - paddingTop;\n            \n            } else if (RGraph.ISIE) {\n                x = e.offsetX - paddingLeft;\n                y = e.offsetY - paddingTop;\n            \n            } else {\n                x = e.offsetX;\n                y = e.offsetY;\n            }   \n\n        } else {\n\n            if (typeof el.offsetParent !== 'undefined') {\n                do {\n                    offsetX += el.offsetLeft;\n                    offsetY += el.offsetTop;\n                } while ((el = el.offsetParent));\n            }\n\n            x = e.pageX - offsetX - additionalX;\n            y = e.pageY - offsetY - additionalY;\n\n            x -= (2 * (parseInt(document.body.style.borderLeftWidth) || 0));\n            y -= (2 * (parseInt(document.body.style.borderTopWidth) || 0));\n\n            //x += (parseInt(caStyle.borderLeftWidth) || 0);\n            //y += (parseInt(caStyle.borderTopWidth) || 0);\n        }\n\n        // We return a javascript array with x and y defined\n        return [x, y];\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function returns a two element array of the canvas x/y position in\n    // relation to the page\n    // \n    // @param object canvas\n    //\n    RGraph.getCanvasXY = function (canvas)\n    {\n        var x  = 0;\n        var y  = 0;\n        var el = canvas; // !!!\n\n        do {\n\n            x += el.offsetLeft;\n            y += el.offsetTop;\n            \n            // ACCOUNT FOR TABLES IN wEBkIT\n            if (el.tagName.toLowerCase() == 'table' && (RGraph.ISCHROME || RGraph.ISSAFARI)) {\n                x += parseInt(el.border) || 0;\n                y += parseInt(el.border) || 0;\n            }\n\n            el = el.offsetParent;\n\n        } while (el && el.tagName.toLowerCase() != 'body');\n\n\n        var paddingLeft = canvas.style.paddingLeft ? parseInt(canvas.style.paddingLeft) : 0;\n        var paddingTop  = canvas.style.paddingTop ? parseInt(canvas.style.paddingTop) : 0;\n        var borderLeft  = canvas.style.borderLeftWidth ? parseInt(canvas.style.borderLeftWidth) : 0;\n        var borderTop   = canvas.style.borderTopWidth  ? parseInt(canvas.style.borderTopWidth) : 0;\n\n        if (navigator.userAgent.indexOf('Firefox') > 0) {\n            x += parseInt(document.body.style.borderLeftWidth) || 0;\n            y += parseInt(document.body.style.borderTopWidth) || 0;\n        }\n\n        return [x + paddingLeft + borderLeft, y + paddingTop + borderTop];\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function determines whther a canvas is fixed (CSS positioning) or not. If not it returns\n    // false. If it is then the element that is fixed is returned (it may be a parent of the canvas).\n    // \n    // @return Either false or the fixed positioned element\n    //\n    RGraph.isFixed = function (canvas)\n    {\n        var obj = canvas;\n        var i = 0;\n\n        while (obj && obj.tagName.toLowerCase() != 'body' && i < 99) {\n\n            if (obj.style.position == 'fixed') {\n                return obj;\n            }\n            \n            obj = obj.offsetParent;\n        }\n\n        return false;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Registers a graph object (used when the canvas is redrawn)\n    // \n    // @param object obj The object to be registered\n    //\n    RGraph.register =\n    RGraph.Register = function (obj)\n    {\n        // Checking this property ensures the object is only registered once\n        if (!obj.get('noregister') && obj.get('register') !== false) {\n            // As of 21st/1/2012 the object registry is now used\n            RGraph.ObjectRegistry.add(obj);\n            obj.set('register', false);\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Causes all registered objects to be redrawn\n    // \n    // @param string An optional color to use to clear the canvas\n    //\n    RGraph.redraw =\n    RGraph.Redraw = function ()\n    {\n        var objectRegistry = RGraph.ObjectRegistry.objects.byCanvasID;\n\n        // Get all of the canvas tags on the page\n        var tags = document.getElementsByTagName('canvas');\n\n        for (var i=0,len=tags.length; i<len; ++i) {\n            if (tags[i] && tags[i].__object__ && tags[i].__object__.isRGraph) {\n                \n                // Only clear the canvas if it's not Trace'ing - this applies to the Line/Scatter Trace effects\n                if (!tags[i].noclear) {\n                    RGraph.clear(tags[i], arguments[0] ? arguments[0] : null);\n                }\n            }\n        }\n\n        // Go through the object registry and redraw *all* of the canvas'es that have been registered\n        for (var i=0,len=objectRegistry.length; i<len; ++i) {\n            if (objectRegistry[i]) {\n                var id = objectRegistry[i][0];\n                objectRegistry[i][1].draw();\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Causes all registered objects ON THE GIVEN CANVAS to be redrawn\n    // \n    // @param canvas object The canvas object to redraw\n    // @param        bool   Optional boolean which defaults to true and determines whether to clear the canvas\n    //\n    RGraph.redrawCanvas =\n    RGraph.RedrawCanvas = function (canvas)\n    {\n        var objects = RGraph.ObjectRegistry.getObjectsByCanvasID(canvas.id);\n\n        //\n        // First clear the canvas\n        //\n        if (!arguments[1] || (typeof arguments[1] === 'boolean' && !arguments[1] == false) ) {\n            var color = arguments[2] || canvas.__object__.get('clearto') || 'transparent';\n            RGraph.clear(canvas, color);\n        }\n\n        //\n        // Now redraw all the charts associated with that canvas\n        //\n        for (var i=0,len=objects.length; i<len; ++i) {\n            if (objects[i]) {\n                if (objects[i] && objects[i].isRGraph) { // Is it an RGraph object ??\n                    objects[i].draw();\n                }\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function draws the background for the bar chart, line chart and scatter chart.\n    // \n    // @param  object obj The graph object\n    //\n    RGraph.Background.draw =\n    RGraph.Background.Draw =\n    RGraph.background.draw =\n    RGraph.background.Draw = function (obj)\n    {\n        var prop         = obj.properties,\n            height       = 0,\n            marginLeft   = obj.marginLeft,\n            marginRight  = obj.marginRight,\n            marginTop    = obj.marginTop,\n            marginBottom = obj.marginBottom,\n            variant      = prop.variant\n\n\n            obj.context.fillStyle = prop.textColor;\n\n            // If it's a bar and 3D variant, translate\n            if (variant == '3d') {\n                obj.context.save();\n                obj.context.translate(prop.variantThreedOffsetx, -1 * prop.variantThreedOffsety);\n            }\n    \n            // X axis title\n            if (typeof prop.xaxisTitle === 'string' && prop.xaxisTitle.length) {\n            \n                var size   = prop.textSize + 2;\n                //var font   = prop.textFont;\n                //var bold   = prop.xaxisTitleBold;\n                //var italic = prop.xaxisTitleItalic;\n\n                //if (typeof prop.xaxisTitleSize === 'number') {\n                //    size = prop.xaxisTitleSize;\n                //}\n    \n                //if (typeof prop.xaxisTitleFont === 'string') {\n                //    font = prop.xaxisTitleFont;\n                //}\n                \n                var hpos = ((obj.canvas.width - marginLeft - marginRight) / 2) + marginLeft;\n                var vpos = obj.canvas.height - marginBottom + 25;\n                \n                if (typeof prop.xaxisTitlePos === 'number') {\n                    vpos = obj.canvas.height - (marginBottom * prop.xaxisTitlePos);\n                }\n    \n    \n    \n    \n                // Specifically specified X/Y positions\n                if (typeof prop.xaxisTitleX === 'number') {\n                    hpos = prop.xaxisTitleX;\n                }\n    \n                if (typeof prop.xaxisTitleY === 'number') {\n                    vpos = prop.xaxisTitleY;\n                }\n                \n                // Get the text configuration\n                var textConf = RGraph.getTextConf({\n                    object: obj,\n                    prefix: 'xaxisTitle'\n                });\n    \n\n                RGraph.text({\n                \n                  object: obj,\n\n                    font:   textConf.font,\n                    size:   textConf.size,\n                    color:  textConf.color,\n                    bold:   textConf.bold,\n                    italic: textConf.italic,\n\n                    x:      hpos,\n                    y:      vpos,\n                    text:   prop.xaxisTitle,\n                    halign: 'center',\n                    valign: 'top',\n                    tag:    'xaxis.title'\n                });\n            }\n    \n            // Y axis title\n            if (typeof(prop.yaxisTitle) === 'string' && prop.yaxisTitle.length) {\n\n                var size   = prop.textSize + 2;\n                var font   = prop.textFont;\n                var italic = prop.textItalic;\n                var angle  = 270;\n                var bold   = prop.yaxisTitleBold;\n                var color  = prop.yaxisTitleColor;\n\n                if (typeof prop.yaxisTitlePos == 'number') {\n                    var yaxis_title_pos = prop.yaxisTitlePos * marginLeft;\n                } else if (obj.type === 'hbar' && RGraph.isNull(prop.yaxisTitlePos) ) {\n                    var yaxis_title_pos = prop.marginLeft - obj.yaxisLabelsSize;\n                } else {\n\n                    if (obj && obj.scale2) {\n\n                        var yaxisTitleDimensions = RGraph.measureText({\n                            text: obj.scale2.labels[obj.scale2.labels.length - 1],\n                            bold: typeof prop.yaxisScaleBold === 'boolean' ? prop.yaxisScaleBold : prop.textBold,\n                            font: prop.yaxisScaleFont || prop.textFont,\n                            size: typeof prop.yaxisScaleSize === 'number' ? prop.yaxisScaleSize : prop.textSize\n                        });\n\n                    } else {\n                        // This is here to allow for the drawing API background\n                        // object\n                        yaxisTitleDimensions = [0,0];\n                    }\n\n                    var yaxis_title_pos = prop.marginLeft - yaxisTitleDimensions[0] - 7;\n                }\n                if (typeof prop.yaxisTitleSize === 'number') {\n                    size = prop.yaxisTitleSize;\n                }\n    \n                if (typeof prop.yaxisTitleItalic === 'boolean') {\n                    italic = prop.yaxisTitleItalic;\n                }\n    \n                if (typeof prop.yaxisTitleFont === 'string') {\n                    font = prop.yaxisTitleFont;\n                }\n                \n                \n\n                if (   prop.yaxisTitleAlign == 'right'\n                    || prop.yaxisTitlePosition == 'right'\n                    || (obj.type === 'hbar' && prop.yaxisPosition === 'right' && typeof prop.yaxisTitleAlign === 'undefined' && typeof prop.yaxisTitlePosition === 'undefined')\n                   ) {\n\n                    angle = 90;\n                    yaxis_title_pos = typeof prop.yaxisTitlePos === 'number'\n                                          ? (obj.canvas.width - marginRight) + (prop.yaxisTitlePos * marginRight)\n                                          : obj.canvas.width - marginRight + (prop.yaxisLabelsSize || prop.textSize) + 10;\n\n                }\n\n                var y = ((obj.canvas.height - marginTop - marginBottom) / 2) + marginTop;\n\n                // Specifically specified X/Y positions\n                if (typeof prop.yaxisTitleX === 'number') {\n                    yaxis_title_pos = prop.yaxisTitleX;\n                }\n    \n                if (typeof prop.yaxisTitleY === 'number') {\n                    y = prop.yaxisTitleY;\n                }\n\n                obj.context.fillStyle = color;\n\n                // Get the text configuration\n                var textConf = RGraph.getTextConf({\n                    object: obj,\n                    prefix: 'yaxisTitle'\n                });\n\n\n                RGraph.text({\n                \n                  object: obj,\n                \n                    font:   textConf.font,\n                    size:   textConf.size,\n                    color:  textConf.color,\n                    bold:   textConf.bold,\n                    italic: textConf.italic,\n\n                    x:          yaxis_title_pos,\n                    y:          y,\n                    valign:     'bottom',\n                    halign:     'center',\n                    angle:      angle,\n                    text:       prop.yaxisTitle,\n                    tag:        'yaxis.title',\n                    accessible: false\n                });\n            }\n    \n            //\n            // If the background color is spec ified - draw that. It's a rectangle that fills the\n            // entire area within the margins\n            //\n            var bgcolor = prop.backgroundColor;\n\n            if (bgcolor) {\n                obj.context.fillStyle = bgcolor;\n                obj.context.fillRect(marginLeft + 0.5, marginTop + 0.5, obj.canvas.width - marginLeft - marginRight, obj.canvas.height - marginTop - marginBottom);\n            }\n\n\n\n\n\n\n\n            //\n            // Draw horizontal background bars\n            //\n            var numbars   = (prop.yaxisLabelsCount || 5);\n\n            // If the backbgroundBarcount property is set use that\n            if (typeof prop.backgroundBarsCount === 'number') {\n                numbars = prop.backgroundBarsCount;\n            }\n\n            // Calculate the height of the bars\n            var barHeight = (obj.canvas.height - marginBottom - marginTop) / numbars;\n\n            obj.context.beginPath();\n                obj.context.fillStyle   = prop.backgroundBarsColor1;\n                obj.context.strokeStyle = obj.context.fillStyle;\n                height = (obj.canvas.height - marginBottom);\n\n                for (var i=0; i<numbars; i+=2) {\n                    obj.context.rect(marginLeft,\n                        (i * barHeight) + marginTop,\n                        obj.canvas.width - marginLeft - marginRight,\n                        barHeight\n                    );\n                }\n            obj.context.fill();\n\n\n\n            obj.context.beginPath();\n                obj.context.fillStyle   = prop.backgroundBarsColor2;\n                obj.context.strokeStyle = obj.context.fillStyle;\n        \n                for (var i=1; i<numbars; i+=2) {\n                    obj.context.rect(\n                        marginLeft,\n                        (i * barHeight) + marginTop,\n                        obj.canvas.width - marginLeft - marginRight,\n                        barHeight\n                    );\n                }\n            \n            obj.context.fill();\n            \n            // Close any errantly open path\n            obj.context.beginPath();\n\n\n\n\n\n\n\n\n\n\n\n\n            //\n            // The background grid is cached\n            //\n            var func = function (obj, cacheCanvas, cacheContext)\n            {\n                // Draw the background grid\n                if (prop.backgroundGrid) {\n                \n                    prop.backgroundGridHlinesCount += 0.0001;\n\n                    // If autofit is specified, use the .numhlines and .numvlines along with the width to work\n                    // out the hsize and vsize\n                    if (prop.backgroundGridAutofit) {\n\n                        //\n                        // Align the grid to the tickmarks\n                        //\n                        if (prop.backgroundGridAutofitAlign) {\n                        \n                            // Align the horizontal lines\n                            if (obj.type === 'hbar') {\n                                obj.set('backgroundGridHlinesCount', obj.data.length);\n                            }\n\n                            // Align the vertical lines for the line\n                            if (obj.type === 'line') {\n                                if (typeof prop.backgroundGridVlinesCount === 'number') {\n                                    // Nada\n                                } else if (prop.xaxisLabels && prop.xaxisLabels.length) {\n                                    obj.set('backgroundGridVlinesCount', prop.xaxisLabels.length - 1);\n                                } else {\n                                    obj.set('backgroundGridVlinesCount', obj.data[0].length - 1);\n                                }\n                            } else if (obj.type === 'waterfall') {\n                                obj.set(\n                                    'backgroundGridVlinesCount',\n                                    obj.data.length + (prop.total ? 1 : 0)\n                                );\n\n                            // Align the vertical lines for the bar\n                            } else if (obj.type === 'bar') {\n                                \n                                // 13/12/2018\n                                //\n                                // Updated to be the same as the number of data points\n                                //\n                                obj.set('backgroundGridVlinesCount', obj.data.length);\n                            \n                            // Align the vertical lines for the Scatter\n                            } else if (obj.type === 'scatter') {\n                                if (typeof prop.backgroundGridVlinesCount !== 'number') {\n                                    \n                                    // Set the number of grid lines to the same\n                                    // as the number of labels\n                                    if (RGraph.isArray(prop.xaxisLabels) && prop.xaxisLabels.length) {\n                                        obj.set('backgroundGridVlinesCount', prop.xaxisLabels.length);\n                                    \n                                    // No labels - set the number of grid lines\n                                    // to 10\n                                    } else {\n                                        obj.set('backgroundGridVlinesCount', 10);\n                                    }\n                                }\n\n    \n                            // Gantt\n                            } else if (obj.type === 'gantt') {\n\n                                if (typeof obj.get('backgroundGridVlinesCount') === 'number') {\n                                    // Nothing to do here\n                                } else {\n                                    obj.set('backgroundGridVlinesCount', prop.xaxisScaleMax);\n                                }\n    \n                                obj.set('backgroundGridHlinesCount', obj.data.length);\n                            \n                            // HBar\n                            } else if (obj.type === 'hbar' && RGraph.isNull(prop.backgroundGridHlinesCount) ) {\n                                obj.set('backgroundGridHlinesCount', obj.data.length);\n                            }\n                        }\n    \n                        var vsize = ((cacheCanvas.width - marginLeft - marginRight)) / prop.backgroundGridVlinesCount;\n                        var hsize = (cacheCanvas.height - marginTop - marginBottom) / prop.backgroundGridHlinesCount;\n\n                        obj.set('backgroundGridVsize', vsize);\n                        obj.set('backgroundGridHsize', hsize);\n                    }\n\n                    obj.context.beginPath();\n                    cacheContext.lineWidth   = prop.backgroundGridLinewidth ? prop.backgroundGridLinewidth : 1;\n                    cacheContext.strokeStyle = prop.backgroundGridColor;\n\n                    // Dashed background grid\n                    if (prop.backgroundGridDashed && typeof cacheContext.setLineDash == 'function') {\n                        cacheContext.setLineDash([3,5]);\n                    }\n                    \n                    // Dotted background grid\n                    if (prop.backgroundGridDotted && typeof cacheContext.setLineDash == 'function') {\n                        cacheContext.setLineDash([1,3]);\n                    }\n                    \n                    obj.context.beginPath();\n        \n        \n                    // Draw the horizontal lines\n                    if (prop.backgroundGridHlines) {\n                        height = (cacheCanvas.height - marginBottom)\n                        var hsize = prop.backgroundGridHsize;\n                        for (y=marginTop; y<=height; y+=hsize) {\n                            cacheContext.moveTo(marginLeft, Math.round(y));\n                            cacheContext.lineTo(obj.canvas.width - marginRight, Math.round(y));\n                        }\n                    }\n        \n                    // Draw the vertical lines\n\n                    if (prop.backgroundGridVlines) {\n\n                        var width = (cacheCanvas.width - marginRight);\n                        var vsize = prop.backgroundGridVsize;\n\n                        for (var x=marginLeft; Math.round(x)<=width; x+=vsize) {\n                            cacheContext.moveTo(Math.round(x), marginTop);\n                            cacheContext.lineTo(Math.round(x), obj.canvas.height - marginBottom);\n                        }\n                    }\n        \n                    if (prop.backgroundGridBorder) {\n                        // Make sure a rectangle, the same colour as the grid goes around the graph\n                        cacheContext.strokeStyle = prop.backgroundGridColor;\n                        cacheContext.strokeRect(Math.round(marginLeft), Math.round(marginTop), obj.canvas.width - marginLeft - marginRight, obj.canvas.height - marginTop - marginBottom);\n                    }\n                }\n    \n                cacheContext.stroke();\n    \n    \n    \n                // Ensure the grid is drawn before continuing\n                cacheContext.beginPath();\n                cacheContext.closePath();\n            }\n            \n            // Now a cached draw in newer browsers\n            RGraph.cachedDraw(obj, obj.uid + '_background', func);\n\n\n\n\n\n\n\n            // If it's a bar and 3D variant, translate\n            if (variant == '3d') {\n                obj.context.restore();\n            }\n\n            // Reset the line dash\n            if (typeof obj.context.setLineDash == 'function') {\n                obj.context.setLineDash([1,0]);\n            }\n    \n            obj.context.stroke();\n\n\n\n        // Draw the title if one is set\n        if ( typeof(obj.properties.title) == 'string') {\n\n            var prop = obj.properties;\n\n            RGraph.drawTitle(\n                obj,\n                prop.title,\n                obj.marginTop,\n                null,\n                prop.titleSize ? prop.titleSize : prop.textSize + 2,\n                obj\n            );\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Formats a number with thousand seperators so it's easier to read\n    // \n    // THESE ARE OLDER ARGS:\n    // \n    // @param  integer obj The chart object\n    // @param  integer num The number to format\n    // @param  string      The (optional) string to prepend to the string\n    // @param  string      The (optional) string to append to the string\n    // @return string      The formatted number\n    //\n    RGraph.numberFormat =\n    RGraph.number_format = function (opt)\n    {\n        var prop = opt.object.properties;\n\n\n\n        var i;\n        var prepend = opt.unitspre ? String(opt.unitspre) : '';\n        var append  = opt.unitspost ? String(opt.unitspost) : '';\n        var output  = '';\n        var decimal = '';\n        var decimal_seperator  = typeof opt.point    === 'string' ? opt.point    : '.';\n        var thousand_seperator = typeof opt.thousand === 'string' ? opt.thousand : ',';\n        RegExp.$1   = '';\n        var i,j;\n\n        if (typeof opt.formatter === 'function') {\n            return (opt.formatter)(opt);\n        }\n\n        // Ignore the preformatted version of \"1e-2\"\n        if (String(opt.number).indexOf('e') > 0) {\n            return String(prepend + String(opt.number) + append);\n        }\n\n        // We need then number as a string\n        opt.number = String(opt.number);\n\n        // Take off the decimal part - we re-append it later\n        if (opt.number.indexOf('.') > 0) {\n            var tmp    = opt.number;\n            opt.number = opt.number.replace(/\\.(.*)/, ''); // The front part of the number\n            decimal    = tmp.replace(/(.*)\\.(.*)/, '$2'); // The decimal part of the number\n        }\n\n        // Thousand seperator\n        //var seperator = arguments[1] ? String(arguments[1]) : ',';\n        var seperator = thousand_seperator;\n\n        // Work backwards adding the thousand seperators\n        //\n        // ** i is a local variable at this poin **\n        var foundPoint;\n        for (i=(opt.number.length - 1),j=0; i>=0; j++,i--) {\n            var character = opt.number.charAt(i);\n            \n            if ( j % 3 == 0 && j != 0) {\n                output += seperator;\n            }\n            \n            //\n            // Build the output\n            //\n            output += character;\n        }\n\n        //\n        // Now need to reverse the string\n        //\n        var rev = output;\n        output = '';\n        for (i=(rev.length - 1); i>=0; i--) {\n            output += rev.charAt(i);\n        }\n\n        // Tidy up\n        //output = output.replace(/^-,/, '-');\n        if (output.indexOf('-' + opt.thousand) == 0) {\n            output = '-' + output.substr(('-' + opt.thousand).length);\n        }\n\n        // Reappend the decimal\n        if (decimal.length) {\n            output =  output + decimal_seperator + decimal;\n            decimal = '';\n            RegExp.$1 = '';\n        }\n\n        // Minor bugette\n        if (output.charAt(0) == '-') {\n            output = output.replace(/-/, '');\n            prepend = '-' + prepend;\n        }\n        \n        // Get rid of leading commas\n        output = output.replace(/^,+/,'');\n\n        return prepend + output + append;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Draws horizontal coloured bars on something like the bar, line or scatter\n    //\n    RGraph.drawBars =\n    RGraph.DrawBars = function (obj)\n    {\n        var prop  = obj.properties;\n        var hbars = prop.backgroundHbars;\n\n        if (hbars === null) {\n            return;\n        }\n\n        //\n        // Draws a horizontal bar\n        //\n        obj.context.beginPath();\n\n        for (var i=0,len=hbars.length; i<len; ++i) {\n        \n            var start  = hbars[i][0];\n            var length = hbars[i][1];\n            var color  = hbars[i][2];\n            \n\n            // Perform some bounds checking\n            if(RGraph.is_null(start))start = obj.scale2.max\n            if (start > obj.scale2.max) start = obj.scale2.max;\n            if (RGraph.isNull(length)) length = obj.scale2.max - start;\n            if (start + length > obj.scale2.max) length = obj.scale2.max - start;\n            if (start + length < (-1 * obj.scale2.max) ) length = (-1 * obj.scale2.max) - start;\n\n            if (prop.xaxisPosition == 'center' && start == obj.scale2.max && length < (obj.scale2.max * -2)) {\n                length = obj.scale2.max * -2;\n            }\n\n\n            //\n            // Draw the bar\n            //\n            var x = prop.marginLeft;\n            var y = obj.getYCoord(start);\n            var w = obj.canvas.width - prop.marginLeft - prop.marginRight;\n            var h = obj.getYCoord(start + length) - y;\n\n            // Accommodate Opera :-/\n            if (RGraph.ISOPERA != -1 && prop.xaxisPosition == 'center' && h < 0) {\n                h *= -1;\n                y = y - h;\n            }\n\n            //\n            // Account for X axis at the top\n            //\n            if (prop.xaxisPosition == 'top') {\n                y  = obj.canvas.height - y;\n                h *= -1;\n            }\n\n            obj.context.fillStyle = color;\n            obj.context.fillRect(x, y, w, h);\n        }\n\n\n\n\n//\n//            // If the X axis is at the bottom, and a negative max is given, warn the user\n//            if (obj.get('xaxisPosition') == 'bottom' && (hbars[i][0] < 0 || (hbars[i][1] + hbars[i][1] < 0)) ) {\n//                alert('[' + obj.type.toUpperCase() + ' (ID: ' + obj.id + ') BACKGROUND HBARS] You have a negative value in one of your background hbars values, whilst the X axis is in the center');\n//            }\n//\n//            var ystart = (obj.grapharea - (((hbars[i][0] - obj.scale2.min) / (obj.scale2.max - obj.scale2.min)) * obj.grapharea));\n//            //var height = (Math.min(hbars[i][1], obj.max - hbars[i][0]) / (obj.scale2.max - obj.scale2.min)) * obj.grapharea;\n//            var height = obj.getYCoord(hbars[i][0]) - obj.getYCoord(hbars[i][1]);\n//\n//           // Account for the X axis being in the center\n//            if (obj.get('xaxisPosition') == 'center') {\n//                ystart /= 2;\n//                //height /= 2;\n//            }\n//            \n//            ystart += obj.get('marginTop')\n//\n//            var x = obj.get('marginLeft');\n//            var y = ystart - height;\n//            var w = obj.canvas.width - obj.get('marginLeft') - obj.get('marginRight');\n//            var h = height;\n//\n//            // Accommodate Opera :-/\n//            if (navigator.userAgent.indexOf('Opera') != -1 && obj.get('xaxisPosition') == 'center' && h < 0) {\n//                h *= -1;\n//                y = y - h;\n//            }\n//            \n//            //\n//            // Account for X axis at the top\n//            //\n//            //if (obj.get('xaxisPosition') == 'top') {\n//            //    y  = obj.canvas.height - y;\n//            //    h *= -1;\n//            //}\n//\n//            //obj.context.fillStyle = hbars[i][2];\n//            //obj.context.fillRect(x, y, w, h);\n//        //}\n    };\n\n\n\n\n\n\n\n\n    //\n    // Draws in-graph labels.\n    // \n    // @param object obj The graph object\n    //\n    RGraph.drawInGraphLabels =\n    RGraph.DrawInGraphLabels = function (obj)\n    {\n        var prop    = obj.properties,\n            labels  = prop.labelsIngraph,\n            labels_processed = [];\n\n        // Defaults\n        var fgcolor   = 'black',\n            bgcolor   = 'white',\n            direction = 1;\n\n        if (!labels) {\n            return;\n        }\n\n        // Get the text configuration\n        var textConf = RGraph.getTextConf({\n            object: obj,\n            prefix: 'labelsIngraph'\n        });\n\n        //\n        // Preprocess the labels array. Numbers are expanded\n        //\n        for (var i=0,len=labels.length; i<len; i+=1) {\n            if (typeof labels[i] === 'number') {\n                for (var j=0; j<labels[i]; ++j) {\n                    labels_processed.push(null);\n                }\n            } else if (typeof labels[i] === 'string' || typeof labels[i] === 'object') {\n                labels_processed.push(labels[i]);\n            \n            } else {\n                labels_processed.push('');\n            }\n        }\n\n\n\n\n\n\n\n\n        //\n        // Turn off any shadow\n        //\n        RGraph.noShadow(obj);\n\n\n\n\n\n\n\n\n        if (labels_processed && labels_processed.length > 0) {\n\n            for (var i=0,len=labels_processed.length; i<len; i+=1) {\n                if (labels_processed[i]) {\n                    var coords = obj.coords[i];\n                    \n                    if (coords && coords.length > 0) {\n                        var x      = (obj.type == 'bar' ? coords[0] + (coords[2] / 2) : coords[0]);\n                        var y      = (obj.type == 'bar' ? coords[1] + (coords[3] / 2) : coords[1]);\n                        var length = typeof labels_processed[i][4] === 'number' ? labels_processed[i][4] : 25;\n    \n                        obj.context.beginPath();\n                        obj.context.fillStyle   = 'black';\n                        obj.context.strokeStyle = 'black';\n                        \n    \n                        if (obj.type === 'bar') {\n                        \n                            //\n                            // X axis at the top\n                            //\n                            if (obj.get('xaxisPosition') == 'top') {\n                                length *= -1;\n                            }\n    \n                            if (prop.variant == 'dot') {\n                                obj.context.moveTo(Math.round(x), obj.coords[i][1] - 5);\n                                obj.context.lineTo(Math.round(x), obj.coords[i][1] - 5 - length);\n                                \n                                var text_x = Math.round(x);\n                                var text_y = obj.coords[i][1] - 5 - length;\n                            \n                            } else if (prop.variant == 'arrow') {\n                                obj.context.moveTo(Math.round(x), obj.coords[i][1] - 5);\n                                obj.context.lineTo(Math.round(x), obj.coords[i][1] - 5 - length);\n                                \n                                var text_x = Math.round(x);\n                                var text_y = obj.coords[i][1] - 5 - length;\n                            \n                            } else {\n    \n                                obj.context.arc(Math.round(x), y, 2.5, 0, 6.28, 0);\n                                obj.context.moveTo(Math.round(x), y);\n                                obj.context.lineTo(Math.round(x), y - length);\n\n                                var text_x = Math.round(x);\n                                var text_y = y - length;\n                            }\n\n                            obj.context.stroke();\n                            obj.context.fill();\n                            \n    \n                        } else {\n\n                            if (\n                                typeof labels_processed[i] == 'object' &&\n                                typeof labels_processed[i][3] == 'number' &&\n                                labels_processed[i][3] == -1\n                               ) {\n\n                                // Draw an up arrow\n                                drawUpArrow(x, y)\n                                var valign = 'top';\n                                \n                                var text_x = x;\n                                var text_y = y + 5 + length;\n                            \n                            } else {\n\n                                var text_x = x;\n                                var text_y = y - 5 - length;\n\n                                if (text_y < 5 && (typeof labels_processed[i] === 'string' || typeof labels_processed[i][3] === 'undefined')) {\n                                    text_y = y + 5 + length;\n                                    var valign = 'top';\n                                }\n\n                                if (valign === 'top') {\n                                    /// Draw an down arrow\n                                    drawUpArrow(x, y);\n                                } else {\n                                    /// Draw an up arrow\n                                    drawDownArrow(x, y);\n                                }\n                            }\n                        \n                            obj.context.fill();\n                        }\n\n                        obj.context.beginPath();\n                            \n                            // Foreground color\n                            obj.context.fillStyle = (typeof labels_processed[i] === 'object' && typeof labels_processed[i][1] === 'string') ? labels_processed[i][1] : 'black';\n\n                            RGraph.text({\n                            \n                              object: obj,\n\n                                font:            textConf.font,\n                                size:            textConf.size,\n                                color:           textConf.color,\n                                bold:            textConf.bold,\n                                italic:          textConf.italic,\n\n                                x:               text_x,\n                                y:               text_y + (obj.properties.textAccessible ? 2 : 0),\n                                text:            (typeof labels_processed[i] === 'object' && typeof labels_processed[i][0] === 'string') ? labels_processed[i][0] : labels_processed[i],\n                                valign:          valign || 'bottom',\n                                halign:          'center',\n                                bounding:        true,\n                                'bounding.fill': (typeof labels_processed[i] === 'object' && typeof labels_processed[i][2] === 'string') ? labels_processed[i][2] : 'white',\n                                tag:             'labels ingraph'\n                            });\n                        obj.context.fill();\n                    }\n\n\n\n\n                    // Draws a down arrow\n                    function drawUpArrow (x, y)\n                    {\n                        obj.context.moveTo(Math.round(x), y + 5);\n                        obj.context.lineTo(Math.round(x), y + 5 + length);\n                        \n                        obj.context.stroke();\n                        obj.context.beginPath();                                \n                        \n                        // This draws the arrow\n                        obj.context.moveTo(Math.round(x), y + 5);\n                        obj.context.lineTo(Math.round(x) - 3, y + 10);\n                        obj.context.lineTo(Math.round(x) + 3, y + 10);\n                        obj.context.closePath();\n                    }\n\n\n\n\n                    // Draw an up arrow\n                    function drawDownArrow (x, y)\n                    {\n                        obj.context.moveTo(Math.round(x), y - 5);\n                        obj.context.lineTo(Math.round(x), y - 5 - length);\n                        \n                        obj.context.stroke();\n                        obj.context.beginPath();\n                        \n                        // This draws the arrow\n                        obj.context.moveTo(Math.round(x), y - 5);\n                        obj.context.lineTo(Math.round(x) - 3, y - 10);\n                        obj.context.lineTo(Math.round(x) + 3, y - 10);\n                        obj.context.closePath();\n                    }\n                    \n                    valign = undefined;\n                }\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function \"fills in\" key missing properties that various implementations lack\n    // \n    // @param object e The event object\n    //\n    RGraph.fixEventObject =\n    RGraph.FixEventObject = function (e)\n    {\n        if (RGraph.ISOLD) {\n            var e = event;\n\n            e.pageX  = (event.clientX + doc.body.scrollLeft);\n            e.pageY  = (event.clientY + doc.body.scrollTop);\n            e.target = event.srcElement;\n            \n            if (!doc.body.scrollTop && doc.documentElement.scrollTop) {\n                e.pageX += parseInt(doc.documentElement.scrollLeft);\n                e.pageY += parseInt(doc.documentElement.scrollTop);\n            }\n        }\n\n        \n        // Any browser that doesn't implement stopPropagation() (MSIE)\n        if (!e.stopPropagation) {\n            e.stopPropagation = function () {window.event.cancelBubble = true;}\n        }\n        \n        return e;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Thisz function hides the crosshairs coordinates\n    //\n    RGraph.hideCrosshairCoords =\n    RGraph.HideCrosshairCoords = function ()\n    {\n        var div = RGraph.Registry.get('coordinates.coords.div');\n\n        if (   div\n            && div.style.opacity == 1\n            && div.__object__.get('crosshairsCoordsFadeout')\n           ) {\n            \n            var style = RGraph.Registry.get('coordinates.coords.div').style;\n\n            setTimeout(function() {style.opacity = 0.9;}, 25);\n            setTimeout(function() {style.opacity = 0.8;}, 50);\n            setTimeout(function() {style.opacity = 0.7;}, 75);\n            setTimeout(function() {style.opacity = 0.6;}, 100);\n            setTimeout(function() {style.opacity = 0.5;}, 125);\n            setTimeout(function() {style.opacity = 0.4;}, 150);\n            setTimeout(function() {style.opacity = 0.3;}, 175);\n            setTimeout(function() {style.opacity = 0.2;}, 200);\n            setTimeout(function() {style.opacity = 0.1;}, 225);\n            setTimeout(function() {style.opacity = 0;}, 250);\n            setTimeout(function() {style.display = 'none';}, 275);\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Draws the3D axes/background\n    // \n    // @param object obj The chart object\n    //\n    RGraph.draw3DAxes =\n    RGraph.Draw3DAxes = function (obj)\n    {\n        var prop = obj.properties;\n\n        var marginLeft    = obj.marginLeft,\n            marginRight   = obj.marginRight,\n            marginTop     = obj.marginTop,\n            marginBottom  = obj.marginBottom,\n            xaxispos      = prop.xaxisPosition,\n            graphArea     = obj.canvas.height - marginTop - marginBottom,\n            halfGraphArea = graphArea / 2,\n            offsetx       = prop.variantThreedOffsetx,\n            offsety       = prop.variantThreedOffsety,\n            xaxis         = prop.variantThreedXaxis,\n            yaxis         = prop.variantThreedYaxis\n        \n\n        //\n        // Draw the 3D Y axis\n        //\n        if (yaxis) {\n            RGraph.draw3DYAxis(obj);\n        }\n        \n        \n        \n        // X axis\n        if (xaxis) {\n            if (xaxispos === 'center') {\n                RGraph.path(\n                    obj.context,\n                    'b m % % l % % l % % l % % c s #aaa f #ddd',\n                    marginLeft,marginTop + halfGraphArea,\n                    marginLeft + offsetx,marginTop + halfGraphArea - offsety,\n                    obj.canvas.width - marginRight + offsetx,marginTop + halfGraphArea - offsety,\n                    obj.canvas.width - marginRight,marginTop + halfGraphArea\n                );\n\n            } else {\n            \n                if (obj.type === 'hbar') {\n                    var xaxisYCoord = obj.canvas.height - obj.properties.marginBottom;\n                } else {\n                    var xaxisYCoord = obj.getYCoord(0);\n                }\n\n                RGraph.path(\n                    obj.context,\n                    'm % % l % % l % % l % % c s #aaa f #ddd',\n                    marginLeft,xaxisYCoord,\n                    marginLeft + offsetx,xaxisYCoord - offsety,\n                    obj.canvas.width - marginRight + offsetx,xaxisYCoord - offsety,\n                    obj.canvas.width - marginRight,xaxisYCoord\n                );\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Draws the3D Y axis/background\n    // \n    // @param object obj The chart object\n    //\n    RGraph.draw3DYAxis = function (obj)\n    {\n        var prop = obj.properties;\n\n        var marginLeft    = obj.marginLeft,\n            marginRight   = obj.marginRight,\n            marginTop     = obj.marginTop,\n            marginBottom  = obj.marginBottom,\n            xaxispos      = prop.xaxisPosition,\n            graphArea     = obj.canvas.height - marginTop - marginBottom,\n            halfGraphArea = graphArea / 2,\n            offsetx       = prop.variantThreedOffsetx,\n            offsety       = prop.variantThreedOffsety;\n\n        \n        \n        // Y axis\n        // Commented out the if condition because of drawing oddities\n        //if (!prop.noaxes && !prop.noyaxis) {\n\n            if ( (obj.type === 'hbar' || obj.type === 'bar') && prop.yaxisPosition === 'center') {\n                var x = ((obj.canvas.width - marginLeft - marginRight) / 2) + marginLeft;\n            } else if ((obj.type === 'hbar' || obj.type === 'bar') && prop.yaxisPosition === 'right') {\n                var x = obj.canvas.width - marginRight;\n            } else {\n                var x = marginLeft;\n            }\n\n            RGraph.path(\n                obj.context,\n                'b m % % l % % l % % l % % s #aaa f #ddd',\n                x,marginTop,\n                x + offsetx,marginTop - offsety,\n                x + offsetx,obj.canvas.height - marginBottom - offsety,\n                x,obj.canvas.height - marginBottom\n            );\n        //}\n    };\n\n\n\n\n\n\n\n\n    //\n    // Draws a rectangle with curvy corners\n    // \n    // @param context object The context\n    // @param x number The X coordinate (top left of the square)\n    // @param y number The Y coordinate (top left of the square)\n    // @param w number The width of the rectangle\n    // @param h number The height of the rectangle\n    // @param   number The radius of the curved corners\n    // @param   boolean Whether the top left corner is curvy\n    // @param   boolean Whether the top right corner is curvy\n    // @param   boolean Whether the bottom right corner is curvy\n    // @param   boolean Whether the bottom left corner is curvy\n    //\n    RGraph.strokedCurvyRect = function (context, x, y, w, h)\n    {\n        // The corner radius\n        var r = arguments[5] ? arguments[5] : 3;\n\n        // The corners\n        var corner_tl = (arguments[6] || arguments[6] == null) ? true : false;\n        var corner_tr = (arguments[7] || arguments[7] == null) ? true : false;\n        var corner_br = (arguments[8] || arguments[8] == null) ? true : false;\n        var corner_bl = (arguments[9] || arguments[9] == null) ? true : false;\n\n        context.beginPath();\n\n            // Top left side\n            context.moveTo(x + (corner_tl ? r : 0), y);\n            context.lineTo(x + w - (corner_tr ? r : 0), y);\n            \n            // Top right corner\n            if (corner_tr) {\n                context.arc(x + w - r, y + r, r, RGraph.PI + RGraph.HALFPI, RGraph.TWOPI, false);\n            }\n\n            // Top right side\n            context.lineTo(x + w, y + h - (corner_br ? r : 0) );\n\n            // Bottom right corner\n            if (corner_br) {\n                context.arc(x + w - r, y - r + h, r, RGraph.TWOPI, RGraph.HALFPI, false);\n            }\n\n            // Bottom right side\n            context.lineTo(x + (corner_bl ? r : 0), y + h);\n\n            // Bottom left corner\n            if (corner_bl) {\n                context.arc(x + r, y - r + h, r, RGraph.HALFPI, RGraph.PI, false);\n            }\n\n            // Bottom left side\n            context.lineTo(x, y + (corner_tl ? r : 0) );\n\n            // Top left corner\n            if (corner_tl) {\n                context.arc(x + r, y + r, r, RGraph.PI, RGraph.PI + RGraph.HALFPI, false);\n            }\n\n        context.stroke();\n    };\n\n\n\n\n\n\n\n\n    //\n    // Draws a filled rectangle with curvy corners\n    // \n    // @param context object The context\n    // @param x       number The X coordinate (top left of the square)\n    // @param y       number The Y coordinate (top left of the square)\n    // @param w       number The width of the rectangle\n    // @param h       number The height of the rectangle\n    // @param         number The radius of the curved corners\n    // @param         boolean Whether the top left corner is curvy\n    // @param         boolean Whether the top right corner is curvy\n    // @param         boolean Whether the bottom right corner is curvy\n    // @param         boolean Whether the bottom left corner is curvy\n    //\n    RGraph.filledCurvyRect = function (context, x, y, w, h)\n    {\n        // The corner radius\n        var r = arguments[5] ? arguments[5] : 3;\n\n        // The corners\n        var corner_tl = (arguments[6] || arguments[6] == null) ? true : false;\n        var corner_tr = (arguments[7] || arguments[7] == null) ? true : false;\n        var corner_br = (arguments[8] || arguments[8] == null) ? true : false;\n        var corner_bl = (arguments[9] || arguments[9] == null) ? true : false;\n\n        context.beginPath();\n\n            // First draw the corners\n\n            // Top left corner\n            if (corner_tl) {\n                context.moveTo(x + r, y + r);\n                context.arc(x + r, y + r, r, RGraph.PI, RGraph.PI + RGraph.HALFPI, false);\n            } else {\n                context.fillRect(x, y, r, r);\n            }\n\n            // Top right corner\n            if (corner_tr) {\n                context.moveTo(x + w - r, y + r);\n                context.arc(x + w - r, y + r, r, RGraph.PI + RGraph.HALFPI, 0, false);\n            } else {\n                context.moveTo(x + w - r, y);\n                context.fillRect(x + w - r, y, r, r);\n            }\n\n\n            // Bottom right corner\n            if (corner_br) {\n                context.moveTo(x + w - r, y + h - r);\n                context.arc(x + w - r, y - r + h, r, 0, RGraph.HALFPI, false);\n            } else {\n                context.moveTo(x + w - r, y + h - r);\n                context.fillRect(x + w - r, y + h - r, r, r);\n            }\n\n            // Bottom left corner\n            if (corner_bl) {\n                context.moveTo(x + r, y + h - r);\n                context.arc(x + r, y - r + h, r, RGraph.HALFPI, RGraph.PI, false);\n            } else {\n                context.moveTo(x, y + h - r);\n                context.fillRect(x, y + h - r, r, r);\n            }\n\n            // Now fill it in\n            context.fillRect(x + r, y, w - r - r, h);\n            context.fillRect(x, y + r, r + 1, h - r - r);\n            context.fillRect(x + w - r - 1, y + r, r + 1, h - r - r);\n\n        context.fill();\n    };\n\n\n\n\n\n\n\n\n    //\n    // Hides the zoomed canvas\n    //\n    RGraph.hideZoomedCanvas =\n    RGraph.HideZoomedCanvas = function ()\n    {\n        var interval = 10;\n        var frames   = 15;\n\n        if (typeof RGraph.zoom_image === 'object') {\n            var obj  = RGraph.zoom_image.obj;\n            var prop = obj.properties;\n        } else {\n            return;\n        }\n\n        if (prop.zoomFadeOut) {\n            for (var i=frames,j=1; i>=0; --i, ++j) {\n                if (typeof RGraph.zoom_image === 'object') {\n                    setTimeout(\"RGraph.zoom_image.style.opacity = \" + String(i / 10), j * interval);\n                }\n            }\n\n            if (typeof RGraph.zoom_background === 'object') {\n                setTimeout(\"RGraph.zoom_background.style.opacity = \" + String(i / frames), j * interval);\n            }\n        }\n\n        if (typeof RGraph.zoom_image === 'object') {\n            setTimeout(\"RGraph.zoom_image.style.display = 'none'\", prop.zoomFadeOut ? (frames * interval) + 10 : 0);\n        }\n\n        if (typeof RGraph.zoom_background === 'object') {\n            setTimeout(\"RGraph.zoom_background.style.display = 'none'\", prop.zoomFadeOut ? (frames * interval) + 10 : 0);\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Adds an event handler\n    // \n    // @param object obj   The graph object\n    // @param string event The name of the event, eg ontooltip\n    // @param object func  The callback function\n    //\n    RGraph.addCustomEventListener =\n    RGraph.AddCustomEventListener = function (obj, name, func)\n    {\n        // Initialise the events array if necessary\n        if (typeof RGraph.events[obj.uid] === 'undefined') {\n            RGraph.events[obj.uid] = [];\n        }\n        \n        // Prepend \"on\" if necessary\n        if (name.substr(0, 2) !== 'on') {\n            name = 'on' + name;\n        }\n\n        RGraph.events[obj.uid].push([obj, name, func]);\n\n        return RGraph.events[obj.uid].length - 1;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Used to fire one of the RGraph custom events\n    // \n    // @param object obj   The graph object that fires the event\n    // @param string event The name of the event to fire\n    //\n    RGraph.fireCustomEvent =\n    RGraph.FireCustomEvent = function (obj, name)\n    {\n        if (obj && obj.isRGraph) {\n        \n            // This allows the eventsMouseout property to work\n            // (for some reason...)\n            if (name.match(/(on)?mouseout/) && typeof obj.properties.eventsMouseout === 'function') {\n                (obj.properties.eventsMouseout)(obj);\n            }\n        \n            // DOM1 style of adding custom events\n            if (obj[name]) {\n                (obj[name])(obj);\n            }\n            \n            var uid = obj.uid;\n\n            if (   typeof uid === 'string'\n                && typeof RGraph.events === 'object'\n                && typeof RGraph.events[uid] === 'object'\n                && RGraph.events[uid].length > 0) {\n\n                for(var j=0; j<RGraph.events[uid].length; ++j) {\n                    if (RGraph.events[uid][j] && RGraph.events[uid][j][1] === name) {\n                        RGraph.events[uid][j][2](obj);\n                    }\n                }\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Clears all the custom event listeners that have been registered\n    // \n    // @param    string Limits the clearing to this object ID\n    //\n    RGraph.removeAllCustomEventListeners =\n    RGraph.RemoveAllCustomEventListeners = function ()\n    {\n        var id = arguments[0];\n\n        if (id && RGraph.events[id]) {\n            RGraph.events[id] = [];\n        } else {\n            RGraph.events = [];\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Clears a particular custom event listener\n    // \n    // @param object obj The graph object\n    // @param number i   This is the index that is return by .addCustomEventListener()\n    //\n    RGraph.removeCustomEventListener =\n    RGraph.RemoveCustomEventListener = function (obj, i)\n    {\n        if (   typeof RGraph.events === 'object'\n            && typeof RGraph.events[obj.id] === 'object'\n            && typeof RGraph.events[obj.id][i] === 'object') {\n            \n            RGraph.events[obj.id][i] = null;\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This draws the background\n    // \n    // @param object obj The graph object\n    //\n    RGraph.drawBackgroundImage =\n    RGraph.DrawBackgroundImage = function (obj)\n    {\n        var prop = obj.properties;\n\n        if (typeof prop.backgroundImage === 'string') {\n            if (typeof obj.canvas.__rgraph_background_image__ === 'undefined') {\n                var img = new Image();\n                img.__object__  = obj;\n                img.__canvas__  = obj.canvas;\n                img.__context__ = obj.context;\n                img.src         = obj.get('backgroundImage');\n                \n                obj.canvas.__rgraph_background_image__ = img;\n            } else {\n                img = obj.canvas.__rgraph_background_image__;\n            }\n\n            // When the image has loaded - redraw the canvas\n            img.onload = function ()\n            {\n                obj.__rgraph_background_image_loaded__ = true;\n                RGraph.clear(obj.canvas);\n                RGraph.redrawCanvas(obj.canvas);\n            }\n                \n            var marginLeft   = obj.marginLeft;\n            var marginRight  = obj.marginRight;\n            var marginTop    = obj.marginTop;\n            var marginBottom = obj.marginBottom;\n            var stretch      = prop.backgroundImageStretch;\n            var align        = prop.backgroundImageAlign;\n    \n            // Handle backgroundImage.align\n            if (typeof align === 'string') {\n                if (align.indexOf('right') != -1) {\n                    var x = obj.canvas.width - (prop.backgroundImageW || img.width) - marginRight;\n                } else {\n                    var x = marginLeft;\n                }\n    \n                if (align.indexOf('bottom') != -1) {\n                    var y = obj.canvas.height - (prop.backgroundImageH || img.height) - marginBottom;\n                } else {\n                    var y = marginTop;\n                }\n            } else {\n                var x = marginLeft || 25;\n                var y = marginTop || 25;\n            }\n\n            // X/Y coords take precedence over the align\n            var x = typeof prop.backgroundImageX === 'number' ? prop.backgroundImageX : x;\n            var y = typeof prop.backgroundImageY === 'number' ? prop.backgroundImageY : y;\n            var w = stretch ? obj.canvas.width - marginLeft - marginRight : img.width;\n            var h = stretch ? obj.canvas.height - marginTop - marginBottom : img.height;\n            \n            //\n            // You can now specify the width and height of the image\n            //\n            if (typeof prop.backgroundImageW === 'number') w  = prop.backgroundImageW;\n            if (typeof prop.backgroundImageH === 'number') h = prop.backgroundImageH;\n\n            var oldAlpha = obj.context.globalAlpha;\n                obj.context.globalAlpha = prop.backgroundImageAlpha;\n                obj.context.drawImage(img,x,y,w, h);\n            obj.context.globalAlpha = oldAlpha;\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function determines wshether an object has tooltips or not\n    // \n    // @param object obj The chart object\n    //\n    RGraph.hasTooltips = function (obj)\n    {\n        var prop = obj.properties;\n\n        if (typeof prop.tooltips == 'object' && prop.tooltips) {\n            for (var i=0,len=prop.tooltips.length; i<len; ++i) {\n                if (!RGraph.is_null(obj.get('tooltips')[i])) {\n                    return true;\n                }\n            }\n        } else if (typeof prop.tooltips === 'function') {\n            return true;\n        }\n        \n        return false;\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function creates a (G)UID which can be used to identify objects.\n    // \n    // @return string (g)uid The (G)UID\n    //\n    RGraph.createUID =\n    RGraph.CreateUID = function ()\n    {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c)\n        {\n            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n            return v.toString(16);\n        });\n    };\n\n\n\n\n\n\n\n\n    //\n    // This is the new object registry, used to facilitate multiple objects per canvas.\n    // \n    // @param object obj The object to register\n    //\n    RGraph.OR.add =\n    RGraph.OR.Add = function (obj)\n    {\n        var uid = obj.uid;\n        var id  = obj.canvas.id;\n\n        //\n        // Index the objects by UID\n        //\n        //RGraph.ObjectRegistry.objects.byUID.push([uid, obj]);\n        RGraph.ObjectRegistry.objects.byUID[RGraph.ObjectRegistry.objects.byUID.length] = [uid, obj];\n        \n        //\n        // Index the objects by the canvas that they're drawn on\n        //\n        RGraph.ObjectRegistry.objects.byCanvasID.push([id, obj]);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Remove an object from the object registry\n    // \n    // @param object obj The object to remove.\n    //\n    RGraph.OR.remove =\n    RGraph.OR.Remove = function (obj)\n    {\n        var id  = obj.id;\n        var uid = obj.uid;\n\n        for (var i=0; i<RGraph.ObjectRegistry.objects.byUID.length; ++i) {\n            if (RGraph.ObjectRegistry.objects.byUID[i] && RGraph.ObjectRegistry.objects.byUID[i][1].uid == uid) {\n                RGraph.ObjectRegistry.objects.byUID[i] = null;\n            }\n        }\n\n\n        for (var i=0; i<RGraph.ObjectRegistry.objects.byCanvasID.length; ++i) {\n            if (   RGraph.ObjectRegistry.objects.byCanvasID[i]\n                && RGraph.ObjectRegistry.objects.byCanvasID[i][1]\n                && RGraph.ObjectRegistry.objects.byCanvasID[i][1].uid == uid) {\n                \n                RGraph.ObjectRegistry.objects.byCanvasID[i] = null;\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Removes all objects from the ObjectRegistry. If either the ID of a canvas is supplied,\n    // or the canvas itself, then only objects pertaining to that canvas are cleared.\n    // \n    // @param mixed   Either a canvas object (as returned by document.getElementById()\n    //                or the ID of a canvas (ie a string)\n    //\n    RGraph.OR.clear =\n    RGraph.OR.Clear = function ()\n    {\n        // If an ID is supplied restrict the learing to that\n        if (arguments[0]) {\n            var id      = (typeof arguments[0] === 'object' ? arguments[0].id : arguments[0]);\n            var objects = RGraph.ObjectRegistry.getObjectsByCanvasID(id);\n\n            for (var i=0,len=objects.length; i<len; ++i) {\n                RGraph.ObjectRegistry.remove(objects[i]);\n            }\n\n        } else {\n\n            RGraph.ObjectRegistry.objects            = {};\n            RGraph.ObjectRegistry.objects.byUID      = [];\n            RGraph.ObjectRegistry.objects.byCanvasID = [];\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Lists all objects in the ObjectRegistry\n    // \n    // @param boolean ret Whether to return the list or alert() it\n    //\n    RGraph.OR.list =\n    RGraph.OR.List = function ()\n    {\n        var list = [];\n\n        for (var i=0,len=RGraph.ObjectRegistry.objects.byUID.length; i<len; ++i) {\n            if (RGraph.ObjectRegistry.objects.byUID[i]) {\n                list.push(RGraph.ObjectRegistry.objects.byUID[i][1].type);\n            }\n        }\n        \n        if (arguments[0]) {\n            return list;\n        } else {\n            $p(list);\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Clears the ObjectRegistry of objects that are of a certain given type\n    // \n    // @param type string The type to clear\n    //\n    RGraph.OR.clearByType =\n    RGraph.OR.ClearByType = function (type)\n    {\n        var objects = RGraph.ObjectRegistry.objects.byUID;\n\n        for (var i=0,len=objects.length; i<len; ++i) {\n            if (objects[i]) {\n                var uid = objects[i][0];\n                var obj = objects[i][1];\n                \n                if (obj && obj.type == type) {\n                    RGraph.ObjectRegistry.remove(obj);\n                }\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function provides an easy way to go through all of the objects that are held in the\n    // Registry\n    // \n    // @param func function This function is run for every object. Its passed the object as an argument\n    // @param string type Optionally, you can pass a type of object to look for\n    //\n    RGraph.OR.iterate =\n    RGraph.OR.Iterate = function (func)\n    {\n        var objects = RGraph.ObjectRegistry.objects.byUID;\n\n        for (var i=0,len=objects.length; i<len; ++i) {\n        \n            if (typeof arguments[1] === 'string') {\n                \n                var types = arguments[1].split(/,/);\n\n                for (var j=0,len2=types.length; j<len2; ++j) {\n                    if (types[j] == objects[i][1].type) {\n                        func(objects[i][1]);\n                    }\n                }\n            } else {\n                func(objects[i][1]);\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Retrieves all objects for a given canvas id\n    // \n    // @patarm id string The canvas ID to get objects for.\n    //\n    RGraph.OR.getObjectsByCanvasID = function (id)\n    {\n        var store = RGraph.ObjectRegistry.objects.byCanvasID;\n        var ret = [];\n\n        // Loop through all of the objects and return the appropriate ones\n        for (var i=0,len=store.length; i<len; ++i) {\n            if (store[i] && store[i][0] == id ) {\n                ret.push(store[i][1]);\n            }\n        }\n\n        return ret;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Retrieves the relevant object based on the X/Y position.\n    // \n    // @param  object e The event object\n    // @return object   The applicable (if any) object\n    //\n    RGraph.OR.firstbyxy =\n    RGraph.OR.getFirstObjectByXY =\n    RGraph.OR.getObjectByXY = function (e)\n    {\n        var canvas  = e.target;\n        var ret     = null;\n        var objects = RGraph.ObjectRegistry.getObjectsByCanvasID(canvas.id);\n\n        for (var i=(objects.length - 1); i>=0; --i) {\n\n            var obj = objects[i].getObjectByXY(e);\n\n            if (obj) {\n                return obj;\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Retrieves the relevant objects based on the X/Y position.\n    // NOTE This function returns an array of objects\n    // \n    // @param  object e The event object\n    // @return          An array of pertinent objects. Note the there may be only one object\n    //\n    RGraph.OR.getObjectsByXY = function (e)\n    {\n        var canvas  = e.target,\n            ret     = [],\n            objects = RGraph.ObjectRegistry.getObjectsByCanvasID(canvas.id);\n\n        // Retrieve objects \"front to back\"\n        for (var i=(objects.length - 1); i>=0; --i) {\n\n            var obj = objects[i].getObjectByXY(e);\n\n            if (obj) {\n                ret.push(obj);\n            }\n        }\n        \n        return ret;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Retrieves the object with the corresponding UID\n    // \n    // @param string uid The UID to get the relevant object for\n    //\n    RGraph.OR.get =\n    RGraph.OR.getObjectByUID = function (uid)\n    {\n        var objects = RGraph.ObjectRegistry.objects.byUID;\n\n        for (var i=0,len=objects.length; i<len; ++i) {\n            if (objects[i] && objects[i][1].uid == uid) {\n                return objects[i][1];\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Brings a chart to the front of the ObjectRegistry by\n    // removing it and then readding it at the end and then\n    // redrawing the canvas\n    // \n    // @param object  obj    The object to bring to the front\n    // @param boolean redraw Whether to redraw the canvas after the \n    //                       object has been moved\n    //\n    RGraph.OR.bringToFront = function (obj)\n    {\n        var redraw = typeof arguments[1] === 'undefined' ? true : arguments[1];\n\n        RGraph.ObjectRegistry.remove(obj);\n        RGraph.ObjectRegistry.add(obj);\n        \n        if (redraw) {\n            RGraph.redrawCanvas(obj.canvas);\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Retrieves the objects that are the given type\n    // \n    // @param  mixed canvas  The canvas to check. It can either be the canvas object itself or just the ID\n    // @param  string type   The type to look for\n    // @return array         An array of one or more objects\n    //\n    RGraph.OR.type =\n    RGraph.OR.getObjectsByType = function (type)\n    {\n        var objects = RGraph.ObjectRegistry.objects.byUID;\n        var ret     = [];\n\n        for (i in objects) {\n            if (objects[i] && objects[i][1] && objects[i][1].type && objects[i][1].type && objects[i][1].type == type) {\n                ret.push(objects[i][1]);\n            }\n        }\n\n        return ret;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Retrieves the FIRST object that matches the given type\n    //\n    // @param  string type   The type of object to look for\n    // @return object        The FIRST object that matches the given type\n    //\n    RGraph.OR.first =\n    RGraph.OR.getFirstObjectByType = function (type)\n    {\n        var objects = RGraph.ObjectRegistry.objects.byUID;\n\n        for (var i in objects) {\n            if (objects[i] && objects[i][1] && objects[i][1].type == type) {\n                return objects[i][1];\n            }\n        }\n        \n        return null;\n    };\n\n\n\n\n\n\n\n\n    //\n    // This takes centerx, centery, x and y coordinates and returns the\n    // appropriate angle relative to the canvas angle system. Remember\n    // that the canvas angle system starts at the EAST axis\n    // \n    // @param  number cx  The centerx coordinate\n    // @param  number cy  The centery coordinate\n    // @param  number x   The X coordinate (eg the mouseX if coming from a click)\n    // @param  number y   The Y coordinate (eg the mouseY if coming from a click)\n    // @return number     The relevant angle (measured in in RADIANS)\n    //\n    RGraph.getAngleByXY = function (cx, cy, x, y)\n    {\n        var angle = Math.atan((y - cy) / (x - cx));\n            angle = Math.abs(angle)\n\n        if (x >= cx && y >= cy) {\n            angle += RGraph.TWOPI;\n\n        } else if (x >= cx && y < cy) {\n            angle = (RGraph.HALFPI - angle) + (RGraph.PI + RGraph.HALFPI);\n\n        } else if (x < cx && y < cy) {\n            angle += RGraph.PI;\n\n        } else {\n            angle = RGraph.PI - angle;\n        }\n\n        //\n        // Upper and lower limit checking\n        //\n        if (angle > RGraph.TWOPI) {\n            angle -= RGraph.TWOPI;\n        }\n\n        return angle;\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function returns the distance between two points. In effect the\n    // radius of an imaginary circle that is centered on x1 and y1. The name\n    // of this function is derived from the word \"Hypoteneuse\", which in\n    // trigonmetry is the longest side of a triangle\n    // \n    // @param number x1 The original X coordinate\n    // @param number y1 The original Y coordinate\n    // @param number x2 The target X coordinate\n    // @param number y2 The target Y  coordinate\n    //\n    RGraph.getHypLength = function (x1, y1, x2, y2)\n    {\n        var ret = Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));\n\n        return ret;\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function gets the end point (X/Y coordinates) of a given radius.\n    // You pass it the center X/Y and the radius and this function will return\n    // the endpoint X/Y coordinates.\n    // \n    // @param number cx The center X coord\n    // @param number cy The center Y coord\n    // @param number r  The lrngth of the radius\n    //\n    RGraph.getRadiusEndPoint = function (cx, cy, angle, radius)\n    {\n        var x = cx + (Math.cos(angle) * radius);\n        var y = cy + (Math.sin(angle) * radius);\n        \n        return [x, y];\n    };\n\n\n\n\n\n\n\n\n    //\n    // This installs all of the event listeners\n    // \n    // @param object obj The chart object\n    //\n    RGraph.installEventListeners =\n    RGraph.InstallEventListeners = function (obj)\n    {\n        var prop = obj.properties;\n\n        //\n        // Don't attempt to install event listeners for older versions of MSIE\n        //\n        if (RGraph.ISOLD) {\n            return;\n        }\n\n        //\n        // If this function exists, then the dynamic file has been included.\n        //\n        if (RGraph.installCanvasClickListener) {\n\n            RGraph.installWindowMousedownListener(obj);\n            RGraph.installWindowMouseupListener(obj);\n            RGraph.installCanvasMousemoveListener(obj);\n            RGraph.installCanvasMouseupListener(obj);\n            RGraph.installCanvasMousedownListener(obj);\n            RGraph.installCanvasClickListener(obj);\n        \n        } else if (   RGraph.hasTooltips(obj)\n                   || prop.adjustable\n                   || prop.annotatable\n                   || prop.contextmenu\n                   || prop.resizable\n                   || prop.keyInteractive\n                   || prop.eventsClick\n                   || prop.eventsMousemove\n                   || typeof obj.onclick === 'function'\n                   || typeof obj.onmousemove === 'function'\n                  ) {\n\n            alert('[RGRAPH] You appear to have used dynamic features but not included the file: RGraph.common.dynamic.js');\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Loosly mimicks the PHP function print_r();\n    //\n    RGraph.pr = function (obj)\n    {\n        var indent = (arguments[2] ? arguments[2] : '    ');\n        var str    = '';\n\n        var counter = typeof arguments[3] == 'number' ? arguments[3] : 0;\n        \n        if (counter >= 5) {\n            return '';\n        }\n        \n        switch (typeof obj) {\n            \n            case 'string':    str += obj + ' (' + (typeof obj) + ', ' + obj.length + ')'; break;\n            case 'number':    str += obj + ' (' + (typeof obj) + ')'; break;\n            case 'boolean':   str += obj + ' (' + (typeof obj) + ')'; break;\n            case 'function':  str += 'function () {}'; break;\n            case 'undefined': str += 'undefined'; break;\n            case 'null':      str += 'null'; break;\n            \n            case 'object':\n                // In case of null\n                if (RGraph.isNull(obj)) {\n                    str += indent + 'null\\n';\n                } else {\n                    str += indent + 'Object {' + '\\n'\n                    for (var j in obj) {\n                        str += indent + '    ' + j + ' => ' + RGraph.pr(obj[j], true, indent + '    ', counter + 1) + '\\n';\n                    }\n                    str += indent + '}';\n                }\n                break;\n            \n            \n            default:\n                str += 'Unknown type: ' + typeof obj + '';\n                break;\n        }\n\n\n        //\n        // Finished, now either return if we're in a recursed call, or alert()\n        // if we're not.\n        //\n        if (!arguments[1]) {\n            alert(str);\n        }\n        \n        return str;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Produces a dashed line\n    // \n    // @param object context The 2D context\n    // @param number x1 The start X coordinate\n    // @param number y1 The start Y coordinate\n    // @param number x2 The end X coordinate\n    // @param number y2 The end Y coordinate\n    //\n    RGraph.dashedLine =\n    RGraph.DashedLine = function(context, x1, y1, x2, y2)\n    {\n        //\n        // This is the size of the dashes\n        //\n        var size = 5;\n\n        //\n        // The optional fifth argument can be the size of the dashes\n        //\n        if (typeof arguments[5] === 'number') {\n            size = arguments[5];\n        }\n\n        var dx  = x2 - x1;\n        var dy  = y2 - y1;\n        var num = Math.floor(Math.sqrt((dx * dx) + (dy * dy)) / size);\n\n        var xLen = dx / num;\n        var yLen = dy / num;\n\n        var count = 0;\n\n        do {\n            (count % 2 == 0 && count > 0) ? context.lineTo(x1, y1) : context.moveTo(x1, y1);\n\n            x1 += xLen;\n            y1 += yLen;\n        } while(count++ <= num);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Makes an AJAX call. It calls the given callback (a function) when ready\n    // \n    // @param string   url      The URL to retrieve\n    // @param function callback A function that is called when the response is ready,\n    //                          there's an example below called \"myCallback\".\n    //\n    RGraph.AJAX = function (url, callback)\n    {\n        // Mozilla, Safari, ...\n        if (window.XMLHttpRequest) {\n            var httpRequest = new XMLHttpRequest();\n\n        // MSIE\n        } else if (window.ActiveXObject) {\n            var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n        }\n\n        httpRequest.onreadystatechange = function ()\n        {\n            if (this.readyState == 4 && this.status == 200) {\n                this.__user_callback__ = callback;\n\n                this.__user_callback__(this.responseText);\n            }\n        }\n\n        httpRequest.open('GET', url, true);\n        httpRequest.send();\n    };\n\n\n\n\n\n\n\n\n    //\n    // Makes an AJAX POST request. It calls the given callback (a function) when ready\n    // \n    // @param string   url      The URL to retrieve\n    // @param object   data     The POST data\n    // @param function callback A function that is called when the response is ready, there's an example below\n    //                          called \"myCallback\".\n    //\n    RGraph.AJAX.post =\n    RGraph.AJAX.POST = function (url, data, callback)\n    {\n        // Used when building the POST string\n        var crumbs = [];\n\n        // Mozilla, Safari, ...\n        if (window.XMLHttpRequest) {\n            var httpRequest = new XMLHttpRequest();\n\n        // MSIE\n        } else if (window.ActiveXObject) {\n            var httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");\n        }\n\n        httpRequest.onreadystatechange = function ()\n        {\n            if (this.readyState == 4 && this.status == 200) {\n                this.__user_callback__ = callback;\n                this.__user_callback__(this.responseText);\n            }\n        }\n\n        httpRequest.open('POST', url, true);\n        httpRequest.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n        \n        for (i in data) {\n            if (typeof i == 'string') {\n                crumbs.push(i + '=' + encodeURIComponent(data[i]));\n            }\n        }\n\n        httpRequest.send(crumbs.join('&'));\n    };\n\n\n\n\n\n\n\n\n    //\n    // Uses the above function but calls the call back passing a number as its argument\n    // \n    // @param url string The URL to fetch\n    // @param callback function Your callback function (which is passed the number as an argument)\n    //\n    RGraph.AJAX.getNumber = function (url, callback)\n    {\n        RGraph.AJAX(url, function ()\n        {\n            var num = parseFloat(this.responseText);\n\n            callback(num);\n        });\n    };\n\n\n\n\n\n\n\n\n    //\n    // Uses the above function but calls the call back passing a string as its argument\n    // \n    // @param url string The URL to fetch\n    // @param callback function Your callback function (which is passed the string as an argument)\n    //\n    RGraph.AJAX.getString = function (url, callback)\n    {\n        RGraph.AJAX(url, function ()\n        {\n            var str = String(this.responseText);\n\n            callback(str);\n        });\n    };\n\n\n\n\n\n\n\n\n    //\n    // Uses the above function but calls the call back passing JSON (ie a JavaScript object ) as its argument\n    // \n    // @param url string The URL to fetch\n    // @param callback function Your callback function (which is passed the JSON object as an argument)\n    //\n    RGraph.AJAX.getJSON = function (url, callback)\n    {\n        RGraph.AJAX(url, function ()\n        {\n            var json = eval('(' + this.responseText + ')');\n\n            callback(json);\n        });\n    };\n\n\n\n\n\n\n\n\n    //\n    // Uses the above RGraph.AJAX function but calls the call back passing an array as its argument.\n    // Useful if you're retrieving CSV data\n    // \n    // @param url string The URL to fetch\n    // @param callback function Your callback function (which is passed the CSV/array as an argument)\n    //\n    RGraph.AJAX.getCSV = function (url, callback)\n    {\n        var seperator = arguments[2] ? arguments[2] : ',';\n\n        RGraph.AJAX(url, function ()\n        {\n            var regexp = new RegExp(seperator);\n            var arr = this.responseText.split(regexp);\n            \n            // Convert the strings to numbers\n            for (var i=0,len=arr.length;i<len;++i) {\n                arr[i] = parseFloat(arr[i]);\n            }\n\n            callback(arr);\n        });\n    };\n\n\n\n\n\n\n\n\n    //\n    // Rotates the canvas\n    // \n    // @param object canvas The canvas to rotate\n    // @param  int   x      The X coordinate about which to rotate the canvas\n    // @param  int   y      The Y coordinate about which to rotate the canvas\n    // @param  int   angle  The angle(in RADIANS) to rotate the canvas by\n    //\n    RGraph.rotateCanvas =\n    RGraph.RotateCanvas = function (canvas, x, y, angle)\n    {\n        var context = canvas.getContext('2d');\n\n        context.translate(x, y);\n        context.rotate(angle);\n        context.translate(0 - x, 0 - y);    \n    };\n\n\n\n\n\n\n\n\n    //\n    // Measures text by creating a DIV in the document and adding the relevant text to it.\n    // Then checking the .offsetWidth and .offsetHeight.\n    // \n    // @param  string text   The text to measure\n    // @param  bool   bold   Whether the text is bold or not\n    // @param  string font   The font to use\n    // @param  size   number The size of the text (in pts)\n    // @return array         A two element array of the width and height of the text\n    //\n    RGraph.measureText =\n    RGraph.MeasureText = function (opt)\n    {\n        // Individual or object based args\n        if (typeof opt === 'object') {\n            var text = opt.text,\n                bold = opt.bold,\n                font = opt.font,\n                size = opt.size;\n        } else {\n            text = arguments[0];\n            bold = arguments[1];\n            font = arguments[2];\n            size = arguments[3];\n        }\n\n        // Add the sizes to the cache as adding DOM elements is costly and causes slow downs\n        if (typeof RGraph.measuretext_cache === 'undefined') {\n            RGraph.measuretext_cache = [];\n        }\n\n        var str = text + ':' + bold + ':' + font + ':' + size;\n        if (typeof RGraph.measuretext_cache == 'object' && RGraph.measuretext_cache[str]) {\n            return RGraph.measuretext_cache[str];\n        }\n        \n        if (!RGraph.measuretext_cache['text-div']) {\n            var div = document.createElement('DIV');\n                div.style.position = 'absolute';\n                div.style.top = '-100px';\n                div.style.left = '-100px';\n            document.body.appendChild(div);\n            \n            // Now store the newly created DIV\n            RGraph.measuretext_cache['text-div'] = div;\n\n        } else if (RGraph.measuretext_cache['text-div']) {\n            var div = RGraph.measuretext_cache['text-div'];\n        }\n\n        div.innerHTML        = text.replace(/\\r?\\n/g, '<br />');\n        div.style.fontFamily = font;\n        div.style.fontWeight = bold ? 'bold' : 'normal';\n        div.style.fontSize   = (size || 12) + 'pt';\n        \n        var size = [div.offsetWidth, div.offsetHeight];\n\n        //document.body.removeChild(div);\n        RGraph.measuretext_cache[str] = size;\n        \n        return size;\n    };\n\n\n\n\n\n\n\n\n    // New text function. Accepts two arguments:\n    //  o obj - The chart object\n    //  o opt - An object/hash/map of properties. This can consist of:\n    //          x                The X coordinate (REQUIRED)\n    //          y                The Y coordinate (REQUIRED)\n    //          text             The text to show (REQUIRED)\n    //          font             The font to use\n    //          size             The size of the text (in pt)\n    //          italic           Whether the text should be italic or not\n    //          bold             Whether the text should be bold or not\n    //          marker           Whether to show a marker that indicates the X/Y coordinates\n    //          valign           The vertical alignment\n    //          halign           The horizontal alignment\n    //          bounding         Whether to draw a bounding box for the text\n    //          boundingStroke   The strokeStyle of the bounding box\n    //          boundingFill     The fillStyle of the bounding box\n    //          accessible       If false this will cause the text to be\n    //                           rendered as native canvas text. DOM text otherwise\n    //\n    RGraph.text  =\n    RGraph.text2 =\n    RGraph.Text2 = function (opt)\n    {\n        // Allow for the use of a single argument or two\n        // 1. First handle two arguments\n        if (arguments[0] && arguments[1] && typeof arguments[1].text === 'string') {\n            var obj = arguments[0],\n                opt = arguments[1];\n\n        // 2. The alternative is a single option\n       } else {\n            var obj = opt.object;\n        }\n        \n        // Get the defaults for the text function from RGraph.text.defaults object\n        for (var i in RGraph.text.defaults) {\n            if (typeof i === 'string' && typeof opt[i] === 'undefined') {\n                opt[i] = RGraph.text.defaults[i];\n            }\n        }\n\n        // Use DOM nodes to get better quality text. This option is BETA quality\n        // code and most likely and will not work if you use 3D or if you use\n        // your own transformations.\n        function domtext ()\n        {\n            //\n            // Check the font property to see if it contains the italic keyword,\n            // and if it does then take it out and set the italic property\n            //\n            if (String(opt.size).toLowerCase().indexOf('italic') !== -1) {\n                opt.size = opt.size.replace(/ *italic +/, '');\n                opt.italic = true;\n            }\n\n\n\n            // Used for caching the DOM node\n            var cacheKey = Math.abs(parseInt(opt.x)) + '_' + Math.abs(parseInt(opt.y)) + '_' + String(opt.text).replace(/[^a-zA-Z0-9]+/g, '_') + '_' + obj.canvas.id;\n\n\n\n            // Wrap the canvas in a DIV\n            if (!obj.canvas.rgraph_domtext_wrapper) {\n\n                var wrapper = document.createElement('div');\n                    wrapper.id        = obj.canvas.id + '_rgraph_domtext_wrapper';\n                    wrapper.className = 'rgraph_domtext_wrapper';\n\n                    // The wrapper can be configured to hide or show the\n                    // overflow with the textAccessibleOverflow option\n                    wrapper.style.overflow = obj.properties.textAccessibleOverflow != false && obj.properties.textAccessibleOverflow != 'hidden' ? 'visible' : 'hidden';\n                    \n                    wrapper.style.width    = obj.canvas.offsetWidth + 'px';\n                    wrapper.style.height   = obj.canvas.offsetHeight + 'px';\n\n                    wrapper.style.cssFloat   = obj.canvas.style.cssFloat;\n                    wrapper.style.display    = obj.canvas.style.display || 'inline-block';\n                    wrapper.style.position   = obj.canvas.style.position || 'relative';\n                    wrapper.style.left       = obj.canvas.style.left;\n                    wrapper.style.top        = obj.canvas.style.top;\n                    wrapper.style.width      = obj.canvas.width + 'px';\n                    wrapper.style.height     = obj.canvas.height + 'px';\n                    wrapper.style.lineHeight = 'initial';\n\n                    obj.canvas.style.position      = 'absolute';\n                    obj.canvas.style.left          = 0;\n                    obj.canvas.style.top           = 0;\n                    obj.canvas.style.display       = 'inline';\n                    obj.canvas.style.cssFloat      = 'none';\n\n                    \n                    if ((obj.type === 'bar' || obj.type === 'bipolar' || obj.type === 'hbar') && obj.properties.variant === '3d') {\n                        wrapper.style.transform = 'skewY(5.7deg)';\n                    }\n\n                obj.canvas.parentNode.insertBefore(wrapper, obj.canvas);\n                \n                // Remove the canvas from the DOM and put it in the wrapper\n                obj.canvas.parentNode.removeChild(obj.canvas);\n                wrapper.appendChild(obj.canvas);\n                \n                obj.canvas.rgraph_domtext_wrapper = wrapper;\n                \n                // TODO Add a subwrapper here\n\n            } else {\n                wrapper = obj.canvas.rgraph_domtext_wrapper;\n            }\n\n\n\n            var defaults = {\n                size:   12,\n                font:   'Arial',\n                italic: 'normal',\n                bold:   'normal',\n                valign: 'bottom',\n                halign: 'left',\n                marker: true,\n                color:  context.fillStyle,\n                bounding: {\n                    enabled:   false,\n                    fill:      'rgba(255,255,255,0.7)',\n                    stroke:    '#666',\n                    linewidth: 1\n                }\n            }\n\n            \n            // Transform \\n to the string [[RETURN]] which is then replaced\n            // further down\n            opt.text = String(opt.text).replace(/\\r?\\n/g, '[[RETURN]]');\n\n\n            // Create the node cache array that nodes\n            // already created are stored in\n            if (typeof RGraph.text.domNodeCache === 'undefined') {\n                RGraph.text.domNodeCache = new Array();\n            }\n            \n            if (typeof RGraph.text.domNodeCache[obj.id] === 'undefined') {\n                RGraph.text.domNodeCache[obj.id] = new Array();\n            }\n\n            // Create the dimension cache array that node\n            // dimensions are stored in\n            if (typeof RGraph.text.domNodeDimensionCache === 'undefined') {\n                RGraph.text.domNodeDimensionCache = new Array();\n            }\n            \n            if (typeof RGraph.text.domNodeDimensionCache[obj.id] === 'undefined') {\n                RGraph.text.domNodeDimensionCache[obj.id] = new Array();\n            }\n\n\n\n            // Create the DOM node\n            if (!RGraph.text.domNodeCache[obj.id] || !RGraph.text.domNodeCache[obj.id][cacheKey]) {\n\n                var span = document.createElement('span');\n                    span.style.position      = 'absolute';\n                    span.style.display       = 'inline';\n                    \n                    span.className        =   ' rgraph_accessible_text'\n                                            + ' rgraph_accessible_text_' + obj.id\n                                            + ' rgraph_accessible_text_' + (opt.tag || '').replace(/\\./, '_')\n                                            + ' rgraph_accessible_text_' + obj.type;\n\n                    span.style.left       = (opt.x * (parseInt(obj.canvas.offsetWidth) / parseInt(obj.canvas.width))) + 'px';\n                    span.style.top        = (opt.y * (parseInt(obj.canvas.offsetHeight) / parseInt(obj.canvas.height)))  + 'px';\n                    span.style.color      = opt.color || defaults.color;\n                    span.style.fontFamily = opt.font || defaults.font;\n                    span.style.fontWeight = opt.bold ? 'bold' : defaults.bold;\n                    span.style.fontStyle  = opt.italic ? 'italic' : defaults.italic;\n                    span.style.fontSize   = (opt.size || defaults.size) + 'pt';\n                    span.style.whiteSpace = 'nowrap';\n                    span.tag              = opt.tag;\n\n\n                    // CSS angled text. This should be conasidered BETA quality code at the moment,\n                    // but it seems to be OK. You may need to use the labelsOffsety when using this\n                    // option.\n                    if (typeof opt.angle === 'number' && opt.angle !== 0) {\n                    \n                        var coords = RGraph.measureText(\n                            opt.text,\n                            opt.bold,\n                            opt.font,\n                            opt.size\n                        );\n                    \n                        //span.style.left = parseFloat(span.style.left) - coords[0] + 'px';\n                        span.style.transformOrigin = '100% 50%';\n                        span.style.transform       = 'rotate(' + opt.angle + 'deg)';\n                    }\n\n\n\n\n                    // Shadow\n                    span.style.textShadow = '{1}px {2}px {3}px {4}'.format(\n                        context.shadowOffsetX,\n                        context.shadowOffsetY,\n                        context.shadowBlur,\n                        context.shadowColor\n                    );\n\n\n                    if (opt.bounding) {\n                        span.style.border          = '1px solid ' + (opt['bounding.stroke'] || defaults.bounding.stroke);\n                        span.style.backgroundColor = opt['bounding.fill'] || defaults.bounding.fill;\n                        span.style.borderWidth     = typeof opt['bounding.linewidth'] === 'number' ? opt['bounding.linewidth'] : defaults.bounding.linewidth;\n                    }\n                    // Pointer events\n                    if ((typeof obj.properties.textAccessiblePointerevents === 'undefined' ||\n                        obj.properties.textAccessiblePointerevents) &&\n                        obj.properties.textAccessiblePointerevents !== 'none') {\n                        \n                        span.style.pointerEvents =  'auto';\n                    } else {\n                        span.style.pointerEvents =  'none';\n                    }\n\n                    span.style.padding = opt.bounding ? '2px' : null; // Changed to 2px on 16th January 2019\n                    span.__text__      = opt.text\n                    span.innerHTML     = opt.text.replace('&', '&amp;')\n                                                 .replace('<', '&lt;')\n                                                 .replace('>', '&gt;');\n                    \n                    // Now replace the string [[RETURN]] with a <br />\n                    span.innerHTML = span.innerHTML.replace(/\\[\\[RETURN\\]\\]/g, '<br />');\n\n                wrapper.appendChild(span);\n\n                // Alignment defaults\n                opt.halign = opt.halign || 'left';\n                opt.valign = opt.valign || 'bottom';\n                \n                // Horizontal alignment\n                if (opt.halign === 'right') {\n                    span.style.left      = parseFloat(span.style.left) - span.offsetWidth + 'px';\n                    span.style.textAlign = 'right';\n                } else if (opt.halign === 'center') {\n                    span.style.left      = parseFloat(span.style.left) - (span.offsetWidth  / 2) + 'px';\n                    span.style.textAlign = 'center';\n                }\n                \n                // Vertical alignment\n                if (opt.valign === 'top') {\n                    // Nothing to do here\n                } else if (opt.valign === 'center') {\n                    span.style.top = parseFloat(span.style.top) - (span.offsetHeight / 2) + 'px';\n                } else {\n                    span.style.top = parseFloat(span.style.top) - span.offsetHeight + 'px';\n                }\n                        \n                \n                var offsetWidth  = parseFloat(span.offsetWidth),\n                    offsetHeight = parseFloat(span.offsetHeight),\n                    top          = parseFloat(span.style.top),\n                    left         = parseFloat(span.style.left);\n\n                RGraph.text.domNodeCache[obj.id][cacheKey] = span;\n                RGraph.text.domNodeDimensionCache[obj.id][cacheKey] = {\n                      left: left,\n                       top: top,\n                     width: offsetWidth,\n                    height: offsetHeight\n                };\n                span.id = cacheKey;\n\n\n            \n            } else {\n                span = RGraph.text.domNodeCache[obj.id][cacheKey];\n                span.style.display = 'inline';\n                \n                var offsetWidth  = RGraph.text.domNodeDimensionCache[obj.id][cacheKey].width,\n                    offsetHeight = RGraph.text.domNodeDimensionCache[obj.id][cacheKey].height,\n                    top          = RGraph.text.domNodeDimensionCache[obj.id][cacheKey].top,\n                    left         = RGraph.text.domNodeDimensionCache[obj.id][cacheKey].left;\n            }\n\n\n            \n\n            \n            \n            // If requested, draw a marker to indicate the coords\n            if (opt.marker) {\n                RGraph.path(context, 'b m % % l % % m % % l % % s',\n                    opt.x - 5, opt.y,\n                    opt.x + 5, opt.y,\n                    opt.x, opt.y - 5,\n                    opt.x, opt.y + 5\n                );\n            }\n            \n            //\n            // If its a drawing API text object then allow\n            // for events and tooltips\n            //\n            if (obj.type === 'drawing.text') {\n\n                // Mousemove\n                if (obj.properties.eventsMousemove) {\n                    span.addEventListener('mousemove', function (e) {(obj.properties.eventsMousemove)(e, obj);}, false);\n                }\n                \n                // Click\n                if (obj.properties.eventsClick) {\n                    span.addEventListener('click', function (e) {(obj.properties.eventsClick)(e, obj);}, false);\n                }\n                \n                // Tooltips\n                if (obj.properties.tooltips) {\n                    span.addEventListener(\n                        obj.properties.tooltipsEvent.indexOf('mousemove') !== -1 ? 'mousemove' : 'click',\n                        function (e)\n                        {\n                            if (   !RGraph.Registry.get('tooltip')\n                                || RGraph.Registry.get('tooltip').__index__ !== 0\n                                || RGraph.Registry.get('tooltip').__object__.uid != obj.uid\n                               ) {\n                               \n                                RGraph.hideTooltip();\n                                RGraph.redraw();\n                                RGraph.tooltip(obj, obj.properties.tooltips[0], opt.x, opt.y, 0, e);\n                            }\n                        },\n                        false\n                    );\n                }\n            }\n\n            // Build the return value\n            var ret        = {};\n                ret.x      = left;\n                ret.y      = top;\n                ret.width  = offsetWidth;\n                ret.height = offsetHeight;\n                ret.object = obj;\n                ret.text   = opt.text;\n                ret.tag    = opt.tag;\n\n            \n            // The reset() function clears the domNodeCache\n            ////\n            // @param object OPTIONAL You can pass in the canvas to limit the\n            //                        clearing to that canvas.\n            RGraph.text.domNodeCache.reset = function ()\n            {\n                // Limit the clearing to a single canvas tag\n                if (arguments[0]) {\n                    \n                    if (typeof arguments[0] === 'string') {\n                        var canvas = document.getElementById(arguments[0])\n                    } else {\n                        var canvas = arguments[0];\n                    }\n\n                    var nodes = RGraph.text.domNodeCache[canvas.id];\n\n                    for (j in nodes) {\n                        \n                        var node = RGraph.text.domNodeCache[canvas.id][j];\n                        \n                        if (node && node.parentNode) {\n                            node.parentNode.removeChild(node);\n                        }\n                    }\n                    \n                    RGraph.text.domNodeCache[canvas.id]          = [];\n                    RGraph.text.domNodeDimensionCache[canvas.id] = [];\n\n                // Clear all DOM text from all tags\n                } else {\n                    for (i in RGraph.text.domNodeCache) {\n                        for (j in RGraph.text.domNodeCache[i]) {\n                            if (RGraph.text.domNodeCache[i][j] && RGraph.text.domNodeCache[i][j].parentNode) {\n                                RGraph.text.domNodeCache[i][j].parentNode.removeChild(RGraph.text.domNodeCache[i][j]);\n                            }\n                        }\n                    }\n\n                    RGraph.text.domNodeCache          = [];\n                    RGraph.text.domNodeDimensionCache = [];\n                }\n            };\n\n\n\n\n            //\n            // Helps you get hold of the SPAN tag nodes that hold the text on the chart\n            //\n            RGraph.text.find = function (opt)\n            {\n                var span, nodes = [];\n                \n                if (opt.object && opt.object.isRGraph) {\n                    var id = opt.object.id;\n                } else if (opt.id) {\n                    var id     = typeof opt.id === 'string' ? opt.id : opt.object.id;\n                    opt.object = document.getElementById(id).__object__;\n                } else {\n                    alert('[RGRAPH] You Must give either an object or an ID to the RGraph.text.find() function');\n                    return false;\n                }\n\n                for (i in RGraph.text.domNodeCache[id]) {\n                \n                    span = RGraph.text.domNodeCache[id][i];\n\n                    // A full tag is given\n                    if (typeof opt.tag === 'string' && opt.tag === span.tag) {\n                        nodes.push(span);\n                        continue;\n                    }\n\n\n\n                    // A regex is given as the tag\n                    if (typeof opt.tag === 'object' && opt.tag.constructor.toString().indexOf('RegExp')) {\n\n                        var regexp = new RegExp(opt.tag);\n\n                        if (regexp.test(span.tag)) {\n                            nodes.push(span);\n                            continue;\n                        }\n                    }\n\n\n\n                    // A full text is given\n                    if (typeof opt.text === 'string' && opt.text === span.__text__) {\n                        nodes.push(span);\n                        continue;\n                    }\n\n\n\n                    // Regex for the text is given\n                    // A regex is given as the tag\n                    if (typeof opt.text === 'object' && opt.text.constructor.toString().indexOf('RegExp')) {\n\n                        var regexp = new RegExp(opt.text);\n\n                        if (regexp.test(span.__text__)) {\n                            nodes.push(span);\n                            \n                        continue;\n                        }\n                    }\n                }\n                \n                // If a callback has been specified then call it whilst\n                // passing it the text\n                if (typeof opt.callback === 'function') {\n                    (opt.callback)({nodes: nodes, object:opt.object});\n                }\n\n                return nodes;\n            };\n\n\n\n\n            //\n            // Add the SPAN tag to the return value\n            //\n            ret.node = span;\n\n\n            //\n            // Save and then return the details of the text (but oly\n            // if it's an RGraph object that was given)\n            //\n            if (obj && obj.isRGraph && obj.coordsText) {\n                obj.coordsText.push(ret);\n            }\n\n\n            return ret;\n        }\n\n\n\n\n        //\n        // An RGraph object can be given, or a string or the 2D rendering context\n        // The coords are placed on the obj.coordsText variable ONLY if it's an RGraph object. The function\n        // still returns the cooords though in all cases.\n        //\n        if (obj && obj.isRGraph) {\n            var obj     = obj;\n            var canvas  = obj.canvas;\n            var context = obj.context;\n        \n        } else if (typeof obj == 'string') {\n            var canvas  = document.getElementById(obj);\n            var context = canvas.getContext('2d');\n            var obj     = canvas.__object__;\n        \n        } else if (typeof obj.getContext === 'function') {\n            var canvas  = obj;\n            var context = canvas.getContext('2d');\n            var obj     = canvas.__object__;\n        \n        } else if (obj.toString().indexOf('CanvasRenderingContext2D') != -1 || RGraph.ISIE8 && obj.moveTo) {\n            var context  = obj;\n            var canvas   = obj.canvas;\n            var obj      = canvas.__object__;\n\n        // IE7/8\n        } else if (RGraph.ISOLD && obj.fillText) {\n            var context  = obj;\n            var canvas   = obj.canvas;\n            var obj      = canvas.__object__;\n        }\n\n\n        //\n        // Changed the name of boundingFill/boundingStroke - this allows you to still use those names\n        //\n\n        if (typeof opt.boundingFill      === 'string') opt['bounding.fill']   = opt.boundingFill;\n        if (typeof opt.boundingStroke    === 'string') opt['bounding.stroke'] = opt.boundingStroke;\n        if (typeof opt.boundingLinewidth === 'number') opt['bounding.linewidth'] = opt.boundingLinewidth;\n\n\n\n\n\n\n\n        if (typeof opt.accessible === 'undefined') {\n            if (obj && obj.properties.textAccessible) {\n                return domtext();\n            }\n        } else if (typeof opt.accessible === 'boolean' && opt.accessible) {\n            return domtext();\n        }\n\n\n\n\n        var x              = opt.x,\n            y              = opt.y,\n            originalX      = x,\n            originalY      = y,\n            text           = opt.text,\n            text_multiline = typeof text === 'string' ? text.split(/\\r?\\n/g) : '',\n            numlines       = text_multiline.length,\n            font           = opt.font ? opt.font : 'Arial',\n            size           = opt.size ? opt.size : 10,\n            size_pixels    = size * 1.5,\n            bold           = opt.bold,\n            italic         = opt.italic,\n            halign         = opt.halign ? opt.halign : 'left',\n            valign         = opt.valign ? opt.valign : 'bottom',\n            tag            = typeof opt.tag == 'string' && opt.tag.length > 0 ? opt.tag : '',\n            marker         = opt.marker,\n            angle          = opt.angle || 0;\n\n\n\n\n        var bounding                = opt.bounding,\n            bounding_stroke         = opt['bounding.stroke'] ? opt['bounding.stroke'] : 'black',\n            bounding_fill           = opt['bounding.fill'] ? opt['bounding.fill'] : 'rgba(255,255,255,0.7)',\n            bounding_shadow         = opt['bounding.shadow'],\n            bounding_shadow_color   = opt['bounding.shadow.color'] || '#ccc',\n            bounding_shadow_blur    = opt['bounding.shadow.blur'] || 3,\n            bounding_shadow_offsetx = opt['bounding.shadow.offsetx'] || 3,\n            bounding_shadow_offsety = opt['bounding.shadow.offsety'] || 3,\n            bounding_linewidth      = typeof opt['bounding.linewidth'] === 'number' ? opt['bounding.linewidth'] : 1;\n\n\n\n        //\n        // Initialize the return value to an empty object\n        //\n        var ret = {};\n        \n        //\n        // Color\n        //\n        if (typeof opt.color === 'string') {\n            var orig_fillstyle = context.fillStyle;\n            context.fillStyle = opt.color;\n        }\n\n\n\n        //\n        // The text arg must be a string or a number\n        //\n        if (typeof text == 'number') {\n            text = String(text);\n        }\n\n        if (typeof text !== 'string') {\n            return;\n        }\n        \n        \n        \n        //\n        // This facilitates vertical text\n        //\n        if (angle != 0) {\n            context.save();\n            context.translate(x, y);\n            context.rotate((Math.PI / 180) * angle)\n            x = 0;\n            y = 0;\n        }\n\n\n        \n        //\n        // Set the font\n        //\n        context.font = (opt.italic ? 'italic ' : '') + (opt.bold ? 'bold ' : '') + size + 'pt ' + font;\n\n\n\n        //\n        // Measure the width/height. This must be done AFTER the font has been set\n        //\n        var width=0;\n        for (var i=0; i<numlines; ++i) {\n            width = Math.max(width, context.measureText(text_multiline[i]).width);\n        }\n        var height = size_pixels * numlines;\n\n\n\n\n        //\n        // Accommodate old MSIE 7/8\n        //\n        //if (document.all && RGraph.ISOLD) {\n            //y += 2;\n        //}\n\n\n\n        //\n        // If marker is specified draw a marker at the X/Y coordinates\n        //\n        if (opt.marker) {\n            \n            var marker_size = 10;\n            var strokestyle = context.strokeStyle;\n            \n            context.beginPath();\n                context.strokeStyle = 'red';\n                context.moveTo(x, y - marker_size);\n                context.lineTo(x, y + marker_size);\n                context.moveTo(x - marker_size, y);\n                context.lineTo(x + marker_size, y);\n            context.stroke();\n            context.strokeStyle = strokestyle;\n        }\n\n\n\n        //\n        // Set the horizontal alignment\n        //\n        if (halign == 'center') {\n            context.textAlign = 'center';\n            var boundingX = x - 2 - (width / 2);\n        } else if (halign == 'right') {\n            context.textAlign = 'right';\n            var boundingX = x - 2 - width;\n        } else {\n            context.textAlign = 'left';\n            var boundingX = x - 2;\n        }\n\n\n        //\n        // Set the vertical alignment\n        //\n        if (valign == 'center') {\n            \n            context.textBaseline = 'middle';\n            // Move the text slightly\n            y -= 1;\n            \n            y -= ((numlines - 1) / 2) * size_pixels;\n            var boundingY = y - (size_pixels / 2) - 2;\n        \n        } else if (valign == 'top') {\n            context.textBaseline = 'top';\n\n            var boundingY = y - 2;\n\n        } else {\n\n            context.textBaseline = 'bottom';\n            \n            // Move the Y coord if multiline text\n            if (numlines > 1) {\n                y -= ((numlines - 1) * size_pixels);\n            }\n\n            var boundingY = y - size_pixels - 2;\n        }\n        \n        var boundingW = width + 4;\n        var boundingH = height + 4;\n\n\n\n        //\n        // Draw a bounding box if required\n        //\n        if (bounding) {\n\n            var pre_bounding_linewidth     = context.lineWidth,\n                pre_bounding_strokestyle   = context.strokeStyle,\n                pre_bounding_fillstyle     = context.fillStyle,\n                pre_bounding_shadowcolor   = context.shadowColor,\n                pre_bounding_shadowblur    = context.shadowBlur,\n                pre_bounding_shadowoffsetx = context.shadowOffsetX,\n                pre_bounding_shadowoffsety = context.shadowOffsetY;\n\n            context.lineWidth   = bounding_linewidth ? bounding_linewidth : 0.001;\n            context.strokeStyle = bounding_stroke;\n            context.fillStyle   = bounding_fill;\n\n            if (bounding_shadow) {\n                context.shadowColor   = bounding_shadow_color;\n                context.shadowBlur    = bounding_shadow_blur;\n                context.shadowOffsetX = bounding_shadow_offsetx;\n                context.shadowOffsetY = bounding_shadow_offsety;\n            }\n\n            //obj.context.strokeRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);\n            //obj.context.fillRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);\n            context.fillRect(\n                boundingX,\n                boundingY,\n                boundingW,\n                boundingH\n            );\n            \n            context.strokeRect(\n                boundingX,\n                boundingY,\n                boundingW,\n                boundingH\n            );\n\n            // Reset the linewidth,colors and shadow to it's original setting\n            context.lineWidth     = pre_bounding_linewidth;\n            context.strokeStyle   = pre_bounding_strokestyle;\n            context.fillStyle     = pre_bounding_fillstyle;\n            context.shadowColor   = pre_bounding_shadowcolor\n            context.shadowBlur    = pre_bounding_shadowblur\n            context.shadowOffsetX = pre_bounding_shadowoffsetx\n            context.shadowOffsetY = pre_bounding_shadowoffsety\n        }\n\n        \n        \n        //\n        // Draw the text\n        //\n        if (numlines > 1) {\n            for (var i=0; i<numlines; ++i) {\n                context.fillText(text_multiline[i], x, y + (size_pixels * i));\n            }\n        } else {\n            context.fillText(text, x + 0.5, y + 0.5);\n        }\n        \n        \n        \n        //\n        // If the text is at 90 degrees restore() the canvas - getting rid of the rotation\n        // and the translate that we did\n        //\n        if (angle != 0) {\n            if (angle == 90) {\n                if (halign == 'left') {\n                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'center') {boundingX = originalX - (height / 2) - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'top')    {boundingX = originalX - height - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\n                \n                } else if (halign == 'center') {\n                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'center') {boundingX = originalX - (height / 2) -  2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'top')    {boundingX = originalX - height -  2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}\n                \n                } else if (halign == 'right') {\n                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'center') {boundingX = originalX - (height / 2) - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'top')    {boundingX = originalX - height - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\n                }\n\n            } else if (angle == 180) {\n\n                if (halign == 'left') {\n                    if (valign == 'bottom') {boundingX = originalX - width - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}\n                    if (valign == 'center') {boundingX = originalX - width - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}\n                    if (valign == 'top')    {boundingX = originalX - width - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}\n                \n                } else if (halign == 'center') {\n                    if (valign == 'bottom') {boundingX = originalX - (width / 2) - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}\n                    if (valign == 'center') {boundingX = originalX - (width / 2) - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}\n                    if (valign == 'top')    {boundingX = originalX - (width / 2) - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}\n                \n                } else if (halign == 'right') {\n                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}\n                    if (valign == 'center') {boundingX = originalX - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}\n                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}\n                }\n            \n            } else if (angle == 270) {\n\n                if (halign == 'left') {\n                    if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'center') {boundingX = originalX - (height / 2) - 4; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\n                \n                } else if (halign == 'center') {\n                    if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'center') {boundingX = originalX - (height/2) - 4; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}\n                \n                } else if (halign == 'right') {\n                    if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'center') {boundingX = originalX - (height/2) - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\n                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\n                }\n            }\n\n            context.restore();\n        }\n\n\n\n\n        //\n        // Reset the text alignment so that text rendered after this text function is not affected\n        //\n        context.textBaseline = 'alphabetic';\n        context.textAlign    = 'left';\n\n\n\n\n\n        //\n        // Fill the ret variable with details of the text\n        //\n        ret.x      = boundingX;\n        ret.y      = boundingY;\n        ret.width  = boundingW;\n        ret.height = boundingH\n        ret.object = obj;\n        ret.text   = text;\n        ret.tag    = tag;\n\n\n\n        //\n        // Save and then return the details of the text (but oly\n        // if it's an RGraph object that was given)\n        //\n        if (obj && obj.isRGraph && obj.coordsText) {\n            obj.coordsText.push(ret);\n        }\n        \n        //\n        // Restore the original fillstyle\n        //\n        if (typeof orig_fillstyle === 'string') {\n            context.fillStyle = orig_fillstyle;\n        }\n\n        return ret;\n    };\n    \n    // Create the DEFAULTS object\n    RGraph.text.defaults = {};\n\n\n\n\n\n\n\n\n    //\n    // Takes a sequential index abd returns the group/index variation of it. Eg if you have a\n    // sequential index from a grouped bar chart this function can be used to convert that into\n    // an appropriate group/index combination\n    // \n    // @param nindex number The sequential index\n    // @param data   array  The original data (which is grouped)\n    // @return              The group/index information\n    //\n    RGraph.sequentialIndexToGrouped = function (index, data)\n    {\n        var group         = 0;\n        var grouped_index = 0;\n\n        while (--index >= 0) {\n\n            if (RGraph.is_null(data[group])) {\n                group++;\n                grouped_index = 0;\n                continue;\n            }\n\n            // Allow for numbers as well as arrays in the dataset\n            if (typeof data[group] == 'number') {\n                group++\n                grouped_index = 0;\n                continue;\n            }\n            \n\n            grouped_index++;\n            \n            if (grouped_index >= data[group].length) {\n                group++;\n                grouped_index = 0;\n            }\n        }\n        \n        return [group, grouped_index];\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function highlights a rectangle\n    // \n    // @param object obj    The chart object\n    // @param number shape  The coordinates of the rect to highlight\n    //\n    RGraph.Highlight.rect =\n    RGraph.Highlight.Rect = function (obj, shape)\n    {\n        var prop = obj.properties;\n\n        if (prop.tooltipsHighlight) {\n            \n        \n            // Safari seems to need this\n            obj.context.lineWidth = 1;\n\n\n            //\n            // Draw a rectangle on the canvas to highlight the appropriate area\n            //\n            obj.context.beginPath();\n\n                obj.context.strokeStyle = prop.highlightStroke;\n                obj.context.fillStyle   = prop.highlightFill;\n    \n                obj.context.rect(shape['x'],shape['y'],shape['width'],shape['height']);\n                //obj.context.fillRect(shape['x'],shape['y'],shape['width'],shape['height']);\n            obj.context.stroke();\n            obj.context.fill();\n        }\n    };\n\n\n\n\n    //\n    // This function highlights a point\n    // \n    // @param object obj    The chart object\n    // @param number shape  The coordinates of the rect to highlight\n    //\n    RGraph.Highlight.point =\n    RGraph.Highlight.Point = function (obj, shape)\n    {\n        var prop = obj.properties;\n\n        if (prop.tooltipsHighlight) {\n    \n            //\n            // Draw a rectangle on the canvas to highlight the appropriate area\n            //\n            obj.context.beginPath();\n                obj.context.strokeStyle = prop.highlightStroke;\n                obj.context.fillStyle   = prop.highlightFill;\n                var radius   = prop.highlightPointRadius || 2;\n                obj.context.arc(shape['x'],shape['y'],radius, 0, RGraph.TWOPI, 0);\n            obj.context.stroke();\n            obj.context.fill();\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // A better, more flexible, date parsing function that\n    // was taken from the SVG libraries.\n    //\n    //@param  string str The string to parse\n    //@return number     A number, as returned by Date.parse()\n    //\n    RGraph.parseDate = function (str)\n    {\n        // First off - remove the T from the format: YYYY-MM-DDTHH:MM:SS\n        if (str.match(/^\\d\\d\\d\\d-\\d\\d-\\d\\d(t|T)\\d\\d:\\d\\d(:\\d\\d)?$/)) {\n            str = str.toUpperCase().replace(/T/, ' ');\n        }\n\n\n        var d = new Date();\n\n        // Initialise the default values\n        var defaults = {\n            seconds: '00',\n            minutes: '00',\n              hours: '00',\n               date: d.getDate(),\n              month: d.getMonth() + 1,\n               year: d.getFullYear()\n        };\n\n        // Create the months array for turning textual months back to numbers\n        var months       = ['january','february','march','april','may','june','july','august','september','october','november','december'],\n            months_regex = months.join('|');\n\n        for (var i=0; i<months.length; ++i) {\n            months[months[i]] = i;\n            months[months[i].substring(0,3)] = i;\n            months_regex = months_regex + '|' + months[i].substring(0,3);\n        }\n\n        // These are the seperators allowable for d/m/y and y/m/d dates\n        // (Its part of a regexp so the position of the square brackets\n        //  is crucial)\n        var sep = '[-./_=+~#:;,]+';\n\n\n        // Tokenise the string\n        var tokens = str.split(/ +/);\n\n        // Loop through each token checking what it is\n        for (var i=0,len=tokens.length; i<len; ++i) {\n            if (tokens[i]) {\n                \n                // Year\n                if (tokens[i].match(/^\\d\\d\\d\\d$/)) {\n                    defaults.year = tokens[i];\n                }\n\n                // Month\n                var res = isMonth(tokens[i]);\n                if (typeof res === 'number') {\n                    defaults.month = res + 1; // Months are zero indexed\n                }\n\n                // Date\n                if (tokens[i].match(/^\\d?\\d(?:st|nd|rd|th)?$/)) {\n                    defaults.date = parseInt(tokens[i]);\n                }\n\n                // Time\n                if (tokens[i].match(/^(\\d\\d):(\\d\\d):?(?:(\\d\\d))?$/)) {\n                    defaults.hours   = parseInt(RegExp.$1);\n                    defaults.minutes = parseInt(RegExp.$2);\n                    \n                    if (RegExp.$3) {\n                        defaults.seconds = parseInt(RegExp.$3);\n                    }\n                }\n\n                // Dateformat: XXXX-XX-XX\n                if (tokens[i].match(new RegExp('^(\\\\d\\\\d\\\\d\\\\d)' + sep + '(\\\\d\\\\d)' + sep + '(\\\\d\\\\d)$', 'i'))) {\n                    defaults.date  = parseInt(RegExp.$3);\n                    defaults.month = parseInt(RegExp.$2);\n                    defaults.year  = parseInt(RegExp.$1);\n\n                }\n\n                // Dateformat: XX-XX-XXXX\n                if (tokens[i].match(new RegExp('^(\\\\d\\\\d)' + sep + '(\\\\d\\\\d)' + sep + '(\\\\d\\\\d\\\\d\\\\d)$','i') )) {\n                    defaults.date  = parseInt(RegExp.$1);\n                    defaults.month = parseInt(RegExp.$2);\n                    defaults.year  = parseInt(RegExp.$3);\n                }\n            }\n        }\n\n        // Now put the defaults into a format thats recognised by Date.parse()\n        str = '{1}/{2}/{3} {4}:{5}:{6}'.format(\n            defaults.year,\n            String(defaults.month).length     === 1 ? '0' + (defaults.month) : defaults.month,\n            String(defaults.date).length      === 1 ? '0' + (defaults.date)      : defaults.date,\n            String(defaults.hours).length     === 1 ? '0' + (defaults.hours)     : defaults.hours,\n            String(defaults.minutes).length   === 1 ? '0' + (defaults.minutes)   : defaults.minutes,\n            String(defaults.seconds).length   === 1 ? '0' + (defaults.seconds)   : defaults.seconds\n        );\n\n        return Date.parse(str);\n\n        //\n        // Support functions\n        //\n        function isMonth(str)\n        {\n            var res = str.toLowerCase().match(months_regex);\n\n            return res ? months[res[0]] : false;\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This is the same as Date.parse - though a little more flexible.\n    // \n    // @param string str The date string to parse\n    // @return Returns the same thing as Date.parse\n    //\n    RGraph.parseDateOld = function (str)\n    {\n        str = RGraph.trim(str);\n\n        // Allow for: now (just the word \"now\")\n        if (str === 'now') {\n            str = (new Date()).toString();\n        }\n\n\n        // Allow for: 22-11-2013\n        // Allow for: 22/11/2013\n        // Allow for: 22-11-2013 12:09:09\n        // Allow for: 22/11/2013 12:09:09\n        if (str.match(/^(\\d\\d)(?:-|\\/)(\\d\\d)(?:-|\\/)(\\d\\d\\d\\d)(.*)$/)) {\n            str = '{1}/{2}/{3}{4}'.format(\n                RegExp.$3,\n                RegExp.$2,\n                RegExp.$1,\n                RegExp.$4\n            );\n        }\n\n        // Allow for: 2013-11-22 12:12:12 or  2013/11/22 12:12:12\n        if (str.match(/^(\\d\\d\\d\\d)(-|\\/)(\\d\\d)(-|\\/)(\\d\\d)( |T)(\\d\\d):(\\d\\d):(\\d\\d)$/)) {\n            str = RegExp.$1 + '-' + RegExp.$3 + '-' + RegExp.$5 + 'T' + RegExp.$7 + ':' + RegExp.$8 + ':' + RegExp.$9;\n        }\n\n        // Allow for: 2013-11-22\n        if (str.match(/^\\d\\d\\d\\d-\\d\\d-\\d\\d$/)) {\n            str = str.replace(/-/g, '/');\n        }\n\n\n        // Allow for: 12:09:44 (time only using todays date)\n        if (str.match(/^\\d\\d:\\d\\d:\\d\\d$/)) {\n        \n            var dateObj  = new Date();\n            var date     = dateObj.getDate();\n            var month    = dateObj.getMonth() + 1;\n            var year     = dateObj.getFullYear();\n            \n            // Pad the date/month with a zero if it's not two characters\n            if (String(month).length === 1) month = '0' + month;\n            if (String(date).length === 1) date = '0' + date;\n\n            str = (year + '/' + month + '/' + date) + ' ' + str;\n        }\n\n        return Date.parse(str);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Reset all of the color values to their original values\n    // \n    // @param object\n    //\n    RGraph.resetColorsToOriginalValues = function (obj)\n    {\n        if (obj.original_colors) {\n            // Reset the colors to their original values\n            for (var j in obj.original_colors) {\n                if (typeof j === 'string') {// TAKEN OUT 1st AUGUST && j.substr(0,6) === 'chart.'\n                    obj.properties[j] = RGraph.arrayClone(obj.original_colors[j]);\n                }\n            }\n        }\n\n\n\n        //\n        // If the function is present on the object to reset specific colors - use that\n        //\n        if (typeof obj.resetColorsToOriginalValues === 'function') {\n            obj.resetColorsToOriginalValues();\n        }\n\n\n\n        // Reset the colorsParsed flag so that they're parsed for gradients again\n        obj.colorsParsed = false;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Creates a Linear gradient\n    // \n    // @param object obj The chart object\n    // @param number x1 The start X coordinate\n    // @param number x2 The end X coordinate\n    // @param number y1 The start Y coordinate\n    // @param number y2 The end Y coordinate\n    // @param string color1 The start color\n    // @param string color2 The end color\n    //\n    RGraph.linearGradient =\n    RGraph.LinearGradient = function (obj, x1, y1, x2, y2, color1, color2)\n    {\n        var gradient = obj.context.createLinearGradient(x1, y1, x2, y2);\n        var numColors=arguments.length-5;\n        \n        for (var i=5; i<arguments.length; ++i) {\n            \n            var color = arguments[i];\n            var stop = (i - 5) / (numColors - 1);\n            \n            gradient.addColorStop(stop, color);\n        }\n        \n        return gradient;\n    };\n\n\n\n\n\n\n\n    \n    //\n    // Creates a Radial gradient\n    // \n    // @param object obj The chart object\n    // @param number x1 The start X coordinate\n    // @param number x2 The end X coordinate\n    // @param number y1 The start Y coordinate\n    // @param number y2 The end Y coordinate\n    // @param string color1 The start color\n    // @param string color2 The end color\n    //\n    RGraph.radialGradient =\n    RGraph.RadialGradient = function(obj, x1, y1, r1, x2, y2, r2, color1, color2)\n    {\n        var gradient  = obj.context.createRadialGradient(x1, y1, r1, x2, y2, r2);\n        var numColors = arguments.length-7;\n        \n        for(var i=7; i<arguments.length; ++i) {\n            \n            var color = arguments[i];\n            var stop  = (i-7) / (numColors-1);\n            \n            gradient.addColorStop(stop, color);\n        }\n        \n        return gradient;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Adds an event listener to RGraphs internal array so that RGraph can track them.\n    // This DOESN'T add the event listener to the canvas/window.\n    // \n    // 5/1/14 TODO Used in the tooltips file, but is it necessary any more?\n    //\n    RGraph.addEventListener =\n    RGraph.AddEventListener = function (id, e, func)\n    {\n        var type = arguments[3] ? arguments[3] : 'unknown';\n        \n        RGraph.Registry.get('event.handlers').push([id,e,func,type]);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Clears event listeners that have been installed by RGraph\n    // \n    // @param string id The ID of the canvas to clear event listeners for - or 'window' to clear\n    //                  the event listeners attached to the window\n    //\n    RGraph.clearEventListeners =\n    RGraph.ClearEventListeners = function(id)\n    {\n        if (id && id == 'window') {\n        \n            window.removeEventListener('mousedown', window.__rgraph_mousedown_event_listener_installed__, false);\n            window.removeEventListener('mouseup', window.__rgraph_mouseup_event_listener_installed__, false);\n        \n        } else {\n            \n            var canvas = document.getElementById(id);\n            \n            canvas.removeEventListener('mouseup', canvas.__rgraph_mouseup_event_listener_installed__, false);\n            canvas.removeEventListener('mousemove', canvas.__rgraph_mousemove_event_listener_installed__, false);\n            canvas.removeEventListener('mousedown', canvas.__rgraph_mousedown_event_listener_installed__, false);\n            canvas.removeEventListener('click', canvas.__rgraph_click_event_listener_installed__, false);\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Hides the annotating palette. It's here because it can be called\n    // from code other than the annotating code.\n    //\n    RGraph.hidePalette =\n    RGraph.HidePalette = function ()\n    {\n        var div = RGraph.Registry.get('palette');\n        \n        if(typeof div == 'object' && div) {\n            \n            div.style.visibility = 'hidden';\n            div.style.display = 'none';\n            \n            RGraph.Registry.set('palette', null);\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // Generates a random number between the minimum and maximum\n    // \n    // @param number min The minimum value\n    // @param number max The maximum value\n    // @param number     OPTIONAL Number of decimal places\n    //\n    RGraph.random = function (min, max)\n    {\n        var dp = arguments[2] ? arguments[2] : 0;\n        var r  = Math.random();\n        \n        return Number((((max - min) * r) + min).toFixed(dp));\n    };\n\n\n\n\n\n\n\n\n    //\n    // \n    //\n    RGraph.arrayRand =\n    RGraph.arrayRandom =\n    RGraph.random.array = function (num, min, max)\n    {\n        for(var i=0,arr=[]; i<num; i+=1) {\n            arr.push(RGraph.random(min,max, arguments[3]));\n        }\n        \n        return arr;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Turns off shadow by setting blur to zero, the offsets to zero and the color to transparent black.\n    // \n    // @param object obj The chart object\n    //\n    RGraph.noShadow =\n    RGraph.NoShadow = function (obj)\n    {\n\n        obj.context.shadowColor   = 'rgba(0,0,0,0)';\n        obj.context.shadowBlur    = 0;\n        obj.context.shadowOffsetx = 0;\n        obj.context.shadowOffsety = 0;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Sets the various shadow properties\n    // \n    // @param object obj     The chart object\n    // @param string color   The color of the shadow\n    // @param number offsetx The offsetX value for the shadow\n    // @param number offsety The offsetY value for the shadow\n    // @param number blur    The blurring value for the shadow\n    //\n    RGraph.setShadow =\n    RGraph.SetShadow = function (opt)\n    {\n        // 1 Argument\n        if (   typeof opt === 'object'\n            && typeof opt.object === 'object'\n            && typeof opt.object.isRGraph\n            && typeof opt.prefix === 'string'\n           ) {\n            var obj = opt.object;\n\n            obj.context.shadowColor   = obj.properties[opt.prefix + 'Color'];\n            obj.context.shadowOffsetX = obj.properties[opt.prefix + 'Offsetx'];\n            obj.context.shadowOffsetY = obj.properties[opt.prefix + 'Offsety'];\n            obj.context.shadowBlur    = obj.properties[opt.prefix + 'Blur'];\n\n        // Turn Off the shadow\n        } else if (   arguments.length === 1\n                   && typeof arguments[0] === 'object'\n                   && typeof arguments[0].isRGraph) {\n            \n            var obj = arguments[0];\n\n            obj.context.shadowColor   = 'rgba(0,0,0,0)';\n            obj.context.shadowOffsetX = 0;\n            obj.context.shadowOffsetY = 0;\n            obj.context.shadowBlur    = 0;\n\n        // Separate arguments\n        } else {\n\n            var obj = arguments[0];\n    \n            obj.context.shadowColor   = arguments[1];\n            obj.context.shadowOffsetX = arguments[2];\n            obj.context.shadowOffsetY = arguments[3];\n            obj.context.shadowBlur    = arguments[4];\n        }\n    };\n\n\n\n\n\n\n\n    //\n    // Sets an object in the RGraph registry\n    // \n    // @param string name The name of the value to set\n    //\n    RGraph.Registry.set =\n    RGraph.Registry.Set = function (name, value)\n    {\n        // Convert uppercase letters to dot+lower case letter\n        name = name.replace(/([A-Z])/g, function (str)\n        {\n            return '.' + String(RegExp.$1).toLowerCase();\n        });\n\n        RGraph.Registry.store[name] = value;\n        \n        return value;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Gets an object from the RGraph registry\n    // \n    // @param string name The name of the value to fetch\n    //\n    RGraph.Registry.get =\n    RGraph.Registry.Get = function (name)\n    {\n        // Convert uppercase letters to dot+lower case letter\n        name = name.replace(/([A-Z])/g, function (str)\n        {\n            return '.' + String(RegExp.$1).toLowerCase();\n        });\n\n\n        return RGraph.Registry.store[name];\n    };\n\n\n\n\n\n\n\n\n    //\n    // Converts the given number of degrees to radians. Angles in canvas are\n    // measured in radians. There are a .toDegrees() function and a toRadians()\n    // function too.\n    // \n    // @param number deg The value to convert\n    //\n    RGraph.degrees2Radians = function (deg)\n    {\n        return deg * (RGraph.PI / 180);\n    };\n    \n    // Usage RGraph.toRadians(360) // 6.28\n    RGraph.toRadians = function (degrees)\n    {\n        return degrees * (RGraph.PI / 180);\n    };\n\n    // Usage: RGraph.toDegrees(3.14) // 180ish\n    RGraph.toDegrees = function (radians)\n    {\n        return radians * (180 / Math.PI);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Generates logs for... log charts\n    // \n    // @param number n    The number to generate the log for\n    // @param number base The base to use\n    //\n    RGraph.log = function (n,base)\n    {\n        return Math.log(n) / (base ? Math.log(base) : 1);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Determines if the given object is an array or not\n    // \n    // @param mixed obj The variable to test\n    //\n    RGraph.isArray =\n    RGraph.is_array = function (obj)\n    {\n        if (obj && obj.constructor) {\n            var pos = obj.constructor.toString().indexOf('Array');\n        } else {\n            return false;\n        }\n\n        return obj != null &&\n               typeof pos === 'number' &&\n               pos > 0 &&\n               pos < 20;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Removes white-space from the start aqnd end of a string\n    // \n    // @param string str The string to trim\n    //\n    RGraph.trim = function (str)\n    {\n        return RGraph.ltrim(RGraph.rtrim(str));\n    };\n\n\n\n\n\n\n\n\n    //\n    // Trims the white-space from the start of a string\n    // \n    // @param string str The string to trim\n    //\n    RGraph.ltrim = function (str)\n    {\n        return str.replace(/^(\\s|\\0)+/, '');\n    };\n\n\n\n\n\n\n\n\n    //\n    // Trims the white-space off of the end of a string\n    // \n    // @param string str The string to trim\n    //\n    RGraph.rtrim = function (str)\n    {\n        return str.replace(/(\\s|\\0)+$/, '');\n    };\n\n\n\n\n\n\n\n\n    //\n    // Returns true/false as to whether the given variable is null or not\n    // \n    // @param mixed arg The argument to check\n    //\n    RGraph.isNull =\n    RGraph.is_null = function (arg)\n    {\n        // must BE DOUBLE EQUALS - NOT TRIPLE\n        if (arg == null || typeof arg === 'object' && !arg) {\n            return true;\n        }\n        \n        return false;\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function facilitates a very limited way of making your charts\n    // whilst letting the rest of page continue - using  the setTimeout function\n    // \n    // @param function func The function to run that creates the chart\n    //\n    RGraph.async =\n    RGraph.Async = function (func)\n    {\n        return setTimeout(func, arguments[1] ? arguments[1] : 1);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Resets (more than just clears) the canvas and clears any pertinent objects\n    // from the ObjectRegistry\n    // \n    // @param object canvas The canvas object (as returned by document.getElementById() ).\n    //\n    RGraph.reset =\n    RGraph.Reset = function (canvas)\n    {\n        canvas.width = canvas.width;\n        \n        RGraph.ObjectRegistry.clear(canvas);\n        \n        canvas.__rgraph_aa_translated__ = false;\n\n        if (RGraph.text.domNodeCache && RGraph.text.domNodeCache.reset) {\n            RGraph.text.domNodeCache.reset(canvas);\n        }\n\n        // Create the node and dimension caches if they don't already exist\n        if (!RGraph.text.domNodeCache)          { RGraph.text.domNodeCache          = []; }\n        if (!RGraph.text.domNodeDimensionCache) { RGraph.text.domNodeDimensionCache = []; }\n\n        // Create/reset the specific canvas arrays in the caches\n        RGraph.text.domNodeCache[canvas.id]          = [];\n        RGraph.text.domNodeDimensionCache[canvas.id] = [];\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function is due to be removed.\n    // \n    // @param string id The ID of what can be either the canvas tag or a DIV tag\n    //\n    RGraph.getCanvasTag = function (id)\n    {\n        id = typeof id === 'object' ? id.id : id;\n        var canvas = doc.getElementById(id);\n\n        return [id, canvas];\n    };\n\n\n\n\n\n\n\n\n    //\n    // A wrapper function that encapsulate requestAnimationFrame\n    // \n    // @param function func The animation function\n    //\n    RGraph.Effects.updateCanvas =\n    RGraph.Effects.UpdateCanvas = function (func)\n    {\n        win.requestAnimationFrame =    win.requestAnimationFrame\n                                    || win.webkitRequestAnimationFrame\n                                    || win.msRequestAnimationFrame\n                                    || win.mozRequestAnimationFrame\n                                    || (function (func){setTimeout(func, 16.666);});\n        \n        win.requestAnimationFrame(func);\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function returns an easing multiplier for effects so they eas out towards the\n    // end of the effect.\n    // \n    // @param number frames The total number of frames\n    // @param number frame  The frame number\n    //\n    RGraph.Effects.getEasingMultiplier = function (frames, frame)\n    {\n        return Math.pow(Math.sin((frame / frames) * RGraph.HALFPI), 3);\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function converts an array of strings to an array of numbers. Its used by the meter/gauge\n    // style charts so that if you want you can pass in a string. It supports various formats:\n    // \n    // '45.2'\n    // '-45.2'\n    // ['45.2']\n    // ['-45.2']\n    // '45.2,45.2,45.2' // A CSV style string\n    // \n    // @param number frames The string or array to parse\n    //\n    RGraph.stringsToNumbers = function (str)\n    {\n        // An optional seperator to use intead of a comma\n        var sep = arguments[1] || ',';\n        \n        \n        // If it's already a number just return it\n        if (typeof str === 'number') {\n            return str;\n        }\n\n\n\n\n\n        if (typeof str === 'string') {\n            if (str.indexOf(sep) != -1) {\n                str = str.split(sep);\n            } else {\n                str = parseFloat(str);\n            }\n        }\n\n\n\n\n\n        if (typeof str === 'object' && !RGraph.isNull(str)) {\n            for (var i=0,len=str.length; i<len; i+=1) {\n                str[i] = parseFloat(str[i]);\n            }\n        }\n\n        return str;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Drawing cache function. This function creates an off-screen canvas and draws [wwhatever] to it\n    // and then subsequent calls use that  instead of repeatedly drawing the same thing.\n    // \n    // @param object   obj  The graph object\n    // @param string   id   An ID string used to identify the relevant entry in the cache\n    // @param function func The drawing function. This will be called to do the draw.\n    //\n    RGraph.cachedDraw = function (obj, id, func)\n    {\n\n\n\n        /////////////////////////////////////////\n        //\n        // This bypasses caching entirely:\n        //\n        // func(obj, obj.canvas, obj.context);\n        // return;\n        //\n        /////////////////////////////////////////\n\n\n\n\n\n        //If the cache entry exists - just copy it across to the main canvas\n        if (!RGraph.cache[id]) {\n\n            RGraph.cache[id] = {};\n\n            RGraph.cache[id].object = obj;\n            RGraph.cache[id].canvas = document.createElement('canvas');\n\n            RGraph.cache[id].canvas.setAttribute('width', obj.canvas.width);\n            RGraph.cache[id].canvas.setAttribute('height', obj.canvas.height);\n            RGraph.cache[id].canvas.setAttribute('id', 'background_cached_canvas' + obj.canvas.id);\n\n            RGraph.cache[id].canvas.__object__ = obj;\n            RGraph.cache[id].context = RGraph.cache[id].canvas.getContext('2d');\n            \n            // Antialiasing on the cache canvas\n            RGraph.cache[id].context.translate(0.5,0.5);\n\n            // Call the function\n            func(obj, RGraph.cache[id].canvas, RGraph.cache[id].context);\n        }\n\n        // Now copy the contents of the cached canvas over to the main one.\n        // The coordinates are -0.5 because of the anti-aliasing effect in\n        // use on the main canvas\n        obj.context.drawImage(RGraph.cache[id].canvas,-0.5,-0.5);\n    };\n\n\n\n\n\n\n\n\n    //\n    // The function that runs through the supplied configuration and\n    // converts it to the RGraph stylee.\n    // \n    // @param object conf The config\n    // @param object      The settings for the object\n    //\n    RGraph.parseObjectStyleConfig = function (obj, config)\n    {\n        for (var i in config) {\n            if (typeof i === 'string') {\n                obj.set(i, config[i]);\n            }\n        }\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function is a short-cut for the canvas path syntax (which can be rather\n    // verbose). You can read a description of it (which details all of the\n    // various options) on the RGraph blog (www.rgraph.net/blog). The function is\n    // added to the CanvasRenderingContext2D object so it becomes a context function.\n    // \n    // So you can use it like these examples show:\n    // \n    // 1. RGraph.path(context, 'b r 0 0 50 50 f red');\n    // 2. RGraph.path(context, 'b a 50 50 50 0 3.14 false f red');\n    // 3. RGraph.path(context, 'b m 5 100 bc 5 0 100 0 100 100 s red');\n    // 4. RGraph.path(context, 'b m 5 100 at 50 0 95 100 50 s red');\n    // 5. RGraph.path(context, 'sa b r 0 0 50 50 c b r 5 5 590 240 f red rs');\n    // 6. RGraph.path(context, 'ld [2,6] ldo 4 b r 5 5 590 240 f red');\n    // 7. RGraph.path(context, 'ga 0.25 b r 5 5 590 240 f red');\n    // \n    // @param   array p  The path details\n    //\n    RGraph.path =\n    RGraph.path2 = function (opt)\n    {\n        var arguments = Array.prototype.slice.call(arguments);\n\n        // Allow a single arg to be passed as well as multiple\n\n        // Object is passed\n        if (arguments.length === 1 && opt.object && opt.path) {\n            var context = opt.object.context;\n            var p       = opt.path;\n            var args    = opt.args;\n        \n        // Context is passed\n        } else if (arguments.length === 1 && opt.context && opt.path) {\n            var context  = opt.context;\n            var p        = opt.path;\n            var args     = opt.args;\n        \n        // Multiple args, object given\n        } else if (arguments.length >= 2 && arguments[0].isRGraph && arguments[0].context) {\n            var context = arguments[0].context;\n            var p       = arguments[1];\n            var args    = arguments.length > 2 ? arguments.slice(2) : [];\n        \n        // Multiple args, context given\n        } else if (arguments.length >= 2 && arguments[0].toString().indexOf('Context')) {\n            var context   = arguments[0];\n            var p         = arguments[1];\n            var args      = arguments.length > 2 ? arguments.slice(2) : [];\n        }\n\n        \n        // If the path was a string - split it then collapse quoted bits together\n        if (typeof p === 'string') {\n            p = splitstring(p);\n        }\n\n        // Store the last path on the RGraph object\n        RGraph.path.last = RGraph.arrayClone(p);\n\n        // Go through the path information.\n        for (var i=0,len=p.length; i<len; i+=1) {\n\n            switch (p[i]) {\n                case 'b':context.beginPath();break;\n                case 'c':context.closePath();break;\n                case 'm':context.moveTo(parseFloat(p[i+1]),parseFloat(p[i+2]));i+=2;break;\n                case 'l':context.lineTo(parseFloat(p[i+1]),parseFloat(p[i+2]));i+=2;break;\n                case 's':if(p[i+1])context.strokeStyle=p[i+1];context.stroke();i++;break;\n                case 'f':if(p[i+1]){context.fillStyle=p[i+1];}context.fill();i++;break;\n                case 'qc':context.quadraticCurveTo(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;\n                case 'bc':context.bezierCurveTo(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]));i+=6;break;\n                case 'r':context.rect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;\n                case 'a':context.arc(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),p[i+6]==='true'||p[i+6]===true||p[i+6]===1||p[i+6]==='1'?true:false);i+=6;break;\n                case 'at':context.arcTo(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]));i+=5;break;\n                case 'lw':context.lineWidth=parseFloat(p[i+1]);i++;break;\n                case 'e':context.ellipse(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]),parseFloat(p[i+7]),p[i+8] === 'true' ? true : false);i+=8;break;\n                case 'lj':context.lineJoin=p[i+1];i++;break;\n                case 'lc':context.lineCap=p[i+1];i++;break;\n                case 'sc':context.shadowColor=p[i+1];i++;break;\n                case 'sb':context.shadowBlur=parseFloat(p[i+1]);i++;break;\n                case 'sx':context.shadowOffsetX=parseFloat(p[i+1]);i++;break;\n                case 'sy':context.shadowOffsetY=parseFloat(p[i+1]);i++;break;\n                case 'fs':context.fillStyle=p[i+1];i++;break;\n                case 'ss':context.strokeStyle=p[i+1];i++;break;\n                case 'fr':context.fillRect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;\n                case 'sr':context.strokeRect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;\n                case 'cl':context.clip();break;\n                case 'sa':context.save();break;\n                case 'rs':context.restore();break;\n                case 'tr':context.translate(parseFloat(p[i+1]),parseFloat(p[i+2]));i+=2;break;\n                case 'sl':context.scale(parseFloat(p[i+1]), parseFloat(p[i+2]));i+=2;break;\n                case 'ro':context.rotate(parseFloat(p[i+1]));i++;break;\n                case 'tf':context.transform(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]));i+=6;break;\n                case 'stf':context.setTransform(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]));i+=6;break;\n                case 'cr':context.clearRect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;\n                case 'ld':var parts = p[i+1];context.setLineDash(parts);i+=1;break;\n                case 'ldo':context.lineDashOffset=p[i+1];i++;break;\n                case 'fo':context.font=p[i+1];i++;break;\n                case 'ft':context.fillText(p[i+1], parseFloat(p[i+2]), parseFloat(p[i+3]));i+=3;break;\n                case 'st':context.strokeText(p[i+1], parseFloat(p[i+2]), parseFloat(p[i+3]));i+=3;break;\n                case 'ta':context.textAlign=p[i+1];i++;break;\n                case 'tbl':context.textBaseline=p[i+1];i++;break;\n                case 'ga':context.globalAlpha=parseFloat(p[i+1]);i++;break;\n                case 'gco':context.globalCompositeOperation=p[i+1];i++;break;\n                case 'fu':(p[i+1])(context.canvas.__object__);i++;break;\n                \n                // Empty option - ignore it\n                case '':break;\n                \n                // Unknown option\n                default: alert('[ERROR] Unknown option: ' + p[i]);\n            }\n        }\n        \n        function splitstring (p)\n        {\n            var ret = [], buffer = '', inquote = false, quote = '', substitutionIndex = 0;\n\n            // p ia string - not an array\n            for (var i=0; i<p.length; i+=1) {\n                \n                var chr = p[i],\n                    isWS = chr.match(/ /);\n\n                if (isWS) {\n                    if (!inquote) {\n\n                        // Get rid of any enclosing quotes\n                        if (buffer[0] === '\"' || buffer[0] === \"'\") {\n                            buffer = buffer.substr(1, buffer.length - 2);\n                        }\n\n\n                        // String substitution\n                        if (buffer.trim() === '%' && typeof args[substitutionIndex] !== 'undefined') {\n                            buffer = args[substitutionIndex++];\n                        }\n\n                        ret.push(buffer);\n                        buffer = '';\n                    } else {\n                        buffer += chr;\n                    }\n                } else {\n                    if (chr === \"'\" || chr === '\"') {\n                        inquote = !inquote;\n                    }\n\n                    buffer += chr;\n                }\n            }\n\n            // Do the last bit (including substitution)\n            if (buffer.trim() === '%' && args[substitutionIndex]) {\n                buffer = args[substitutionIndex++];\n            }\n\n            ret.push(buffer);\n\n            return ret;\n        }\n    };\n\n\n\n\n\n\n\n\n    // Allows the conversion of older names and values to newer\n    // ones.\n    //\n    // *** When adding this to a new chart library there needs to be\n    // *** two changes done:\n    // ***  o Add the list of aliases as a object variable (eg this.aliases = {}; )\n    // ***  o The bit that goes in the setter that calls the\n    // ***    RGraph.propertyNameAlias() function - copy this from the Bar chart object\n    //\n    //RGraph.propertyNameAlias = function (opt)\n    //{\n    //    var obj = opt.object;\n    //\n    //    if (typeof obj.propertyNameAliases[opt.name] === 'string') {\n    //        return {\n    //            name:  obj.propertyNameAliases[opt.name],\n    //            value: opt.value\n    //        };\n    //    } else if (typeof obj.propertyNameAliases[opt.name] === 'function') {\n    //        var tmp = (obj.propertyNameAliases[opt.name])(opt);\n    //\n    //        return {\n    //            name:  tmp.name,\n    //            value: tmp.value\n    //        };\n    //    }\n    //    \n    //    // Default response - return the name/value unchanged\n    //    return {\n    //        name:  opt.name,\n    //        value: opt.value\n    //    };\n    //};\n\n\n\n\n\n\n\n\n    //\n    // This function gets the text properties when given a relevant prefix.\n    // So if you give it 'text' as the prefix you'll get the:\n    //\n    //  o textFont\n    //  o textSize\n    //  o textColor\n    //  o textBold\n    //  o textItalic\n    //\n    // ...properties. On the other hand if you give it 'yaxisScaleLabels'\n    // as the prefix you'll get:\n    //\n    //  o yaxisScaleLabelsFont\n    //  o yaxisScaleLabelsSize\n    //  o yaxisScaleLabelsColor\n    //  o yaxisScaleLabelsBold\n    //  o yaxisScaleLabelsItalic\n    //\n    RGraph.getTextConf = function (opt)\n    {\n        var obj    = opt.object,\n            prop   = obj.properties,\n            prefix = opt.prefix;\n\n        // Has to be a seperate var statement\n        var font   = typeof prop[prefix + 'Font']   === 'string'  ? prop[prefix + 'Font']  : prop.textFont,\n            size   = typeof prop[prefix + 'Size']   === 'number'  ? prop[prefix + 'Size']  : prop.textSize,\n            color  = typeof prop[prefix + 'Color']  === 'string'  ? prop[prefix + 'Color'] : prop.textColor,\n            bold   = !RGraph.isNull(prop[prefix + 'Bold'])   ? prop[prefix + 'Bold']   : prop.textBold,\n            italic = !RGraph.isNull(prop[prefix + 'Italic']) ? prop[prefix + 'Italic'] : prop.textItalic;\n\n        return {\n            font:   font,\n            size:   size,\n            color:  color,\n            bold:   bold,\n            italic: italic\n        };\n    };\n\n\n\n\n\n\n\n\n    //\n    // This function can be used to resize the canvas when the screen size changes. You\n    // specify various rules and they're then checked.\n    //\n    RGraph.responsive = function (conf)\n    {\n        var opt = arguments[1] || {},\n            \n            // This function is added to each object in their constructors so the this\n            // variable is the chart object.\n            obj   = this,\n            \n            // The func variable becomes the function that is fired by the resize event\n            func  = null,\n            \n            // This is the timer reference\n            timer = null;\n        \n        // The resizie function will run This many milliseconds after the\n        // resize has \"finished\"\n        opt.delay = typeof opt.delay === 'number' ? opt.delay : 200;\n\n        // [TODO] Store defaults that are used if there's no match\n        var func = function ()\n        {\n            // This is set to true if a rule matches\n            var matched = false;\n\n            // Loop through all of the rules\n            for (var i=0; i<conf.length; ++i) {\n\n                //\n                // If a maxWidth is stipulated test that\n                //\n                if (!matched && (document.documentElement.clientWidth <= conf[i].maxWidth || RGraph.isNull(conf[i].maxWidth))) {\n                \n                    matched = true;\n                    \n                    // If a width is defined for this rule set it\n                    if (typeof conf[i].width === 'number') {\n                        if (obj.get('textAccessible')) {\n                            obj.canvas.parentNode.style.width  = conf[i].width + 'px';\n                        }\n                        \n                        obj.canvas.width = conf[i].width;\n                    }\n\n\n\n\n                    //\n                    // If a height is defined for this rule set it\n                    //\n                    if (typeof conf[i].height === 'number') {\n                        if (obj.get('textAccessible')) {\n                            obj.canvas.parentNode.style.height = conf[i].height + 'px';\n                        }\n\n                        obj.canvas.height = conf[i].height;\n                    }\n\n\n\n\n                    //\n                    // Are there any options to be set?\n                    //\n                    if (typeof conf[i].options === 'object' && typeof conf[i].options === 'object') {\n                        for (var j in conf[i].options) {\n                            if (typeof j === 'string') {\n                                obj.set(j, conf[i].options[j]);\n                            }\n                        }\n                    }\n\n\n                    //\n                    // This function simply sets a CSS property on the object.\n                    // It accommodates certain name changes\n                    //\n                    var setCSS = function (el, name, value)\n                    {\n                        var replacements = [\n                            ['float', 'cssFloat']\n                        ];\n                        \n                        // Replace the name if necessary\n                        for (var i=0; i<replacements.length; ++i) {\n                            if (name === replacements[i][0]) {\n                                name = replacements[i][1];\n                            }\n                        }\n\n                        el.style[name] = value;\n                    };\n\n\n\n\n                    //\n                    // Are there any CSS properties to set on the canvas tag?\n                    //\n                    if (typeof conf[i].css === 'object') {\n                        for (var j in conf[i].css) {\n                            if (typeof j === 'string') {\n                                if (obj.get('textAccessible')) {\n                                    setCSS(obj.canvas.parentNode, j, conf[i].css[j]);\n                                } else {\n                                    setCSS(obj.canvas, j, conf[i].css[j]);\n                                }\n                            }\n                        }\n                    }\n\n                    //\n                    // Are there any CSS properties to set on the canvas tahs PARENT?\n                    //\n                    if (typeof conf[i].parentCss === 'object') {\n                        for (var j in conf[i].parentCss) {\n                            if (typeof j === 'string') {\n                                if (obj.get('textAccessible')) {\n                                    setCSS(obj.canvas.parentNode.parentNode, j, conf[i].parentCss[j]);\n                                } else {\n                                    setCSS(obj.canvas.parentNode, j, conf[i].parentCss[j])\n                                }\n                            }\n                        }\n                    }\n\n\n                    // Redraw the chart\n                    RGraph.cache = [];\n                    RGraph.resetColorsToOriginalValues(obj);\n                    if (obj.get('textAccessible')) {\n                        RGraph.text.domNodeCache.reset(obj.canvas);\n                    }\n                    RGraph.redraw();\n\n\n                    // Run the callback function if it's defined\n                    if (typeof conf[i].callback === 'function') {\n                        (conf[i].callback)(obj);\n                    }\n                }\n            }\n        }\n\n\n\n\n\n\n        // Install the resize event listener\n        RGraph.responsive.window_resize_event_listener = function ()\n        {\n            // Set a new timer in order to fire the func() function\n            if (opt.delay > 0) {\n                // Clear the timeout\n                clearTimeout(timer);\n                \n                // Start a new timer going\n                timer = setTimeout(func, opt.delay);\n            \n            // If you don't want a delay before the resizing occurs\n            // then set the delay to zero and it will be fired immediately\n            } else {\n                func();\n            }\n        };\n        window.addEventListener('resize', RGraph.responsive.window_resize_event_listener, false);\n\n        \n        // Call the function initially otherwise it may never run\n        func();\n        \n        // This facilitates chaining\n        return obj;\n    };\n\n\n\n\n\n\n\n\n    //\n    // Wraps the canvas in a DIV to allow DOM text to be used\n    //\n    // NOT USED ANY MORE\n    //\n    RGraph.wrap = function () {};\n\n\n\n\n// End module pattern\n})(window, document);\n\n\n\n\n\n\n\n\n    //\n    // Uses the alert() function to show the structure of the given variable\n    // \n    // @param mixed v The variable to print/alert the structure of\n    //\n    window.$p = function (v)\n    {\n        RGraph.pr(arguments[0], arguments[1], arguments[3]);\n    };\n\n\n\n\n\n\n\n\n    //\n    // A shorthand for the default alert() function\n    //\n    window.$a = function (v)\n    {\n        alert(v);\n    };\n\n\n\n\n\n\n\n\n    //\n    // Short-hand for console.log\n    // \n    // @param mixed v The variable to log to the console\n    //\n    window.$cl = function (v)\n    {\n        return console.log(v);\n    };\n\n\n\n\n\n\n\n\n    //\n    // A basic string formatting function. Use it like this:\n    // \n    // var str = '{0} {1} {2}'.format('a', 'b', 'c');\n    // \n    // Outputs: a b c\n    //\n    String.prototype.format = function()\n    {\n        var args = arguments;\n        \n        var s = this.replace(/{(\\d+)}/g, function(str, idx)\n        {\n          return typeof args[idx - 1] !== 'undefined' ? args[idx - 1] : str;\n        });\n        \n        \n        // Save percentage signs that are escaped with either another\n        // percent or a backslash\n        s = s.replace(/(?:%|\\\\)%(\\d)/g,'__PPEERRCCEENNTT__$1');\n        \n        s = s.replace(/%(\\d+)/g, function(str, idx)\n        {\n          return typeof args[idx - 1] !== 'undefined' ? args[idx - 1] : str;\n        });\n        \n        // Now replace those saved percentage signs with a percentage sign\n        return s.replace('__PPEERRCCEENNTT__', '%');\n    };\n\n//# sourceURL=webpack:///../vendor/RGraph.common.core.js?");

/***/ }),

/***/ "../vendor/RGraph.rose.js":
/*!********************************!*\
  !*** ../vendor/RGraph.rose.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// version: 2019-10-11\n    // o--------------------------------------------------------------------------------o\n    // | This file is part of the RGraph package - you can learn more at:               |\n    // |                                                                                |\n    // |                         https://www.rgraph.net                                 |\n    // |                                                                                |\n    // | RGraph is licensed under the Open Source MIT license. That means that it's     |\n    // | totally free to use and there are no restrictions on what you can do with it!  |\n    // o--------------------------------------------------------------------------------o\n\n    RGraph              = window.RGraph || {isRGraph: true};\n    RGraph.Effects      = RGraph.Effects || {};\n    RGraph.Effects.Rose = RGraph.Effects.Rose || {};\n\n    //\n    // The rose chart constuctor\n    //\n    RGraph.Rose = function (conf)\n    {\n        this.id                = conf.id;\n        this.canvas            = document.getElementById(this.id);\n        this.context           = this.canvas.getContext ? this.canvas.getContext(\"2d\") : null;\n        this.data              = conf.data;\n        this.canvas.__object__ = this;\n        this.type              = 'rose';\n        this.isRGraph          = true;\n        this.uid               = RGraph.createUID();\n        this.canvas.uid        = this.canvas.uid ? this.canvas.uid : RGraph.createUID();\n        this.colorsParsed      = false;\n        this.coordsText        = [];\n        this.original_colors   = [];\n        this.firstDraw         = true; // After the first draw this will be false\n\n\n\n\n\n        this.centerx = 0;\n        this.centery = 0;\n        this.radius  = 0;\n        this.max     = 0;\n        this.angles  = [];\n        this.angles2 = [];\n\n        this.properties =\n        {\n            axes:                           false,\n            axesColor:                      'black',\n            axesLinewidth:                  1,\n            axesTickmarks:                  true,\n\n            backgroundGrid:                 true,\n            backgroundGridColor:            '#ccc',\n            backgroundGridSize:             null,\n            backgroundGridRadialsCount:     null,\n            backgroundGridCirclesCount:     5,\n            // [TODO] Need linewidth setting\n            \n            centerx:                        null,\n            centery:                        null,\n            radius:                         null,\n            \n            anglesStart:                    0,            \n            \n            linewidth:                      1,\n            \n            colors:                         ['rgba(255,0,0,0.5)', 'rgba(255,255,0,0.5)', 'rgba(0,255,255,0.5)', 'rgb(0,255,0)', 'gray', 'blue', 'rgb(255,128,255)','green', 'pink', 'gray', 'aqua'],\n            colorsSequential:               false,\n            colorsAlpha:                    null,\n            colorsStroke:                   'rgba(0,0,0,0)',\n            \n            margin:                         5,\n            marginLeft:                    25,\n            marginRight:                   25,\n            marginTop:                     25,\n            marginBottom:                  25,\n\n            shadow:                        false,\n            shadowColor:                   '#aaa',\n            shadowOffsetx:                 0,\n            shadowOffsety:                 0,\n            shadowBlur:                    15,\n\n            title:                         '',\n            titleBackground:               null,\n            titleHpos:                     null,\n            titleVpos:                     null,\n            titleBold:                     null,\n            titleFont:                     null,\n            titleSize:                     null,\n            titleItalic:                   null,\n            titleColor:                    null,\n            titleX:                        null,\n            titleY:                        null,\n            titleHalign:                   null,\n            titleValign:                   null,\n            \n            labels:                        null,\n            labelsColor:                   null,\n            labelsFont:                    null,\n            labelsSize:                    null,\n            labelsBold:                    null,\n            labelsItalic:                  null,\n            labelsPosition:                'center',\n            labelsBoxed:                   false,\n            labelsOffset:                  0,\n            labelsAxes:                    'n',\n            labelsAxesFont:                null,\n            labelsAxesSize:                null,\n            labelsAxesColor:               null,\n            labelsAxesBold:                null,\n            labelsAxesItalic:              null,\n            labelsAxesCount:               5,\n            \n            textColor:                     'black',\n            textFont:                      'Arial, Verdana, sans-serif',\n            textSize:                      12,\n            textBold:                      false,\n            textItalic:                    false,\n            textAccessible:                true,\n            textAccessibleOverflow:       'visible',\n            textAccessiblePointerevents:   false,\n\n            key:                           null,\n            keyBackground:                 'white',\n            keyPosition:                   'graph',\n            keyHalign:                     'right',\n            keyShadow:                     false,\n            keyShadowColor:                '#666',\n            keyShadowBlur:                 3,\n            keyShadowOffsetx:              2,\n            keyShadowOffsety:              2,\n            keyPositionGutterBoxed:        false,\n            keyPositionX:                  null,\n            keyPositionY:                  null,\n            keyColorShape:                 'square',\n            keyRounded:                    true,\n            keyLinewidth:                  1,\n            keyColors:                     null,\n            keyInteractive:                false,\n            keyInteractiveHighlightChartStroke: 'black',\n            keyInteractiveHighlightChartFill: 'rgba(255,255,255,0.7)',\n            keyInteractiveHighlightLabel:  'rgba(255,0,0,0.2)',\n            keyLabelsColor:                null,\n            keyLabelsFont:                 null,\n            keyLabelsSize:                 null,\n            keyLabelsBold:                 null,\n            keyLabelsItalic:               null,\n            keyLabelsOffsetx:              0,\n            keyLabelsOffsety:              0,\n\n            contextmenu:                   null,\n\n            tooltips:                      null,\n            tooltipsEvent:                 'onclick',\n            tooltipsEffect:                'fade',\n            tooltipsCssClass:              'RGraph_tooltip',\n            tooltipsHighlight:             true,\n\n            highlightStroke:               'rgba(0,0,0,0)',\n            highlightFill:                 'rgba(255,255,255,0.7)',\n\n            annotatable:                   false,\n            annotatableColor:              'black',\n            annotatableLinewidth:          1,\n\n            resizable:                     false,\n            resizableHandleAdjust:         [0,0],\n            resizableHandleBackground:     null,\n\n            adjustable:                    false,\n\n            scaleMax:                      null,\n            scaleMin:                      0,\n            scaleDecimals:                 null,\n            scalePoint:                    '.',\n            scaleThousand:                 ',',\n            scaleUnitsPre:                 '',\n            scaleUnitsPost:                '',\n\n            variant:                       'stacked',\n            variantThreedDepth:            10,\n\n            exploded:                      0,\n\n            eventsMousemove:               null,\n            eventsClick:                   null,\n\n            animationRoundrobinFactor:     1,\n            animationRoundrobinRadius:     true,\n            animationGrowMultiplier:       1,\n\n            segmentHighlight:              false,\n            segmentHighlightCount:         null,\n            segmentHighlightFill:          'rgba(0,255,0,0.5)',\n            segmentHighlightStroke:        'rgba(0,0,0,0)',\n\n            clearto:                       'rgba(0,0,0,0)'\n        }\n        \n        \n        \n        // Go through the data converting it to numbers\n        for (var i=0; i<this.data.length; ++i) {\n            if (typeof this.data[i] === 'string') {\n                this.data[i] = parseFloat(this.data[i]);\n            } else if (typeof this.data[i] === 'object') {\n                for (var j=0; j<this.data[i].length; ++j) {\n                    if (typeof this.data[i][j] === 'string') {\n                        this.data[i][j] = parseFloat(this.data[i][j]);\n                    }\n                }\n            }\n        }\n\n\n\n\n        //\n        // Create the $ objects. In the case of non-equi-angular rose charts it actually creates too many $ objects,\n        // but it doesn't matter.\n        //\n        var linear_data = RGraph.arrayLinearize(this.data);\n        this.data_seq = linear_data; // Add .data_seq\n        for (var i=0; i<linear_data.length; ++i) {\n            this[\"$\" + i] = {};\n        }\n\n\n        //\n        // Translate half a pixel for antialiasing purposes - but only if it hasn't beeen\n        // done already\n        //\n        if (!this.canvas.__rgraph_aa_translated__) {\n            this.context.translate(0.5,0.5);\n            \n            this.canvas.__rgraph_aa_translated__ = true;\n        }\n\n\n\n\n        // Short variable names\n        var prop = this.properties,\n            path = RGraph.path;\n        \n        \n        \n        //\n        // \"Decorate\" the object with the generic effects if the effects library has been included\n        //\n        if (RGraph.Effects && typeof RGraph.Effects.decorate === 'function') {\n            RGraph.Effects.decorate(this);\n        }\n        \n        \n        \n        // Add the reponsive method. This method resides in the common file.\n        this.responsive = RGraph.responsive;\n\n\n\n\n\n\n\n\n        //\n        // A simple setter\n        this.set = function (name)\n        {\n            var value = typeof arguments[1] === 'undefined' ? null : arguments[1];\n\n            // the number of arguments is only one and it's an\n            // object - parse it for configuration data and return.\n            if (arguments.length === 1 && typeof arguments[0] === 'object') {\n                for (i in arguments[0]) {\n                    if (typeof i === 'string') {\n                        this.set(i, arguments[0][i]);\n                    }\n                }\n\n                return this;\n            }\n\n            prop[name] = value;\n\n            return this;\n        };\n\n\n\n\n\n\n\n\n        //\n        // A simple getter\n        // \n        // @param string name The name of the property to get\n        //\n        this.get = function (name)\n        {\n            return prop[name];\n        };\n\n\n\n\n\n\n\n\n        //\n        // This method draws the rose chart\n        //\n        this.draw = function ()\n        {\n            //\n            // Fire the onbeforedraw event\n            //\n            RGraph.fireCustomEvent(this, 'onbeforedraw');\n\n\n\n            //\n            // Make the margins easy ro access\n            //\n            this.marginLeft   = prop.marginLeft;\n            this.marginRight  = prop.marginRight;\n            this.marginTop    = prop.marginTop;\n            this.marginBottom = prop.marginBottom;\n    \n            // Calculate the radius\n            this.radius       = (Math.min(this.canvas.width - this.marginLeft - this.marginRight, this.canvas.height - this.marginTop - this.marginBottom) / 2);\n            this.centerx      = ((this.canvas.width - this.marginLeft - this.marginRight) / 2) + this.marginLeft;\n            this.centery      = ((this.canvas.height - this.marginTop - this.marginBottom) / 2) + this.marginTop;\n            this.angles       = [];\n            this.angles2      = [];\n            this.total        = 0;\n            this.startRadians = prop.anglesStart;\n            this.coordsText   = [];\n\n            //\n            // Change the centerx marginally if the key is defined\n            //\n            if (prop.key && prop.key.length > 0 && prop.key.length >= 3) {\n                this.centerx = this.centerx - this.marginRight + 5;\n            }\n    \n    \n    \n            // User specified radius, centerx and centery\n            if (typeof prop.centerx == 'number') this.centerx = prop.centerx;\n            if (typeof prop.centery == 'number') this.centery = prop.centery;\n            if (typeof prop.radius  == 'number') this.radius  = prop.radius;\n    \n            //\n            // Parse the colors for gradients. Its down here so that the center X/Y can be used\n            //\n            if (!this.colorsParsed) {\n    \n                this.parseColors();\n    \n                // Don't want to do this again\n                this.colorsParsed = true;\n            }\n\n\n\n        // 3D variant\n        if (prop.variant.indexOf('3d') !== -1) {\n\n            var scaleX = 1.5;\n\n            this.context.setTransform(\n                scaleX,\n                0,\n                0,\n                1,\n                (this.canvas.width * scaleX - this.canvas.width) * -0.5,\n                0\n            );\n        }\n\n\n\n\n\n            this.drawBackground();\n\n\n\n\n\n            // If a 3D variant draw the depth\n            if (prop.variant.indexOf('3d') !== -1) {\n            \n                // Setting the shadow here means that the first (the bottom Rose)\n                // sill have a shadow but not upper iterations.\n                RGraph.setShadow(this,'rgba(0,0,0,0.35)',0,15,25);\n            \n                for (var i=prop.variantThreedDepth; i>0; i-=1) {\n            \n                    this.centery -= 1;\n            \n                    this.drawRose({storeAngles: false});\n            \n                    //RGraph.setShadow(this,'rgba(0,0,0,0)',0,0,0);\n                    RGraph.noShadow(this);\n            \n            \n                    // Make the segments darker\n                    for (var j=0,len=this.angles.length; j<len; j+=1) {\n            \n                        var a = this.angles[j];\n            \n                        path(this.context, [\n                            'b',\n                            'm', a[4], a[5],\n                            'a', a[4], a[5], a[3] + 1.5, a[0] - 0.01, a[1] + 0.01, false,\n                            'c',\n                            'f', 'rgba(0,0,0,0.1)'\n                        ]);\n                    }\n                }\n            }\n\n            this.drawRose();\n            this.drawLabels();\n\n            //\n            // Set the strokestyle to transparent because of a strange double stroke bug\n            // \n            // DO NOT REMOVE\n            //\n            this.context.strokeStyle = 'rgba(0,0,0,0)'\n\n\n            //\n            // Setup the context menu if required\n            //\n            if (prop.contextmenu) {\n                RGraph.showContext(this);\n            }\n    \n            \n            //\n            // This function enables resizing\n            //\n            if (prop.resizable) {\n                RGraph.allowResizing(this);\n            }\n    \n            \n            //\n            // This function enables adjusting\n            //\n            if (prop.adjustable) {\n                RGraph.allowAdjusting(this);\n            }\n    \n    \n            //\n            // This installs the event listeners\n            //\n            RGraph.installEventListeners(this);\n\n\n\n\n\n            //\n            // Allow the segments to be highlighted\n            //\n            if (prop.segmentHighlight) {\n                \n                // Check to see if the dynamic library has been included\n                if (!RGraph.allowSegmentHighlight) {\n                    alert('[WARNING] The segment highlight function does not exist - have you included the dynamic library?');\n                }\n\n                RGraph.allowSegmentHighlight({\n                    object: this,\n                    count:  typeof prop.segmentHighlightCount === 'number' ? prop.segmentHighlightCount : this.data.length,\n                    fill:   prop.segmentHighlightFill,\n                    stroke: prop.segmentHighlightStroke\n                });\n            }\n\n\n\n            //\n            // Fire the onfirstdraw event\n            //\n            if (this.firstDraw) {\n                this.firstDraw = false;\n                RGraph.fireCustomEvent(this, 'onfirstdraw');\n                this.firstDrawFunc();\n            }\n\n\n\n            //\n            // Fire the RGraph ondraw event\n            //\n            RGraph.fireCustomEvent(this, 'ondraw');\n            \n            return this;\n        };\n\n\n\n\n\n\n\n\n        //\n        // Used in chaining. Runs a function there and then - not waiting for\n        // the events to fire (eg the onbeforedraw event)\n        // \n        // @param function func The function to execute\n        //\n        this.exec = function (func)\n        {\n            func(this);\n            \n            return this;\n        };\n\n\n\n\n\n\n\n\n        //\n        // This method draws the rose charts background\n        //\n        this.drawBackground = function ()\n        {\n            this.context.lineWidth = 1;\n    \n    \n            // Draw the background grey circles/spokes\n            if (prop.backgroundGridCirclesCount) {\n                \n                if (typeof(prop.backgroundGridCirclesCount) == 'number') {\n                    prop.backgroundGridCirclesSize = this.radius / prop.backgroundGridCirclesCount;\n                }\n        \n                this.context.beginPath();\n                    this.context.strokeStyle = prop.backgroundGridColor;\n                    \n                    // Radius must be greater than 0 for Opera to work\n                    for (var i=prop.backgroundGridCirclesSize; i<=this.radius; i+=prop.backgroundGridCirclesSize) {\n                        \n                        // Hmmm... This is questionable\n                        this.context.moveTo(this.centerx + i, this.centery);\n            \n                        // Radius must be greater than 0 for Opera to work\n                        this.context.arc(\n                            this.centerx,\n                            this.centery,\n                            i,\n                            0,\n                            RGraph.TWOPI,\n                            false\n                        );\n                    }\n                this.context.stroke();\n    \n    \n    \n    \n    \n    \n                // Draw the background lines that go from the center outwards\n                this.context.beginPath();\n                if (typeof prop.backgroundGridRadialsCount !== 'number') {\n                    prop.backgroundGridRadialsCount = this.data.length\n                }\n                \n                if (prop.backgroundGridRadialsCount > 0) {\n\n                    var num = (360 / prop.backgroundGridRadialsCount);\n    \n                    for (var i=0; i<=360; i+=num) {\n                    \n                        // Radius must be greater than 0 for Opera to work\n                        this.context.arc(\n                            this.centerx,\n                            this.centery,\n                            this.radius,\n                            ((i / (180 / RGraph.PI)) - RGraph.HALFPI) + this.startRadians,\n                            (((i + 0.0001) / (180 / RGraph.PI)) - RGraph.HALFPI) + this.startRadians,\n                            false\n                           );\n    \n                        this.context.lineTo(this.centerx, this.centery);\n                    }\n                    this.context.stroke();\n                }\n            }\n    \n    \n    \n            if (prop.axes) {\n            \n                this.context.beginPath();\n                this.context.strokeStyle = prop.axesColor;\n                this.context.lineWidth   = prop.axesLinewidth;\n\n                // Draw the X axis\n                this.context.moveTo(this.centerx - this.radius, Math.round(this.centery) );\n                this.context.lineTo(this.centerx + this.radius, Math.round(this.centery) );\n            \n                if (prop.axesTickmarks) {\n                    // Draw the X ends\n                    this.context.moveTo(Math.round(this.centerx - this.radius), this.centery - 5);\n                    this.context.lineTo(Math.round(this.centerx - this.radius), this.centery + 5);\n                    this.context.moveTo(Math.round(this.centerx + this.radius), this.centery - 5);\n                    this.context.lineTo(Math.round(this.centerx + this.radius), this.centery + 5);\n                \n                    // Draw the X check marks\n                    for (var i=(this.centerx - this.radius); i<(this.centerx + this.radius); i+=(this.radius / 5)) {\n                        this.context.moveTo(Math.round(i),  this.centery - 3);\n                        this.context.lineTo(Math.round(i),  this.centery + 3.5);\n                    }\n                \n                    // Draw the Y check marks\n                    for (var i=(this.centery - this.radius); i<(this.centery + this.radius); i+=(this.radius / 5)) {\n                        this.context.moveTo(this.centerx - 3, Math.round(i));\n                        this.context.lineTo(this.centerx + 3, Math.round(i));\n                    }\n                }\n            \n                // Draw the Y axis\n                this.context.moveTo(Math.round(this.centerx), this.centery - this.radius);\n                this.context.lineTo(Math.round(this.centerx), this.centery + this.radius);\n                \n                if (prop.axesTickmarks) {\n                    // Draw the Y ends\n                    this.context.moveTo(this.centerx - 5, Math.round(this.centery - this.radius));\n                    this.context.lineTo(this.centerx + 5, Math.round(this.centery - this.radius));\n            \n                    this.context.moveTo(this.centerx - 5, Math.round(this.centery + this.radius));\n                    this.context.lineTo(this.centerx + 5, Math.round(this.centery + this.radius));\n                }\n                \n                // Stroke it\n                this.context.closePath();\n                this.context.stroke();\n            }\n            \n            path(this.context, 'b c');\n        };\n\n\n\n\n\n\n\n\n        //\n        // This method draws the data on the graph\n        //\n        this.drawRose = function ()\n        {\n            var max    = 0,\n                data   = this.data,\n                margin = RGraph.toRadians(prop.margin),\n                opt    = arguments[0] || {};\n\n            this.context.lineWidth = prop.linewidth;\n    \n            // Work out the maximum value and the sum\n            if (RGraph.isNull(prop.scaleMax)) {\n    \n                // Work out the max\n                for (var i=0; i<data.length; ++i) {\n                    if (typeof data[i] == 'number') {\n                        max = Math.max(max, data[i]);\n                    } else if (typeof data[i] == 'object' && prop.variant.indexOf('non-equi-angular') !== -1) {\n                        max = Math.max(max, data[i][0]);\n                    \n                    // Fallback is stacked\n                    } else {\n                        max = Math.max(max, RGraph.arraySum(data[i]));\n                    }\n                }\n    \n                this.scale2 = RGraph.getScale({object: this, options: {\n                    'scale.max':max,\n                    'scale.min':0,\n                    'scale.thousand':     prop.scaleThousand,\n                    'scale.point':        prop.scalePoint,\n                    'scale.decimals':     prop.scaleDecimals,\n                    'scale.labels.count': prop.labelsAxesCount,\n                    'scale.round':        prop.scaleRound,\n                    'scale.units.pre':    prop.scaleUnitsPre,\n                    'scale.units.post':   prop.scaleUnitsPost\n                }});\n                this.max = this.scale2.max;\n    \n            } else {\n    \n                var ymax = prop.scaleMax;\n    \n    \n    \n                this.scale2 = RGraph.getScale({object: this, options: {\n                    'scale.max':          ymax,\n                    'scale.strict':       true,\n                    'scale.thousand':     prop.scaleThousand,\n                    'scale.point':        prop.scalePoint,\n                    'scale.decimals':     prop.scaleDecimals,\n                    'scale.labels.count': prop.labelsAxesCount,\n                    'scale.round':        prop.scaleRound,\n                    'scale.units.pre':    prop.scaleUnitsPre,\n                    'scale.units.post':   prop.scaleUnitsPost\n                }});\n                this.max = this.scale2.max\n            }\n\n            this.sum = RGraph.arraySum(data);\n            \n            // Move to the centre\n            this.context.moveTo(this.centerx, this.centery);\n        \n            this.context.stroke(); // Stroke the background so it stays grey\n        \n            // Transparency\n            if (prop.colorsAlpha) {\n                this.context.globalAlpha = prop.colorsAlpha;\n            }\n            \n            var sequentialIndex = 0;\n    \n            //\n            // A non-equi-angular Rose chart\n            //\n            if (typeof(prop.variant) == 'string' && prop.variant.indexOf('non-equi-angular') !== -1) {\n\n                var total=0;\n                for (var i=0; i<data.length; ++i) {\n                    total += data[i][1];\n                }\n                \n                if (prop.shadow) {\n                    RGraph.setShadow(\n                        this,\n                        prop.shadowColor,\n                        prop.shadowOffsetx,\n                        prop.shadowOffsety,\n                        prop.shadowBlur\n                    );\n                }\n\n                for (var i=0; i<this.data.length; ++i) {\n                \n                    var segmentRadians = ((this.data[i][1] / total) * RGraph.TWOPI);\n                    var radius         = ((this.data[i][0] - prop.scaleMin) / (this.max - prop.scaleMin)) * this.radius;\n                        radius = radius * prop.animationGrowMultiplier;\n    \n                    this.context.strokeStyle = prop.colorsStroke;\n                    this.context.fillStyle   = prop.colors[0];\n    \n                    if (prop.colorsSequential) {\n                        this.context.fillStyle = prop.colors[i];\n                    }\n\n                    this.context.beginPath(); // Begin the segment\n    \n                        var startAngle = (this.startRadians * prop.animationRoundrobinFactor) - RGraph.HALFPI + margin;\n                        var endAngle   = ((this.startRadians + segmentRadians) * prop.animationRoundrobinFactor) - RGraph.HALFPI - margin;\n    \n                        var exploded  = this.getExploded(i, startAngle, endAngle, prop.exploded);\n                        var explodedX = exploded[0];\n                        var explodedY = exploded[1];\n    \n    \n                        this.context.arc(\n                            this.centerx + explodedX,\n                            this.centery + explodedY,\n                            prop.animationRoundrobinRadius ? radius * prop.animationRoundrobinFactor : radius,\n                            startAngle,\n                            endAngle,\n                            0\n                        );\n                        this.context.lineTo(this.centerx + explodedX, this.centery + explodedY);\n                    this.context.closePath(); // End the segment\n                    \n                    this.context.stroke();\n                    this.context.fill();\n                    \n                    // Store the start and end angles\n\n                    this.angles[i] = [\n                        startAngle,\n                        endAngle,\n                        0,\n                        prop.animationRoundrobinRadius ? radius * prop.animationRoundrobinFactor : radius,\n                        this.centerx + explodedX,\n                        this.centery + explodedY,\n                        this.context.strokeStyle,\n                        this.context.fillStyle\n                    ];\n                    \n                    sequentialIndex++;\n                    this.startRadians += segmentRadians;\n                }\n                \n                // Turn the shadow off it its enabled and redraw the chart\n                if (prop.shadow) {\n                    RGraph.noShadow(this);\n                    this.redrawRose();\n                }\n                \n                //\n                // Now redraw the rose if the linewidth is larger than 2 so that the\n                // fills appear under the strokes\n                //\n                if (prop.linewidth > 1) {\n                    this.restrokeRose();\n                }\n\n            } else {\n            \n                var sequentialColorIndex = 0;\n                \n                if (prop.shadow) {\n                    RGraph.setShadow(\n                        this,\n                        prop.shadowColor,\n                        prop.shadowOffsetx,\n                        prop.shadowOffsety,\n                        prop.shadowBlur\n                    );\n                }\n\n                //\n                // Draw regular segments here\n                //\n                for (var i=0; i<this.data.length; ++i) {\n\n                    var segmentRadians = (1 / this.data.length) * RGraph.TWOPI;\n\n                    if (typeof this.data[i] == 'number') {\n                        this.context.beginPath(); // Begin the segment\n    \n                            this.context.strokeStyle = prop.colorsStroke;\n                            this.context.fillStyle = prop.colors[0];\n            \n                            //\n                            // This allows sequential colors\n                            //\n                            if (prop.colorsSequential) {\n                                this.context.fillStyle = prop.colors[i];\n                            }\n\n                            var radius = ((this.data[i] - prop.scaleMin) / (this.max - prop.scaleMin)) * this.radius;\n                                radius = radius * prop.animationGrowMultiplier;\n    \n                            var startAngle = (this.startRadians * prop.animationRoundrobinFactor) - RGraph.HALFPI + margin;\n                            var endAngle   = (this.startRadians * prop.animationRoundrobinFactor) + (segmentRadians * prop.animationRoundrobinFactor) - RGraph.HALFPI - margin;\n    \n                            var exploded  = this.getExploded(i, startAngle, endAngle, prop.exploded);\n                            var explodedX = exploded[0];\n                            var explodedY = exploded[1];\n    \n                            this.context.arc(\n                                this.centerx + explodedX,\n                                this.centery + explodedY,\n                                prop.animationRoundrobinRadius ? radius * prop.animationRoundrobinFactor : radius,\n                                startAngle,\n                                endAngle,\n                                0\n                            );\n                            this.context.lineTo(this.centerx + explodedX, this.centery + explodedY);\n                        this.context.closePath(); // End the segment\n                        this.context.fill();\n                        this.context.stroke();\n\n                        // This skirts a double-stroke bug\n                        this.context.beginPath();\n\n                        if (endAngle == 0) {\n                            //endAngle = RGraph.TWOPI;\n                        }\n\n                        // Store the start and end angles\n                        this.angles[i] = [\n                            startAngle,\n                            endAngle,\n                            0,\n                            radius * prop.animationRoundrobinFactor,\n                            this.centerx + explodedX,\n                            this.centery + explodedY,\n                            this.context.strokeStyle,\n                            this.context.fillStyle\n                        ];\n                        \n                        sequentialIndex++;\n    \n                    //\n                    // Draw a stacked segment\n                    //\n                    } else if (typeof(this.data[i]) == 'object') {\n\n                        var margin = prop.margin / (180 / RGraph.PI);\n\n                        \n                        // Initialise the angles2 array\n                        if (!this.angles2[i]) {\n                            this.angles2[i] = [];\n                        }\n                        \n\n                        for (var j=0; j<this.data[i].length; ++j) {\n\n                            var startAngle = (this.startRadians * prop.animationRoundrobinFactor) - RGraph.HALFPI + margin;\n                            var endAngle  = (this.startRadians * prop.animationRoundrobinFactor)+ (segmentRadians * prop.animationRoundrobinFactor) - RGraph.HALFPI - margin;\n                        \n                            var exploded  = this.getExploded(i, startAngle, endAngle, prop.exploded);\n                            var explodedX = exploded[0];\n                            var explodedY = exploded[1];\n        \n                            this.context.strokeStyle = prop.colorsStroke;\n                            this.context.fillStyle   = prop.colors[j];\n    \n                            // This facilitates sequential color support\n                            if (prop.colorsSequential) {\n                                this.context.fillStyle = prop.colors[sequentialColorIndex++];\n                            }\n    \n                            if (j == 0) {\n                                this.context.beginPath(); // Begin the segment\n                                    var startRadius = 0;\n                                    var endRadius = ((this.data[i][j] - prop.scaleMin) / (this.max - prop.scaleMin)) * this.radius;\n                                        endRadius = endRadius * prop.animationGrowMultiplier;\n                        \n                                    this.context.arc(this.centerx + explodedX,\n                                           this.centery + explodedY,\n                                           prop.animationRoundrobinRadius ? endRadius * prop.animationRoundrobinFactor : endRadius,\n                                           startAngle,\n                                           endAngle,\n                                           0);\n                                    this.context.lineTo(this.centerx + explodedX, this.centery + explodedY);\n                                this.context.closePath(); // End the segment\n                                this.context.stroke();\n                                this.context.fill();\n\n                                this.angles[sequentialIndex++] = [\n                                    startAngle,\n                                    endAngle,\n                                    0,\n                                    endRadius * prop.animationRoundrobinFactor,\n                                    this.centerx + explodedX,\n                                    this.centery + explodedY,\n                                    this.context.strokeStyle,\n                                    this.context.fillStyle\n                                ];\n        \n                                this.angles2[i][j] = [\n                                    startAngle,\n                                    endAngle,\n                                    0,\n                                    endRadius * prop.animationRoundrobinFactor,\n                                    this.centerx + explodedX,\n                                    this.centery + explodedY,\n                                    this.context.strokeStyle,\n                                    this.context.fillStyle\n                                ];\n                            \n                            } else {\n\n                                this.context.beginPath(); // Begin the segment\n                                    \n                                    var startRadius = endRadius; // This comes from the prior iteration of this loop\n                                    var endRadius = (((this.data[i][j] - prop.scaleMin) / (this.max - prop.scaleMin)) * this.radius) + startRadius;\n                                        endRadius = endRadius * prop.animationGrowMultiplier;\n                    \n                                    this.context.arc(this.centerx + explodedX,\n                                           this.centery + explodedY,\n                                           startRadius  * prop.animationRoundrobinFactor,\n                                           startAngle,\n                                           endAngle,\n                                           0);\n                    \n                                    this.context.arc(this.centerx + explodedX,\n                                           this.centery + explodedY,\n                                           endRadius  * prop.animationRoundrobinFactor,\n                                           endAngle,\n                                           startAngle,\n                                           true);\n                    \n                                this.context.closePath(); // End the segment\n                                this.context.stroke();\n                                this.context.fill();\n        \n\n                                this.angles[sequentialIndex++] = [\n                                    startAngle,\n                                    endAngle,\n                                    startRadius * prop.animationRoundrobinFactor,\n                                    endRadius * prop.animationRoundrobinFactor,\n                                    this.centerx + explodedX,\n                                    this.centery + explodedY,\n                                    this.context.strokeStyle,\n                                    this.context.fillStyle\n                                ];\n        \n                                this.angles2[i][j] = [\n                                    startAngle,\n                                    endAngle,\n                                    startRadius * prop.animationRoundrobinFactor,\n                                    endRadius * prop.animationRoundrobinFactor,\n                                    this.centerx + explodedX,\n                                    this.centery + explodedY,\n                                    this.context.strokeStyle,\n                                    this.context.fillStyle\n                                ];\n                            }\n                        }\n                    }\n        \n                    this.startRadians += segmentRadians;\n                        \n                }\n\n\n                if (prop.shadow) {\n                    RGraph.noShadow(this);\n                }\n\n\n\n                //\n                // Now redraw the rose if the shadow is enabled so that\n                // the rose appears over the shadow\n                //\n                if (prop.shadow) {\n                    this.redrawRose();\n                }\n\n\n                //\n                // Now redraw the rose if the linewidth is larger than 2 so that the\n                // fills appear under the strokes\n                //\n                if (prop.linewidth > 1) {\n                    this.restrokeRose();\n                }\n\n\n                //\n                // Now redraw the rose if the shadow is enabled so that\n                // the rose appears over the shadow\n                //\n                if (prop.shadow) {\n                    this.redrawRose();\n                }\n            }\n    \n            // Turn off the transparency\n            if (prop.colorsAlpha) {\n                this.context.globalAlpha = 1;\n            }\n    \n            // Draw the title if any has been set\n            if (prop.title) {\n                RGraph.drawTitle(\n                    this,\n                    prop.title,\n                    (this.canvas.height / 2) - this.radius,\n                    this.centerx,\n                    prop.titleSize ? prop.titleSize : prop.textSize\n                );\n            }\n        };\n\n\n\n\n\n\n\n\n        //\n        // This function redraws the stroke on the chart so that\n        // the strokes appear above the fill\n        //\n        this.restrokeRose = function ()\n        {\n            var angles = this.angles;\n\n            for (var i=0; i<angles.length; ++i) {\n                path(\n                    this.context,\n                    'b a % % % % % false a % % % % % true c s %',\n\n                    angles[i][4], // x\n                    angles[i][5], // y\n                    angles[i][2], // radius\n                    angles[i][0], // start angle\n                    angles[i][1], // end angle\n\n                    angles[i][4], // x\n                    angles[i][5], // y\n                    angles[i][3], // radius\n                    angles[i][1], // end angle\n                    angles[i][0], // start angle\n                    angles[i][6], // strokestyle\n                );\n            }\n        };\n\n\n\n\n\n\n\n\n        //\n        // This function redraws the rose if the shadow is enabled so the it\n        // appears above the shadow\n        //\n        this.redrawRose = function ()\n        {\n            var angles = this.angles;\n\n            for (var i=0; i<angles.length; ++i) {\n                \n                path(\n                    this.context,\n                    'b a % % % % % false a % % % % % true c f % f % ',\n\n                    angles[i][4], // x\n                    angles[i][5], // y\n                    angles[i][2], // radius\n                    angles[i][0], // start angle\n                    angles[i][1], // end angle\n\n                    angles[i][4], // x\n                    angles[i][5], // y\n                    angles[i][3], // radius\n                    angles[i][1], // end angle\n                    angles[i][0], // start angle\n                    angles[i][6], // strokestyle\n                    angles[i][7]  // fillstyle\n                );\n            }\n        };\n\n\n\n\n\n\n\n\n        //\n        // Unsuprisingly, draws the labels\n        //\n        this.drawLabels = function ()\n        {\n            this.context.lineWidth = 1;\n            var key = prop.key;\n    \n            if (key && key.length) {\n                RGraph.drawKey(this, key, prop.colors);\n            }\n            \n            // Set the color to black\n            this.context.fillStyle   = prop.textColor;\n            this.context.strokeStyle = 'black';\n            \n            var radius      = this.radius,\n                font        = prop.textFont,\n                size        = prop.textSize,\n                axes        = prop.labelsAxes.toLowerCase(),\n                decimals    = prop.scaleDecimals,\n                units_pre   = prop.scaleUnitsPre,\n                units_post  = prop.scaleUnitsPost,\n                centerx     = this.centerx,\n                centery     = this.centery + (prop.variant.indexOf('3d') !== -1 ? prop.variantThreedDepth : 0);\n\n            // Draw any circular labels\n            if (typeof prop.labels == 'object' && prop.labels) {\n                this.drawCircularLabels(this.context, prop.labels, font, size, radius + 10);\n            }\n    \n    \n            // Size can be specified seperately for the scale now\n            if (typeof(prop.textSize) == 'number') {\n                size = prop.textSize;\n            }\n    \n    \n            var color = 'rgba(255,255,255,0.8)';\n    \n            // The \"North\" axis labels\n            if (axes.indexOf('n') > -1) {\n            \n                // The offset for the labels\n                if (prop.backgroundAxes) {\n                    var offset = -10;\n                    var halign = 'right';\n                } else {\n                    var offset = 0;\n                    var halign = 'center';\n                }\n                \n                var textConf = RGraph.getTextConf({\n                    object: this,\n                    prefix: 'labelsAxes'\n                });\n\n                for (var i=0; i<prop.labelsAxesCount; ++i) {\n                    RGraph.text({\n                        \n                   object: this,\n\n                     font: textConf.font,\n                     size: textConf.size,\n                    color: textConf.color,\n                     bold: textConf.bold,\n                   italic: textConf.italic,\n\n                        'x':centerx + offset,\n                        'y':centery - (radius * ((i+1) / prop.labelsAxesCount)),\n                        'text':this.scale2.labels[i],\n                        'valign':'center',\n                        'halign': halign,\n                        'bounding':true,\n                        'bounding.fill':color,\n                        'bounding.stroke': 'rgba(0,0,0,0)',\n                        'tag': 'scale'\n                    });\n                }\n            }\n    \n            // The \"South\" axis labels\n            if (axes.indexOf('s') > -1) {\n\n                // The offset for the labels\n                if (prop.backgroundAxes) {\n                    var offset = -10;\n                    var halign = 'right';\n                } else {\n                    var offset = 0;\n                    var halign = 'center';\n                }\n\n                for (var i=0; i<prop.labelsAxesCount; ++i) {\n                    RGraph.text({\n                        \n                   object: this,\n\n                     font: textConf.font,\n                     size: textConf.size,\n                    color: textConf.color,\n                     bold: textConf.bold,\n                   italic: textConf.italic,\n\n                        'x':centerx + offset,\n                        'y':centery + (radius * ((i+1) / prop.labelsAxesCount)),\n                        'text':this.scale2.labels[i],\n                        'valign':'center',\n                        'halign':halign,\n                        'bounding':true,\n                        'bounding.fill':color,\n                        'bounding.stroke':'rgba(0,0,0,0)',\n                        'tag': 'scale'\n                    });\n                }\n            }\n            \n            // The \"East\" axis labels\n            if (axes.indexOf('e') > -1) {\n                for (var i=0; i<prop.labelsAxesCount; ++i) {\n            \n                    // The offset for the labels\n                    if (prop.backgroundAxes) {\n                        var offset = 10;\n                        var valign = 'top';\n                    } else {\n                        var offset = 0;\n                        var valign = 'center';\n                    }\n\n                    RGraph.text({\n                        \n                   object: this,\n\n                     font: textConf.font,\n                     size: textConf.size,\n                    color: textConf.color,\n                     bold: textConf.bold,\n                   italic: textConf.italic,\n\n                        'x':centerx + (radius * ((i+1) / prop.labelsAxesCount)),\n                        'y':centery + offset,\n                        'text':this.scale2.labels[i],\n                        'valign':valign,\n                        'halign':'center',\n                        'bounding':true,\n                        'bounding.fill':color,\n                        'bounding.stroke':'rgba(0,0,0,0)',\n                        'tag': 'scale'\n                    });\n                }\n            }\n    \n            // The \"West\" axis labels\n            if (axes.indexOf('w') > -1) {\n                for (var i=0; i<prop.labelsAxesCount; ++i) {\n            \n                    // The offset for the labels\n                    if (prop.backgroundAxes) {\n                        var offset = 10;\n                        var valign = 'top';\n                    } else {\n                        var offset = 0;\n                        var valign = 'center';\n                    }\n\n                    RGraph.text({\n                        \n                   object: this,\n\n                     font: textConf.font,\n                     size: textConf.size,\n                    color: textConf.color,\n                     bold: textConf.bold,\n                   italic: textConf.italic,\n\n                        'x':centerx - (radius * ((i+1) / prop.labelsAxesCount)),\n                        'y':centery + offset,\n                        'text':this.scale2.labels[i],\n                        'valign':valign,\n                        'halign':'center',\n                        'bounding':true,\n                        'bounding.fill':color,\n                        'bounding.stroke': 'rgba(0,0,0,0)',\n                        'tag': 'scale'\n                    });\n                }\n            }\n\n            // Draw the minimum value\n            if (RGraph.trim(axes).length > 0) {\n                RGraph.text({\n                    \n               object: this,\n\n                 font: textConf.font,\n                 size: textConf.size,\n                color: textConf.color,\n                 bold: textConf.bold,\n               italic: textConf.italic,\n\n                    'x':centerx,\n                    'y':centery,\n                    'text':typeof prop.scaleMin === 'number' ?\n                               RGraph.numberFormat({\n                                   object:    this,\n                                   number:    Number(prop.scaleMin).toFixed(prop.scaleMin === 0 ? '0' : prop.scaleDecimals),\n                                   unitspre:  units_pre,\n                                   unitspost: units_post\n                               }) : '0',\n                    'valign':'center',\n                    'halign':'center',\n                    'bounding':true,\n                    'bounding.fill':color,\n                    'bounding.stroke':'rgba(0,0,0,0)',\n                    'tag': 'scale'\n                });\n            }\n        };\n\n\n\n\n\n\n\n\n        //\n        // Draws the circular labels that go around the charts\n        // \n        // @param labels array The labels that go around the chart\n        //\n        this.drawCircularLabels = function (context, labels, font, size, radius)\n        {\n            var variant     = prop.variant,\n                position    = prop.labelsPosition,\n                radius      = radius + 5 + prop.labelsOffset,\n                centerx     = this.centerx,\n                centery     = this.centery + (prop.variant.indexOf('3d') !== -1 ? prop.variantThreedDepth : 0),\n                labelsColor = prop.labelsColor || prop.textColor,\n                angles      = this.angles\n\n\n                \n                var textConf = RGraph.getTextConf({\n                    object: this,\n                    prefix: 'labels'\n                });\n    \n            for (var i=0; i<this.data.length; ++i) {\n                \n                if (typeof(variant) == 'string' && variant.indexOf('non-equi-angular') !== -1) {\n                    var a = Number(angles[i][0]) + ((angles[i][1] - angles[i][0]) / 2);\n                } else {\n                    var a = (RGraph.TWOPI / this.data.length) * (i + 1) - (RGraph.TWOPI / (this.data.length * 2));\n                    var a = a - RGraph.HALFPI + (prop.labelsPosition == 'edge' ? ((RGraph.TWOPI / this.data.length) / 2) : 0);\n                }\n    \n                var x = centerx + (Math.cos(a) * radius);\n                var y = centery + (Math.sin(a) * radius);\n    \n                // Horizontal alignment\n                if (x > centerx) {\n                    halign = 'left';\n                } else if (Math.round(x) == centerx) {\n                    halign = 'center';\n                } else {\n                    halign = 'right';\n                }\n    \n                RGraph.text({\n                    \n               object: this,\n\n                 font: textConf.font,\n                 size: textConf.size,\n                color: textConf.color,\n                 bold: textConf.bold,\n               italic: textConf.italic,\n\n                    x:      x,\n                    y:      y,\n                    text:   String(labels[i] || ''),\n                    halign: halign,\n                    valign: 'center',\n                    tag:    'labels'\n                });\n            }\n        };\n\n\n\n\n\n\n\n\n        //\n        // This function is for use with circular graph types, eg the Pie or Rose. Pass it your event object\n        // and it will pass you back the corresponding segment details as an array:\n        // \n        // [x, y, r, startAngle, endAngle]\n        // \n        // Angles are measured in degrees, and are measured from the \"east\" axis (just like the canvas).\n        // \n        // @param object e   Your event object\n        // @param object Options (OPTIONAL):\n        //                radius - whether to take into account\n        //                         the radius of the segment\n        //\n        this.getShape = function (e)\n        {\n            RGraph.fixEventObject(e);\n    \n            var angles  = this.angles;\n            var ret     = [];\n            var opt     = arguments[1] ? arguments[1] : {radius: true};\n    \n            //\n            // Go through all of the angles checking each one\n            //\n            for (var i=0; i<angles.length ; ++i) {\n    \n                var angleStart  = angles[i][0];\n                var angleEnd    = angles[i][1];\n                var radiusStart = opt.radius === false ? 0 : angles[i][2];\n                var radiusEnd   = opt.radius === false ? this.radius : angles[i][3];\n                var centerX     = angles[i][4];\n                var centerY     = angles[i][5];// - (prop.variant.indexOf('3d') !== -1 ? prop.variantThreedDepth : 0);\n                var mouseXY     = RGraph.getMouseXY(e);\n                var mouseX      = mouseXY[0] - centerX;\n                var mouseY      = mouseXY[1] - centerY;\n    \n                // New click testing (the 0.01 is there because Opera doesn't like 0 as the radius)\n                this.context.beginPath();\n                    this.context.arc(centerX, centerY, radiusStart ? radiusStart : 0.01, angleStart, angleEnd, false);\n                    this.context.arc(centerX, centerY, radiusEnd, angleEnd, angleStart, true);\n                this.context.closePath();\n    \n                // No stroke() or fill()\n    \n    \n                if (this.context.isPointInPath(mouseXY[0], mouseXY[1])) {\n\n                    angles[i][6] = i;\n                    \n                    if (RGraph.parseTooltipText) {\n                        var tooltip = RGraph.parseTooltipText(prop.tooltips, angles[i][6]);\n                    }\n    \n                    // Add the textual keys\n                    angles[i]['object']       = this;\n                    angles[i]['x']            = angles[i][4];\n                    angles[i]['y']            = angles[i][5];\n                    angles[i]['angle.start']  = angles[i][0];\n                    angles[i]['angle.end']    = angles[i][1];\n                    angles[i]['radius.start'] = angles[i][2];\n                    angles[i]['radius.end']   = angles[i][3];\n                    angles[i]['index']        = angles[i][6];\n                    angles[i]['tooltip']      = tooltip ? tooltip : null;\n\n                    return angles[i];\n                }\n            }\n\n            return null;\n        };\n\n\n\n\n\n\n\n\n        //\n        // Returns any exploded for a particular segment\n        //\n        this.getExploded = function (index, startAngle, endAngle, exploded)\n        {\n            var explodedx, explodedy;\n    \n            //\n            // Retrieve any exploded - the exploded can be an array of numbers or a single number\n            // (which is applied to all segments)\n            //\n            if (typeof(exploded) == 'object' && typeof(exploded[index]) == 'number') {\n                explodedx = Math.cos(((endAngle - startAngle) / 2) + startAngle) * exploded[index];\n                explodedy = Math.sin(((endAngle - startAngle) / 2) + startAngle) * exploded[index];\n            \n            } else if (typeof(exploded) == 'number') {\n                explodedx = Math.cos(((endAngle - startAngle) / 2) + startAngle) * exploded;\n                explodedy = Math.sin(((endAngle - startAngle) / 2) + startAngle) * exploded;\n    \n            } else {\n                explodedx = 0;\n                explodedy = 0;\n            }\n            \n            return [explodedx, explodedy];\n        };\n\n\n\n\n\n\n\n\n        //\n        // This function facilitates the installation of tooltip event listeners if\n        // tooltips are defined.\n        //\n        this.allowTooltips = function ()\n        {\n            // Preload any tooltip images that are used in the tooltips\n            RGraph.preLoadTooltipImages(this);\n    \n    \n            //\n            // This installs the window mousedown event listener that lears any\n            // highlight that may be visible.\n            //\n            RGraph.installWindowMousedownTooltipListener(this);\n    \n    \n            //\n            // This installs the canvas mousemove event listener. This function\n            // controls the pointer shape.\n            //\n            RGraph.installCanvasMousemoveTooltipListener(this);\n    \n    \n            //\n            // This installs the canvas mouseup event listener. This is the\n            // function that actually shows the appropriate tooltip (if any).\n            //\n            RGraph.installCanvasMouseupTooltipListener(this);\n        };\n\n\n\n\n\n\n\n\n        //\n        // Each object type has its own Highlight() function which highlights the appropriate shape\n        // \n        // @param object shape The shape to highlight\n        //\n        this.highlight = function (shape)\n        {\n            if (prop.tooltipsHighlight) {\n            \n            \n                if (typeof prop.highlightStyle === 'function'){\n                    (prop.highlightStyle)(shape);\n                    return;\n                }\n            \n            \n                // Add the new segment highlight\n                this.context.beginPath();\n                \n                    this.context.strokeStyle = prop.highlightStroke;\n                    this.context.fillStyle   = prop.highlightFill;\n                \n                    this.context.arc(\n                        shape['x'],\n                        shape['y'],//- (prop.variant.indexOf('3d') !== -1 ? prop.variantThreedDepth : 0),\n                        shape['radius.end'],\n                        shape['angle.start'],\n                        shape['angle.end'],\n                        false\n                    );\n\n                    if (shape['radius.start'] > 0) {\n                        this.context.arc(\n                            shape['x'],\n                            shape['y'],\n                            shape['radius.start'],\n                            shape['angle.end'],\n                            shape['angle.start'],\n                            true\n                        );\n                    } else {\n                        this.context.lineTo(\n                            shape['x'],\n                            shape['y']\n                        );\n                    }\n                this.context.closePath();\n        \n                this.context.stroke();\n                this.context.fill();\n            }\n        };\n\n\n\n\n\n\n\n\n        //\n        // The getObjectByXY() worker method. Don't call this call:\n        // \n        // RGraph.ObjectRegistry.getObjectByXY(e)\n        // \n        // @param object e The event object\n        //\n        this.getObjectByXY = function (e)\n        {\n            var mouseXY = RGraph.getMouseXY(e);\n    \n            // Work out the radius\n            var radius = RGraph.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);\n\n            // Account for the 3D stretching effect\n            if (prop.variant.indexOf('3d') !== -1) {\n                radius /= -1;\n            }\n\n            if (\n                   mouseXY[0] > (this.centerx - this.radius)\n                && mouseXY[0] < (this.centerx + this.radius)\n                && mouseXY[1] > (this.centery - this.radius)\n                && mouseXY[1] < (this.centery + this.radius)\n                && radius <= this.radius\n                ) {\n    \n                return this;\n            }\n        };\n\n\n\n\n\n\n\n\n        //\n        // This method gives you the relevant radius for a particular value\n        // \n        // @param number value The relevant value to get the radius for\n        //\n        this.getRadius = function (value)\n        {\n            // Range checking (the Rose minimum is always 0)\n            if (value < 0 || value > this.max) {\n                return null;\n            }\n            \n            var r = (value / this.max) * this.radius;\n            \n            return r;\n        };\n\n\n\n\n\n\n\n\n        //\n        // This allows for easy specification of gradients\n        //\n        this.parseColors = function ()\n        {\n            // Save the original colors so that they can be restored when the canvas is reset\n            if (this.original_colors.length === 0) {\n                this.original_colors.colors          = RGraph.arrayClone(prop.colors);\n                this.original_colors.keyColors       = RGraph.arrayClone(prop.keyColors);\n                this.original_colors.highlightStroke = RGraph.arrayClone(prop.highlightStroke);\n                this.original_colors.highlightFill   = RGraph.arrayClone(prop.highlightFill);\n            }\n\n\n            for (var i=0; i<prop.colors.length; ++i) {\n                prop.colors[i] = this.parseSingleColorForGradient(prop.colors[i]);\n            }\n    \n            //\n            // Key colors\n            //\n            if (!RGraph.isNull(prop.keyColors)) {\n                for (var i=0; i<prop.keyColors.length; ++i) {\n                    prop.keyColors[i] = this.parseSingleColorForGradient(prop.keyColors[i]);\n                }\n            }\n\n            prop.highlightFill           = this.parseSingleColorForGradient(prop.highlightFill);\n            prop.highlightStroke         = this.parseSingleColorForGradient(prop.highlightStroke);\n            prop.segmentHighlightStroke = this.parseSingleColorForGradient(prop.segmentHighlightStroke);\n            prop.segmentHighlightFill   = this.parseSingleColorForGradient(prop.segmentHighlightFill);\n        };\n\n\n\n\n\n\n\n\n        //\n        // Use this function to reset the object to the post-constructor state. Eg reset colors if\n        // need be etc\n        //\n        this.reset = function ()\n        {\n        };\n\n\n\n\n\n\n\n\n        //\n        // This parses a single color value\n        //\n        this.parseSingleColorForGradient = function (color)\n        {\n            if (!color || typeof(color) != 'string') {\n                return color;\n            }\n    \n            if (color.match(/^gradient\\((.*)\\)$/i)) {\n\n                // Allow for JSON gradients\n                if (color.match(/^gradient\\(({.*})\\)$/i)) {\n                    return RGraph.parseJSONGradient({object: this, def: RegExp.$1});\n                }\n\n                var parts = RegExp.$1.split(':');\n    \n                // Create the gradient\n                //var grad = context.createLinearGradient(0,0,canvas.width,0);\n                var grad = this.context.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);\n    \n                var diff = 1 / (parts.length - 1);\n    \n                grad.addColorStop(0, RGraph.trim(parts[0]));\n    \n                for (var j=1; j<parts.length; ++j) {\n                    grad.addColorStop(j * diff, RGraph.trim(parts[j]));\n                }\n            }\n\n            return grad ? grad : color;\n        };\n\n\n\n\n\n\n\n\n        //\n        // This function handles highlighting an entire data-series for the interactive\n        // key\n        // \n        // @param int index The index of the data series to be highlighted\n        //\n        this.interactiveKeyHighlight = function (index)\n        {\n            var segments = this.angles2;\n            \n            for (var i=0; i<this.angles2.length; i+=1) {\n                this.context.beginPath();\n                    this.context.lineWidth = 2;\n                    this.context.fillStyle = prop.keyInteractiveHighlightChartFill;\n                    this.context.strokeStyle = prop.keyInteractiveHighlightChartStroke;\n                    this.context.arc(segments[i][index][4], segments[i][index][5], segments[i][index][2], segments[i][index][0], segments[i][index][1], false);\n                    this.context.arc(segments[i][index][4], segments[i][index][5], segments[i][index][3], segments[i][index][1], segments[i][index][0], true);\n                this.context.closePath();\n                this.context.fill();\n                this.context.stroke();\n            }\n\n            return;\n        };\n\n\n\n\n\n\n\n\n        //\n        // Using a function to add events makes it easier to facilitate method chaining\n        // \n        // @param string   type The type of even to add\n        // @param function func \n        //\n        this.on = function (type, func)\n        {\n            if (type.substr(0,2) !== 'on') {\n                type = 'on' + type;\n            }\n            \n            if (typeof this[type] !== 'function') {\n                this[type] = func;\n            } else {\n                RGraph.addCustomEventListener(this, type, func);\n            }\n    \n            return this;\n        };\n\n\n\n\n\n\n\n\n        //\n        // This function runs once only\n        // (put at the end of the file (before any effects))\n        //\n        this.firstDrawFunc = function ()\n        {\n        };\n\n\n\n\n\n\n\n\n        //\n        // Rose chart explode\n        // \n        // Explodes the Rose chart - gradually incrementing the size of the explode property\n        // \n        // @param object     Optional options for the effect. You can pass in frames here - such as:\n        //                   myRose.roundRobin({frames: 60}; function () {alert('Done!');})\n        // @param function   A callback function which is called when the effect is finished\n        //\n        this.explode = function ()\n        {\n            var obj         = this;\n            var opt         = arguments[0] || {};\n            var callback    = arguments[1] || function (){};\n            var frames      = opt.frames ? opt.frames : 30;\n            var frame       = 0;\n            var explodedMax = Math.max(this.canvas.width, this.canvas.height);\n            var exploded    = Number(this.get('exploded'));\n    \n    \n    \n    \n            function iterator ()\n            {\n                exploded =  (frame / frames) * explodedMax;\n\n                // Set the new value\n                obj.set('exploded', exploded);\n    \n                RGraph.clear(obj.canvas);\n                RGraph.redrawCanvas(obj.canvas);\n    \n                if (frame++ < frames) {\n                    RGraph.Effects.updateCanvas(iterator);\n                } else  {\n                    callback(obj);\n                }\n            }\n\n\n\n\n            iterator();\n            \n            return this;\n        };\n\n\n\n\n\n\n\n\n        //\n        // RoundRobin\n        // \n        // This effect is similar to the Pie chart RoundRobin effect\n        // \n        // @param object     Optional options for the effect. You can pass in frames here - such as:\n        //                   myRose.roundRobin({frames: 60}; function () {alert('Done!');})\n        // @param function   A callback function which is called when the effect is finished\n        //\n        this.roundRobin = function ()\n        {\n            var obj             = this;\n            var opt             = arguments[0] || {}\n            var frames          = opt.frames || 30;\n            var frame           = 0;\n            var original_margin = prop.margin;\n            var margin          = (360 / this.data.length) / 2;\n            var callback        = arguments[1] || function () {};\n    \n            this.set('margin', margin);\n            this.set('animationRoundrobinFactor', 0);\n    \n            function iterator ()\n            {\n                RGraph.clear(obj.canvas);\n                RGraph.redrawCanvas(obj.canvas);\n\n                if (frame++ < frames) {\n                    obj.set('animationRoundrobinFactor', frame / frames);\n                    obj.set('margin', (frame / frames) * original_margin);\n                    RGraph.Effects.updateCanvas(iterator);\n                } else {\n                    obj.set('animationRoundrobinFactor', 1);\n                    obj.set('margin', original_margin);\n\n                    callback(obj);\n                }\n            }\n            \n            iterator();\n            \n            return this;\n        };\n\n\n\n\n\n\n\n\n        //\n        // Rose chart implode\n        // \n        // Implodes the Rose chart - gradually decreasing the size of the explode property. It starts at the largest of\n        // the canvas width./height\n        // \n        // @param object     Optional options for the effect. You can pass in frames here - such as:\n        //                   myRose.implode({frames: 60}; function () {alert('Done!');})\n        // @param function   A callback function which is called when the effect is finished\n        //\n        this.implode = function ()\n        {\n            var obj         = this;\n            var opt         = arguments[0] || {};\n            var callback    = arguments[1] || function (){};\n            var frames      = opt.frames || 30;\n            var frame       = 0;\n            var explodedMax = Math.max(this.canvas.width, this.canvas.height);\n            var exploded    = explodedMax;\n    \n    \n    \n            function iterator ()\n            {\n                exploded =  explodedMax - ((frame / frames) * explodedMax);\n\n                // Set the new value\n                obj.set('exploded', exploded);\n    \n                RGraph.clear(obj.canvas);\n                RGraph.redrawCanvas(obj.canvas);\n\n                if (frame++ < frames) {\n                    RGraph.Effects.updateCanvas(iterator);\n                } else {\n                    RGraph.clear(obj.canvas);\n                    RGraph.redrawCanvas(obj.canvas);\n                    callback(obj);\n                }\n            }\n            \n            iterator();\n\n            return this;\n        };\n\n\n\n\n\n\n\n\n        //\n        // Rose chart Grow\n        // \n        // This effect gradually increases the size of the Rose chart\n        // \n        // @param object     Optional options for the effect. You can pass in frames here - such as:\n        //                   myRose.grow({frames: 60}; function () {alert('Done!');})\n        // @param function   A callback function which is called when the effect is finished\n        //\n        this.grow = function ()\n        {\n            var obj      = this;\n            var opt      = arguments[0] || {};\n            var callback = arguments[1] || function (){};\n            var frames   = opt.frames || 30;\n            var frame    = 0;\n\n            function iterator ()\n            {\n                obj.set('animationGrowMultiplier', frame / frames);\n    \n                RGraph.clear(obj.canvas);\n                RGraph.redrawCanvas(obj.canvas);\n\n                if (frame < frames) {\n                    frame++;\n                    RGraph.Effects.updateCanvas(iterator);\n                } else {\n                    callback(obj);\n                }\n            }\n            \n            iterator();\n\n            return this;\n        };\n\n\n\n\n\n\n\n\n        //\n        // Register this object\n        //\n        RGraph.register(this);\n\n\n\n\n\n\n\n\n       //\n        // This is the 'end' of the constructor so if the first argument\n        // contains configuration data - handle that.\n        //\n        RGraph.parseObjectStyleConfig(this, conf.options);\n    };\n\n//# sourceURL=webpack:///../vendor/RGraph.rose.js?");

/***/ }),

/***/ "../vendor/RGraph.rscatter.js":
/*!************************************!*\
  !*** ../vendor/RGraph.rscatter.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// version: 2019-10-11\n    // o--------------------------------------------------------------------------------o\n    // | This file is part of the RGraph package - you can learn more at:               |\n    // |                                                                                |\n    // |                         https://www.rgraph.net                                 |\n    // |                                                                                |\n    // | RGraph is licensed under the Open Source MIT license. That means that it's     |\n    // | totally free to use and there are no restrictions on what you can do with it!  |\n    // o--------------------------------------------------------------------------------o\n\n    RGraph = window.RGraph || {isRGraph: true};\n\n    //\n    // The chart constuctor\n    //\n    RGraph.RScatter =\n    RGraph.Rscatter = function (conf)\n    {\n        this.data = new Array(conf.data.length);\n\n       // Store the data set(s)\n        this.data = RGraph.arrayClone(conf.data);\n\n\n        // Account for just one dataset being given\n        if (typeof conf.data === 'object' && typeof conf.data[0] === 'object' && typeof conf.data[0][0] === 'number') {\n            var tmp = RGraph.arrayClone(conf.data);\n            conf.data = new Array();\n            conf.data[0] = RGraph.arrayClone(tmp);\n            \n            this.data = RGraph.arrayClone(conf.data);\n        }\n\n\n\n\n\n\n        this.id                = conf.id\n        this.canvas            = document.getElementById(this.id)\n        this.context           = this.canvas.getContext ? this.canvas.getContext(\"2d\") : null;\n        this.canvas.__object__ = this;\n        this.type              = 'rscatter';\n        this.hasTooltips       = false;\n        this.isRGraph          = true;\n        this.uid               = RGraph.createUID();\n        this.canvas.uid        = this.canvas.uid ? this.canvas.uid : RGraph.createUID();\n        this.colorsParsed      = false;\n        this.coordsText        = [];\n        this.original_colors   = [];\n        this.firstDraw         = true; // After the first draw this will be false\n\n\n\n\n\n\n        this.centerx = 0;\n        this.centery = 0;\n        this.radius  = 0;\n        this.max     = 0;\n\n        // Convert all of the data pieces to numbers\n        for (var i=0; i<this.data.length; ++i) {\n            for (var j=0; j<this.data[i].length; ++j) {\n                if (typeof this.data[i][j][0] === 'string') {\n                    this.data[i][j][0] = parseFloat(this.data[i][j][0]);\n                }\n\n                if (typeof this.data[i][j][1] === 'string') {\n                    this.data[i][j][1] = parseFloat(this.data[i][j][1]);\n                }\n            }\n        }\n\n\n        this.properties =\n        {\n            backgroundColor:                        'transparent',\n            backgroundGrid:                         true,\n            backgroundGridRadials:                  true,\n            backgroundGridRadialsCount:             null,\n            backgroundGridCircles:                  true,\n            backgroundGridCirclesCount:             null,\n            backgroundGridLinewidth:                1,\n            backgroundGridColor:                    '#ccc',\n\n            centerx:                                null,\n            centery:                                null,\n            radius:                                 null,\n\n            colors:                                 [], // This is used internally for the key\n            colorsDefault:                          'black',\n\n            marginLeft:                             25,\n            marginRight:                            25,\n            marginTop:                              25,\n            marginBottom:                           25,\n\n            title:                                  '',\n            titleBackground:                        null,\n            titleHpos:                              null,\n            titleVpos:                              null,\n            titleBold:                              null,\n            titleFont:                              null,\n            titleSize:                              null,\n            titleItalic:                            null,\n            titleColor:                             null,\n            titleX:                                 null,\n            titleY:                                 null,\n            titleHalign:                            null,\n            titleValign:                            null,\n\n            labels:                                 null,\n            labelsColor:                            null,\n            labelsFont:                             null,\n            labelsSize:                             null,\n            labelsItalic:                           null,\n            labelsBold:                             null,\n            labelsAxes:                             'n',\n            labelsAxesBackground:                   'rgba(255,255,255,0.7)',\n            labelsAxesCount:                        5,\n            labelsAxesFont:                         null,\n            labelsAxesSize:                         null,\n            labelsAxesColor:                        null,\n            labelsAxesBold:                         null,\n            labelsAxesItalic:                       null,\n\n            textColor:                              'black',\n            textFont:                               'Arial, Verdana, sans-serif',\n            textSize:                               12,\n            textBold:                               false,\n            textItalic:                             false,\n            textAccessible:                         true,\n            textAccessibleOverflow:                 'visible',\n            textAccessiblePointerevents:            false,\n\n            key:                                    null,\n            keyBackground:                          'white',\n            keyPosition:                            'graph',\n            keyHalign:                              'right',\n            keyShadow:                              false,\n            keyShadowColor:                         '#666',\n            keyShadowBlur:                          3,\n            keyShadowOffsetx:                       2,\n            keyShadowOffsety:                       2,\n            keyPositionGutterBoxed:                 false,\n            keyPositionX:                           null,\n            keyPositionY:                           null,\n            keyColorShape:                          'square',\n            keyRounded:                             true,\n            keyLinewidth:                           1,\n            keyColors:                              null,\n            keyInteractive:                         false,\n            keyInteractiveHighlightChartFill:       'rgba(255,0,0,0.9)',\n            keyInteractiveHighlightLabel:           'rgba(255,0,0,0.2)',\n            keyLabelsColor:                         null,\n            keyLabelsFont:                          null,\n            keyLabelsSize:                          null,\n            keyLabelsBold:                          null,\n            keyLabelsItalic:                        null,\n            keyLabelsOffsetx:                       0,\n            keyLabelsOffsety:                       0,\n\n            contextmenu:                            null,\n\n            tooltips:                               null,\n            tooltipsEvent:                          'onmousemove',\n            tooltipsEffect:                         'fade',\n            tooltipsCssClass:                       'RGraph_tooltip',\n            tooltipsHighlight:                      true,\n            tooltipsHotspot:                        3,\n            tooltipsCoordsPage:                     false,\n\n            annotatable:                            false,\n            annotatableColor:                       'black',\n            annotatableLinewidth:                   1,\n\n            resizable:                              false,\n            resizableHandleBackground:              null,\n\n            scaleMax:                               null,\n            scaleMin:                               0, // TODO Not fully implemented\n            scaleDecimals:                          null,\n            scalePoint:                             '.',\n            scaleThousand:                          ',',\n            scaleRound:                             false,\n            scaleZerostart:                         true,\n            scaleUnitsPre:                          '',\n            scaleUnitsPost:                         '',\n\n            tickmarks:                              'cross',\n            tickmarksSize:                          3,\n\n            axesColor:                              'transparent',\n\n            eventsMousemove:                        null,\n            eventsClick:                            null,\n\n            highlightStroke:                        'transparent',\n            highlightFill:                          'rgba(255,255,255,0.7)',\n            highlightPointRadius:                   3,\n\n            segmentHighlight:                       false,\n            segmentHighlightCount:                  null,\n            segmentHighlightFill:                   'rgba(0,255,0,0.5)',\n            segmentHighlightStroke:                 'rgba(0,0,0,0)',\n\n            line:                                   false,\n            lineClose:                              false,\n            lineLinewidth:                          1,\n            lineColors:                             ['black'],\n            lineShadow:                             false,\n            lineShadowColor:                        'black',\n            lineShadowBlur:                         2,\n            lineShadowOffsetx:                      3,\n            lineShadowOffsety:                      3,\n\n            clearto:                                'rgba(0,0,0,0)'\n        }\n        \n\n\n\n        //\n        // Create the $ objects so that functions can be added to them\n        //\n        for (var i=0,idx=0; i<this.data.length; ++i) {\n            for (var j=0,len=this.data[i].length; j<len; j+=1,idx+=1) {\n                this['$' + idx] = {}\n            }\n        }\n\n\n\n\n\n        //\n        // Translate half a pixel for antialiasing purposes - but only if it hasn't beeen\n        // done already\n        //\n        if (!this.canvas.__rgraph_aa_translated__) {\n            this.context.translate(0.5,0.5);\n            \n            this.canvas.__rgraph_aa_translated__ = true;\n        }\n\n\n\n        // Short variable names\n        var prop = this.properties,\n            path = RGraph.path;\n        \n        \n        \n        //\n        // \"Decorate\" the object with the generic effects if the effects library has been included\n        //\n        if (RGraph.Effects && typeof RGraph.Effects.decorate === 'function') {\n            RGraph.Effects.decorate(this);\n        }\n        \n        \n        \n        // Add the reponsive method. This method resides in the common file.\n        this.responsive = RGraph.responsive;\n\n\n\n\n\n\n\n\n        //\n        // A simple setter\n        // \n        // @param string name  The name of the property to set\n        // @param string value The value of the property\n        //\n        this.set = function (name)\n        {\n            var value = typeof arguments[1] === 'undefined' ? null : arguments[1];\n\n            // the number of arguments is only one and it's an\n            // object - parse it for configuration data and return.\n            if (arguments.length === 1 && typeof arguments[0] === 'object') {\n                for (i in arguments[0]) {\n                    if (typeof i === 'string') {\n                        this.set(i, arguments[0][i]);\n                    }\n                }\n\n                return this;\n            }\n\n            prop[name] = value;\n\n            return this;\n        };\n\n\n\n\n\n\n\n\n        //\n        // A simple getter\n        // \n        // @param string name The name of the property to get\n        //\n        this.get = function (name)\n        {\n            return prop[name];\n        };\n\n\n\n\n\n\n\n\n        //\n        // This method draws the rose chart\n        //\n        this.draw = function ()\n        {\n            //\n            // Fire the onbeforedraw event\n            //\n            RGraph.fireCustomEvent(this, 'onbeforedraw');\n\n\n\n            //\n            // Make the margins easy ro access\n            //            \n            this.marginLeft   = prop.marginLeft;\n            this.marginRight  = prop.marginRight;\n            this.marginTop    = prop.marginTop;\n            this.marginBottom = prop.marginBottom;\n    \n            // Calculate the radius\n            this.radius  = (Math.min(this.canvas.width - this.marginLeft - this.marginRight, this.canvas.height - this.marginTop - this.marginBottom) / 2);\n            this.centerx = ((this.canvas.width - this.marginLeft - this.marginRight) / 2) + this.marginLeft;\n            this.centery = ((this.canvas.height - this.marginTop - this.marginBottom) / 2) + this.marginTop;\n            this.coords  = [];\n            this.coords2 = [];\n\n\n\n            //\n            // Stop this growing uncontrollably\n            //\n            this.coordsText = [];\n\n\n\n\n            //\n            // If there's a user specified radius/centerx/centery, use them\n            //\n            if (typeof(prop.centerx) == 'number') this.centerx = prop.centerx;\n            if (typeof(prop.centery) == 'number') this.centery = prop.centery;\n            if (typeof(prop.radius)  == 'number') this.radius  = prop.radius;\n    \n    \n    \n            //\n            // Parse the colors for gradients. Its down here so that the center X/Y can be used\n            //\n            if (!this.colorsParsed) {\n    \n                this.parseColors();\n    \n                // Don't want to do this again\n                this.colorsParsed = true;\n            }\n    \n    \n            //\n            // Work out the scale\n            //\n            var max = prop.scaleMax;\n            var min = prop.scaleMin;\n            \n            if (typeof(max) == 'number') {\n                this.max    = max;\n                this.scale2 = RGraph.getScale({object: this, options: {\n                    'scale.max':          max,\n                    'scale.min':          min,\n                    'scale.strict':       true,\n                    'scale.decimals':     Number(prop.scaleDecimals),\n                    'scale.point':        prop.scalePoint,\n                    'scale.thousand':     prop.scaleThousand,\n                    'scale.round':        prop.scaleRound,\n                    'scale.units.pre':    prop.scaleUnitsPre,\n                    'scale.units.post':   prop.scaleUnitsPost,\n                    'scale.labels.count': prop.labelsAxesCount\n                }});\n            } else {\n    \n                for (var i=0; i<this.data.length; i+=1) {\n                    for (var j=0,len=this.data[i].length; j<len; j+=1) {\n                        this.max = Math.max(this.max, this.data[i][j][1]);\n                    }\n                }\n\n                this.min = 0;\n    \n                this.scale2 = RGraph.getScale({object: this, options: {\n                    'scale.max':          this.max,\n                    'scale.min':          0,\n                    'scale.decimals':     Number(prop.scaleDecimals),\n                    'scale.point':        prop.scalePoint,\n                    'scale.thousand':     prop.scaleThousand,\n                    'scale.round':        prop.scaleRound,\n                    'scale.units.pre':    prop.scaleUnitsPre,\n                    'scale.units.post':   prop.scaleUnitsPost,\n                    'scale.labels.count': prop.labelsAxesCount\n                }});\n                this.max = this.scale2.max;\n            }\n    \n            //\n            // Change the centerx marginally if the key is defined\n            //\n            if (prop.key && prop.key.length > 0 && prop.key.length >= 3) {\n                this.centerx = this.centerx - prop.marginRight + 5;\n            }\n\n            //\n            // Populate the colors array for the purposes of generating the key\n            //\n            if (typeof prop.key === 'object' && RGraph.isArray(prop.key) && prop.key[0]) {\n\n                // Reset the colors array\n                prop.colors = [];\n\n                for (var i=0; i<this.data.length; i+=1) {\n                    for (var j=0,len=this.data[i].length; j<len; j+=1) {\n                        if (typeof this.data[i][j][2] == 'string') {\n                            prop.colors.push(this.data[i][j][2]);\n                        }\n                    }\n                }\n            }\n\n    \n    \n    \n            //\n            // Populate the tooltips array\n            //\n            this.set('tooltips', []);\n\n            for (var i=0; i<this.data.length; i+=1) {\n                for (var j=0,len=this.data[i].length; j<len; j+=1) {\n                    prop.tooltips.push(this.data[i][j][3]);\n                }\n            }\n    \n    \n    \n            // This resets the chart drawing state\n            this.context.beginPath();\n    \n            this.drawBackground();\n            this.drawRscatter();\n            this.drawLabels();\n            \n    \n            //\n            // Draw the key\n            //\n            var key = prop.key;\n\n            if (key && key.length) {\n                RGraph.drawKey(this, prop.key, prop.colors);\n            }\n    \n    \n    \n    \n            //\n            // Setup the context menu if required\n            //\n            if (prop.contextmenu) {\n                RGraph.showContext(this);\n            }\n    \n    \n    \n            // Draw the title if any has been set\n            if (prop.title) {\n                RGraph.drawTitle(\n                    this,\n                    prop.title,\n                    this.centery - this.radius - 10,\n                    this.centerx,\n                    prop.titleSize ? prop.titleSize : prop.textSize + 2\n                );\n            }\n    \n            \n            //\n            // This function enables resizing\n            //\n            if (prop.resizable) {\n                RGraph.allowResizing(this);\n            }\n    \n    \n            //\n            // This installs the event listeners\n            //\n            RGraph.installEventListeners(this);\n\n\n\n\n\n\n            //\n            // Allow the segments to be highlighted\n            //\n            if (prop.segmentHighlight) {\n                RGraph.allowSegmentHighlight({\n                    object: this,\n\n                    // This is duplicated in the drawBackground function\n                    count:  typeof prop.segmentHighlightCount === 'number' ? prop.segmentHighlightCount : ((prop.backgroundGridDiagonalsCount ? prop.backgroundGridDiagonalsCount : (prop.labels ? prop.labels.length : 8))),\n\n                    fill:   prop.segmentHighlightFill,\n                    stroke: prop.segmentHighlightStroke\n                });\n            }\n\n\n\n\n            //\n            // Fire the onfirstdraw event\n            //\n            if (this.firstDraw) {\n                this.firstDraw = false;\n                RGraph.fireCustomEvent(this, 'onfirstdraw');\n                this.firstDrawFunc();\n            }\n\n\n\n\n            //\n            // Fire the RGraph ondraw event\n            //\n            RGraph.fireCustomEvent(this, 'ondraw');\n\n            return this;\n        };\n\n\n\n\n\n\n\n\n        //\n        // Used in chaining. Runs a function there and then - not waiting for\n        // the events to fire (eg the onbeforedraw event)\n        // \n        // @param function func The function to execute\n        //\n        this.exec = function (func)\n        {\n            func(this);\n            \n            return this;\n        };\n\n\n\n\n\n\n\n\n        //\n        // This method draws the rscatter charts background\n        //\n        this.drawBackground = function ()\n        {\n            // Draw the background color first\n            if (prop.backgroundColor != 'transparent') {\n                path({\n                  object: this,\n                    path: 'b a % % % % % % f %',\n                    args: [\n                        this.centerx, this.centery, this.radius, 0, 2 * Math.PI, -1,\n                        prop.backgroundColor\n                    ]\n                });\n            }\n\n\n            var gridEnabled  = prop.backgroundGrid;\n\n\n            if (gridEnabled) {\n                \n                this.context.lineWidth = prop.backgroundGridLinewidth;\n        \n        \n                // Draw the background grey circles\n                if (prop.backgroundGridCircles) {\n\n                    this.context.strokeStyle = prop.backgroundGridColor;\n                    this.context.beginPath();\n                    \n                    if (RGraph.isNull(prop.backgroundGridCirclesCount)) {\n                        prop.backgroundGridCirclesCount = prop.labelsAxesCount;\n                    }\n\n                    // Radius must be greater than 0 for Opera to work\n                    \n                    var r = this.radius / prop.backgroundGridCirclesCount;\n\n                    for (var i=0,len=this.radius; i<=len; i+=r) {\n                \n                        // Radius must be greater than 0 for Opera to work\n                        this.context.moveTo(this.centerx + i, this.centery);\n                        this.context.arc(\n                            this.centerx,\n                            this.centery,\n                            i,\n                            0,\n                            RGraph.TWOPI,\n                            0\n                        );\n                    }\n                    this.context.stroke();\n                }\n        \n        \n        \n        \n        \n        \n        \n                // Draw the background lines that go from the center outwards\n                if (prop.backgroundGridRadials) {\n\n                    this.context.strokeStyle = prop.backgroundGridColor;\n                \n                    this.context.beginPath();\n                    \n                    // This is duplicated in the allowSegmentHighlight call\n                    if (typeof prop.backgroundGridRadialsCount === 'number') {\n                        var inc = 360 / prop.backgroundGridRadialsCount;\n                    } else if (prop.labels && prop.labels.length) {\n                        var inc = 360 / prop.labels.length;\n                    } else {\n                        var inc = 45; //360 / 8\n                    }\n\n\n                    for (var i=0; i<360; i+=inc) {\n                    \n                        // Radius must be greater than 0 for Opera to work\n                        this.context.arc(\n                            this.centerx,\n                            this.centery,\n                            this.radius,\n                            (i / (180 / RGraph.PI)) - RGraph.HALFPI,\n                            ((i + 0.01) / (180 / RGraph.PI)) - RGraph.HALFPI,\n                            0\n                        );\n                    \n                        this.context.lineTo(this.centerx, this.centery);\n                    }\n                    this.context.stroke();\n                }\n            }\n            \n            // Reset the linewidth\n            this.context.lineWidth = 1;\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n            this.context.beginPath();\n            this.context.strokeStyle = prop.axesColor;\n        \n            // Draw the X axis\n            this.context.moveTo(this.centerx - this.radius, Math.round(this.centery));\n            this.context.lineTo(this.centerx + this.radius, Math.round(this.centery));\n        \n            // Draw the X ends\n            this.context.moveTo(Math.round(this.centerx - this.radius), this.centery - 5);\n            this.context.lineTo(Math.round(this.centerx - this.radius), this.centery + 5);\n            this.context.moveTo(Math.round(this.centerx + this.radius), this.centery - 5);\n            this.context.lineTo(Math.round(this.centerx + this.radius), this.centery + 5);\n            \n            \n            var numticks = prop.labelsAxesCount;\n            \n            if (numticks) {\n                // Draw the X check marks\n                for (var i=(this.centerx - this.radius); i<(this.centerx + this.radius); i+=(this.radius / numticks)) {\n                    this.context.moveTo(Math.round(i),  this.centery - 3);\n                    this.context.lineTo(Math.round(i),  this.centery + 3);\n                }\n                \n                // Draw the Y check marks\n                for (var i=(this.centery - this.radius); i<(this.centery + this.radius); i+=(this.radius / numticks)) {\n                    this.context.moveTo(this.centerx - 3, Math.round(i));\n                    this.context.lineTo(this.centerx + 3, Math.round(i));\n                }\n            }\n        \n            // Draw the Y axis\n            this.context.moveTo(Math.round(this.centerx), this.centery - this.radius);\n            this.context.lineTo(Math.round(this.centerx), this.centery + this.radius);\n        \n            // Draw the Y ends\n            if (prop.axesCaps) {\n                this.context.moveTo(this.centerx - 5, Math.round(this.centery - this.radius));\n                this.context.lineTo(this.centerx + 5, Math.round(this.centery - this.radius));\n\n                this.context.moveTo(this.centerx - 5, Math.round(this.centery + this.radius));\n                this.context.lineTo(this.centerx + 5, Math.round(this.centery + this.radius));\n            }\n            \n            // Stroke it\n            this.context.closePath();\n            this.context.stroke();\n        };\n\n\n\n\n\n\n\n\n        //\n        // This method draws a set of data on the graph\n        //\n        this.drawRscatter = function ()\n        {\n            for (var dataset=0; dataset<this.data.length; dataset+=1) {\n\n                var data = this.data[dataset];\n\n                // Don't do this\n                // this.coords = [];\n\n                this.coords2[dataset] = [];\n\n                var drawPoints = function (obj)\n                {\n                    for (var i=0; i<data.length; ++i) {\n\n                        var d1      = data[i][0],\n                            d2      = data[i][1],\n                            a       = d1 / (180 / RGraph.PI), // RADIANS\n                            r       = ( (d2 - prop.scaleMin) / (obj.scale2.max - obj.scale2.min) ) * obj.radius,\n                            x       = Math.sin(a) * r,\n                            y       = Math.cos(a) * r,\n                            color   = data[i][2] ? data[i][2] : prop.colorsDefault,\n                            tooltip = data[i][3] ? data[i][3] : null\n            \n                        if (tooltip && String(tooltip).length) {\n                            obj.hasTooltips = true;\n                        }\n            \n                        //\n                        // Account for the correct quadrant\n                        //\n                        x = x + obj.centerx;\n                        y = obj.centery - y;\n            \n            \n                        obj.drawTick(x, y, color);\n                        \n                        // Populate the coords array with the coordinates and the tooltip\n\n                        obj.coords.push([x, y, color, tooltip]);\n                        obj.coords2[dataset].push([x, y, color, tooltip]);\n                    }\n                }\n\n                drawPoints(this);\n\n                if (prop.line) {\n                    this.drawLine(dataset);\n                }\n            }\n        };\n\n\n\n\n\n\n\n\n        //\n        // Draws a connecting line through the points if requested\n        // \n        // @param object opt The options to the line\n        //\n        this.drawLine = function (idx)\n        {\n            var opt = {\n                dataset:        idx,\n                coords:        this.coords2[idx],\n                color:         prop.lineColors[idx],\n                shadow:        prop.lineShadow,\n                shadowColor:   prop.lineShadowColor,\n                shadowOffsetX: prop.lineShadowOffsetx,\n                shadowOffsetY: prop.lineShadowOffsety,\n                shadowBlur:    prop.lineShadowBlur,\n                linewidth:     prop.lineLinewidth\n            };\n\n            this.context.beginPath();\n\n            this.context.strokeStyle = this.parseSingleColorForGradient(opt.color);\n              this.context.lineWidth = typeof prop.lineLinewidth === 'object' ? prop.lineLinewidth[idx] : prop.lineLinewidth;\n                this.context.lineCap = 'round';\n\n            if (opt.shadow) {\n                RGraph.setShadow(\n                    this,\n                    opt.shadowColor,\n                    opt.shadowOffsetX,\n                    opt.shadowOffsetY,\n                    opt.shadowBlur\n                );\n            }\n\n            for (var i=0; i<this.coords2[idx].length; ++i) {\n                if (i === 0) {\n                    this.context.moveTo(this.coords2[idx][i][0], this.coords2[idx][i][1]);\n                    \n                    var startCoords = RGraph.arrayClone(this.coords2[idx]);\n\n                } else {\n                    this.context.lineTo(this.coords2[idx][i][0], this.coords2[idx][i][1]);\n                }\n            }\n            \n            // Draw the line back to the start?\n            if (\n                   (typeof prop.lineClose === 'boolean' && prop.lineClose)\n                || (typeof prop.lineClose === 'object' && prop.lineClose[idx])\n                ) {\n                this.context.lineTo(this.coords2[idx][0][0], this.coords2[idx][0][1]);\n            }\n            \n            this.context.stroke();\n            \n            RGraph.noShadow(this);\n        };\n\n\n\n\n\n\n\n\n        //\n        // Unsuprisingly, draws the labels\n        //\n        this.drawLabels = function ()\n        {\n            this.context.lineWidth = 1;\n            \n            // Default the color to black\n            this.context.fillStyle = 'black';\n            this.context.strokeStyle = 'black';\n            \n            var key        = prop.key;\n            var r          = this.radius;\n            var axesColor  = prop.axesColor;\n            var italic     = prop.textItalic;\n            var bold       = prop.textBold;\n            var color      = prop.textColor;\n            var font       = prop.textFont;\n            var size       = prop.textSize;\n            var axes       = prop.labelsAxes.toLowerCase();\n            var units_pre  = prop.scaleUnitsPre;\n            var units_post = prop.scaleUnitsPost;\n            var decimals   = prop.scaleDecimals;\n            var centerx    = this.centerx;\n            var centery    = this.centery;\n            \n            this.context.fillStyle = prop.textColor;\n    \n            // Draw any labels\n            if (typeof prop.labels == 'object' && prop.labels) {\n                this.drawCircularLabels(this.context, prop.labels, font , size, r);\n            }\n    \n\n            //\n            // If the axes are transparent - then the labels should have no offset,\n            // otherwise it defaults to true. Similarly the labels can or can't be\n            // centered if there's no axes\n            //\n            var offset   = 10;\n            var centered = false;\n\n            if (   axesColor === 'rgba(0,0,0,0)'\n                || axesColor === 'rgb(0,0,0)'\n                || axesColor === 'transparent') {\n                \n                offset = 0;\n                centered = true;\n            }\n\n\n                var textConf = RGraph.getTextConf({\n                    object: this,\n                    prefix: 'labelsAxes'\n                });\n\n    \n            // Draw the axis labels\n            for (var i=0,len=this.scale2.labels.length; i<len; ++i) {\n                if (axes.indexOf('n') > -1) RGraph.text({object: this,tag: 'scale',font: textConf.font,size: textConf.size,color: textConf.color,bold: textConf.bold,italic: textConf.italic,x:centerx - offset,y:centery - (r * ((i+1) / len)),text:this.scale2.labels[i],valign:'center',halign:centered ? 'center' : 'right',bounding: true, boundingFill: prop.labelsAxesBackground, boundingStroke: 'rgba(0,0,0,0)'});\n                if (axes.indexOf('s') > -1) RGraph.text({object: this,tag: 'scale',font: textConf.font,size: textConf.size,color: textConf.color,bold: textConf.bold,italic: textConf.italic,x:centerx - offset,y:centery + (r * ((i+1) / len)),text:this.scale2.labels[i],valign:'center',halign:centered ? 'center' : 'right',bounding: true, boundingFill: prop.labelsAxesBackground, boundingStroke: 'rgba(0,0,0,0)'});\n                if (axes.indexOf('e') > -1) RGraph.text({object: this,tag: 'scale',font: textConf.font,size: textConf.size,color: textConf.color,bold: textConf.bold,italic: textConf.italic,x:centerx + (r * ((i+1) / len)),y:centery + offset,text:this.scale2.labels[i],valign:centered ? 'center' : 'top',halign:'center',bounding: true, boundingFill: prop.labelsAxesBackground, boundingStroke: 'rgba(0,0,0,0)'});\n                if (axes.indexOf('w') > -1) RGraph.text({object: this,tag: 'scale',font: textConf.font,size: textConf.size,color: textConf.color,bold: textConf.bold,italic: textConf.italic,x:centerx - (r * ((i+1) / len)),y:centery + offset,text:this.scale2.labels[i],valign:centered ? 'center' : 'top',halign:'center',bounding: true, boundingFill: prop.labelsAxesBackground, boundingStroke: 'rgba(0,0,0,0)'});\n            }\n    \n            // Draw the center minimum value (but only if there's at least one axes labels stipulated)\n            if (prop.labelsAxes.length > 0 && prop.scaleZerostart) {\n                RGraph.text({\n\n                    object:         this,\n\n                    font:           textConf.font,\n                    size:           textConf.size,\n                    color:          textConf.color,\n                    bold:           textConf.bold,\n                    italic:         textConf.italic,\n\n                    x:              centerx,\n                    y:              centery,\n                    text:           RGraph.numberFormat({\n                                        object:    this,\n                                        number:    Number(this.scale2.min).toFixed(this.scale2.decimals),\n                                        unitspre:  this.scale2.units_pre,\n                                        unitspost: this.scale2.units_post\n                                    }),\n                    valign:         'center',\n                    halign:         'center',\n                    bounding:       true,\n                    boundingFill:   prop.labelsAxesBackground,\n                    boundingStroke: 'rgba(0,0,0,0)',\n                    tag:            'scale'\n                });\n            }\n        };\n\n\n\n\n\n\n\n\n        //\n        // Draws the circular labels that go around the charts\n        // \n        // @param labels array The labels that go around the chart\n        //\n        this.drawCircularLabels = function (context, labels, font_face, font_size, r)\n        {\n            var r = r + 10,\n                color = prop.labelsColor;\n    \n            for (var i=0; i<labels.length; ++i) {\n\n                var a = (360 / labels.length) * (i + 1) - (360 / (labels.length * 2));\n                var a = a - 90 + (prop.labelsPosition == 'edge' ? ((360 / labels.length) / 2) : 0);\n    \n                var x = Math.cos(a / (180/RGraph.PI) ) * r;\n                var y = Math.sin(a / (180/RGraph.PI)) * r;\n    \n                var textConf = RGraph.getTextConf({\n                    object: this,\n                    prefix: 'labels'\n                });\n\n\n                RGraph.text({\n                    \n                   object:  this,\n\n                     font:  textConf.font,\n                     size:  textConf.size,\n                    color:  textConf.color,\n                     bold:  textConf.bold,\n                   italic:  textConf.italic,\n\n                    x:      this.centerx + x,\n                    y:      this.centery + y,\n                    text:   String(labels[i]),\n                    valign: 'center',\n                    halign: ( (this.centerx + x) > this.centerx) ? 'left' : 'right',\n                    tag:    'labels'\n                });\n            }\n        };\n\n\n\n\n\n\n\n\n        //\n        // Draws a single tickmark\n        //\n        this.drawTick = function (x, y, color)\n        {\n            var tickmarks = prop.tickmarks;\n            var ticksize  = prop.tickmarksSize;\n    \n            this.context.strokeStyle = color;\n            this.context.fillStyle   = color;\n    \n            // Set the linewidth for the tickmark to 1\n            var prevLinewidth = this.context.lineWidth;\n            this.context.lineWidth = 1;\n    \n            // Cross\n            if (tickmarks == 'cross') {\n    \n                this.context.beginPath();\n                this.context.moveTo(x + ticksize, y + ticksize);\n                this.context.lineTo(x - ticksize, y - ticksize);\n                this.context.stroke();\n        \n                this.context.beginPath();\n                this.context.moveTo(x - ticksize, y + ticksize);\n                this.context.lineTo(x + ticksize, y - ticksize);\n                this.context.stroke();\n            \n            // Circle\n            } else if (tickmarks == 'circle') {\n    \n                this.context.beginPath();\n                this.context.arc(x, y, ticksize, 0, 6.2830, false);\n                this.context.fill();\n    \n            // Square\n            } else if (tickmarks == 'square') {\n    \n                this.context.beginPath();\n                this.context.fillRect(x - ticksize, y - ticksize, 2 * ticksize, 2 * ticksize);\n                this.context.fill();\n            \n            // Diamond shape tickmarks\n             } else if (tickmarks == 'diamond') {\n    \n                this.context.beginPath();\n                    this.context.moveTo(x, y - ticksize);\n                    this.context.lineTo(x + ticksize, y);\n                    this.context.lineTo(x, y + ticksize);\n                    this.context.lineTo(x - ticksize, y);\n                this.context.closePath();\n                this.context.fill();\n    \n            // Plus style tickmarks\n            } else if (tickmarks == 'plus') {\n            \n                this.context.lineWidth = 1;\n    \n                this.context.beginPath();\n                    this.context.moveTo(x, y - ticksize);\n                    this.context.lineTo(x, y + ticksize);\n                    this.context.moveTo(x - ticksize, y);\n                    this.context.lineTo(x + ticksize, y);\n                this.context.stroke();\n            }\n            \n            \n            this.context.lineWidth = prevLinewidth;\n        };\n\n\n\n\n\n\n\n\n        //\n        // This function makes it much easier to get the (if any) point that is currently being hovered over.\n        // \n        // @param object e The event object\n        //\n        this.getShape = function (e)\n        {\n            var mouseXY     = RGraph.getMouseXY(e);\n            var mouseX      = mouseXY[0];\n            var mouseY      = mouseXY[1];\n            var overHotspot = false;\n            var offset      = prop.tooltipsHotspot; // This is how far the hotspot extends\n    \n            for (var i=0,len=this.coords.length; i<len; ++i) {\n\n                var x       = this.coords[i][0];\n                var y       = this.coords[i][1];\n                var tooltip = this.coords[i][3];\n    \n                if (\n                    mouseX < (x + offset) &&\n                    mouseX > (x - offset) &&\n                    mouseY < (y + offset) &&\n                    mouseY > (y - offset)\n                   ) {\n\n                    var tooltip = RGraph.parseTooltipText(prop.tooltips, i);\n\n                    return {0:this,1:x,2:y,3:i,object:this, x:x, y:y, index:i, tooltip: tooltip};\n                }\n            }\n        };\n\n\n\n\n\n\n\n\n        //\n        // This function facilitates the installation of tooltip event listeners if\n        // tooltips are defined.\n        //\n        this.allowTooltips = function ()\n        {\n            // Preload any tooltip images that are used in the tooltips\n            RGraph.preLoadTooltipImages(this);\n\n    \n            //\n            // This installs the window mousedown event listener that lears any\n            // highlight that may be visible.\n            //\n            RGraph.installWindowMousedownTooltipListener(this);\n    \n    \n            //\n            // This installs the canvas mousemove event listener. This function\n            // controls the pointer shape.\n            //\n            RGraph.installCanvasMousemoveTooltipListener(this);\n    \n    \n            //\n            // This installs the canvas mouseup event listener. This is the\n            // function that actually shows the appropriate tooltip (if any).\n            //\n            RGraph.installCanvasMouseupTooltipListener(this);\n        };\n\n\n\n\n\n\n\n\n        //\n        // Each object type has its own Highlight() function which highlights the appropriate shape\n        // \n        // @param object shape The shape to highlight\n        //\n        this.highlight = function (shape)\n        {\n            if (typeof prop.highlightStyle === 'function') {\n                (prop.highlightStyle)(shape);\n            } else {\n                RGraph.Highlight.point(this, shape);\n            }\n        };\n\n\n\n\n\n\n\n\n        //\n        // The getObjectByXY() worker method. Don't call this call:\n        // \n        // RGraph.ObjectRegistry.getObjectByXY(e)\n        // \n        // @param object e The event object\n        //\n        this.getObjectByXY = function (e)\n        {\n            var mouseXY = RGraph.getMouseXY(e);\n            var mouseX  = mouseXY[0];\n            var mouseY  = mouseXY[1];\n            var centerx = this.centerx;\n            var centery = this.centery;\n            var radius  = this.radius;\n    \n            if (\n                   mouseX > (centerx - radius)\n                && mouseX < (centerx + radius)\n                && mouseY > (centery - radius)\n                && mouseY < (centery + radius)\n                ) {\n    \n                return this;\n            }\n        };\n\n\n\n\n\n\n\n\n        //\n        // This function returns the radius (ie the distance from the center) for a particular\n        // value.\n        // \n        // @param number value The value you want the radius for\n        //\n        this.getRadius = function (value)\n        {\n            var max = this.max;\n\n            if (value < 0 || value > max) {\n                return null;\n            }\n            \n            var r = (value / max) * this.radius;\n            \n            return r;\n        };\n\n\n\n\n\n\n\n\n        //\n        // This allows for easy specification of gradients\n        //\n        this.parseColors = function ()\n        {\n            // Save the original colors so that they can be restored when the canvas is reset\n            if (this.original_colors.length === 0) {\n                this.original_colors.data                   = RGraph.arrayClone(this.data);\n                this.original_colors.highlightStroke        = RGraph.arrayClone(prop.highlightStroke);\n                this.original_colors.highlightFill          = RGraph.arrayClone(prop.highlightFill);\n                this.original_colors.colorsDefault          = RGraph.arrayClone(prop.colorsDefault);\n                this.original_colors.backgroundGridColor    = RGraph.arrayClone(prop.backgroundGridColor);\n                this.original_colors.backgroundColor        = RGraph.arrayClone(prop.backgroundColor);\n                this.original_colors.segmentHighlightStroke = RGraph.arrayClone(prop.segmentHighlightStroke);\n                this.original_colors.segmentHighlightFill   = RGraph.arrayClone(prop.segmentHighlightFill);\n            }\n\n\n\n\n\n\n            // Go through the data\n            for (var i=0; i<this.data.length; i+=1) {\n                for (var j=0,len=this.data[i].length; j<len; j+=1) {\n                    this.data[i][j][2] = this.parseSingleColorForGradient(this.data[i][j][2]);\n                }\n            }\n    \n            prop.highlightStroke         = this.parseSingleColorForGradient(prop.highlightStroke);\n            prop.highlightFill           = this.parseSingleColorForGradient(prop.highlightFill);\n            prop.colorsDefault           = this.parseSingleColorForGradient(prop.colorsDefault);\n            prop.backgroundGridColor    = this.parseSingleColorForGradient(prop.backgroundGridColor);\n            prop.backgroundColor         = this.parseSingleColorForGradient(prop.backgroundColor);\n            prop.segmentHighlightStroke = this.parseSingleColorForGradient(prop.segmentHighlightStroke);\n            prop.segmentHighlightFill   = this.parseSingleColorForGradient(prop.segmentHighlightFill);\n        };\n\n\n\n\n\n\n\n\n        //\n        // Use this function to reset the object to the post-constructor state. Eg reset colors if\n        // need be etc\n        //\n        this.reset = function ()\n        {\n        };\n\n\n\n\n\n\n\n\n        //\n        // This parses a single color value\n        //\n        this.parseSingleColorForGradient = function (color)\n        {\n            if (!color || typeof color != 'string') {\n                return color;\n            }\n\n            if (color.match(/^gradient\\((.*)\\)$/i)) {\n\n                // Allow for JSON gradients\n                if (color.match(/^gradient\\(({.*})\\)$/i)) {\n                    return RGraph.parseJSONGradient({object: this, def: RegExp.$1});\n                }\n\n                var parts = RegExp.$1.split(':');\n    \n                // Create the gradient\n                var grad = this.context.createRadialGradient(this.centerx, this.centery, 0, this.centerx, this.centery, this.radius);\n    \n                var diff = 1 / (parts.length - 1);\n    \n                grad.addColorStop(0, RGraph.trim(parts[0]));\n    \n                for (var j=1; j<parts.length; ++j) {\n                    grad.addColorStop(j * diff, RGraph.trim(parts[j]));\n                }\n            }\n    \n            return grad ? grad : color;\n        };\n\n\n\n\n\n\n\n\n        //\n        // This function handles highlighting an entire data-series for the interactive\n        // key\n        // \n        // @param int index The index of the data series to be highlighted\n        //\n        this.interactiveKeyHighlight = function (index)\n        {\n            var obj = this;\n\n            if (this.coords2 && this.coords2[index] && this.coords2[index].length) {\n                this.coords2[index].forEach(function (value, idx, arr)\n                {\n                    obj.context.beginPath();\n                    obj.context.fillStyle = prop.keyInteractiveHighlightChartFill;\n                    obj.context.arc(value[0], value[1], prop.tickmarksSize + 2, 0, RGraph.TWOPI, false);\n                    obj.context.fill();\n                });\n            }\n        };\n\n\n\n\n\n\n\n\n        //\n        // Using a function to add events makes it easier to facilitate method chaining\n        // \n        // @param string   type The type of even to add\n        // @param function func \n        //\n        this.on = function (type, func)\n        {\n            if (type.substr(0,2) !== 'on') {\n                type = 'on' + type;\n            }\n            \n            if (typeof this[type] !== 'function') {\n                this[type] = func;\n            } else {\n                RGraph.addCustomEventListener(this, type, func);\n            }\n    \n            return this;\n        };\n\n\n\n\n\n\n\n\n        //\n        // This helps the Gantt reset colors when the reset function is called.\n        // It handles going through the data and resetting the colors.\n        //\n        this.resetColorsToOriginalValues = function ()\n        {\n            //\n            // Copy the original colors over for single-event-per-line data\n            //\n            for (var i=0,len=this.original_colors.data.length; i<len; ++i) {\n                for (var j=0,len2=this.original_colors.data[i].length; j<len2;++j) {\n                    this.data[i][j][2] = RGraph.arrayClone(this.original_colors.data[i][j][2]);\n                }\n            }\n        };\n\n\n\n\n\n\n\n\n        //\n        // This function runs once only\n        // (put at the end of the file (before any effects))\n        //\n        this.firstDrawFunc = function ()\n        {\n        };\n\n\n\n\n\n\n\n\n        //\n        // Register the object\n        //\n        RGraph.register(this);\n\n\n\n\n\n\n\n\n        //\n        // This is the 'end' of the constructor so if the first argument\n        // contains configuration data - handle that.\n        //\n        RGraph.parseObjectStyleConfig(this, conf.options);\n    };\n\n//# sourceURL=webpack:///../vendor/RGraph.rscatter.js?");

/***/ }),

/***/ "./abstract-layer-2d/index.js":
/*!************************************!*\
  !*** ./abstract-layer-2d/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n    component: component,\n    klass: AbstractLayer2D\n}\nvar AbstractLayer = __webpack_require__(/*! ../abstract-layer */ \"./abstract-layer/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar AbstractLayerComponent = AbstractLayer.component;\n\nfunction component(componentData) {\n    componentData.bindings = {\n        minY: \"<\",\n        maxY: \"<\",\n        minDrawY: \"<\",\n        maxDrawY: \"<\",\n        orthoLoga: \"<\",\n        autofit: \"<\",\n        ...componentData.bindings\n    }\n    return AbstractLayerComponent(componentData);\n}\nfunction AbstractLayer2D($timeout, $element, $scope) {\n    let self = this;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n\n    this.watchProperties = this.watchProperties.concat([\n        \"minY\",\n        \"maxY\",\n        \"minDrawY\",\n        \"maxDrawY\",\n        \"orthoLoga\",\n    ]);\n    this.twoDBindings = function() {\n        this.minY = this.minY || 0;\n        this.maxY = _.isFinite(this.maxY) ? this.maxY : 100;\n        this.minDrawY = this.minDrawY || this.minY;\n        this.maxDrawY = this.maxDrawY || this.maxY;\n    }\n\n    this.registerWatch(function() {\n        if (self.orthoLoga) {\n            if (self.minY <= 0) self.minY = 0.01;\n            if (self.maxY <= 0) self.maxY = 0.01;\n        }\n        self.getOrthoTransform(true);\n    });\n    /*this.twoDRegisterWatch = function() {\n        this.registerWatch(function() {\n            self.getOrthoTransform(true);\n            self.drawOptimized();\n        });\n    }\n    let superDoInit = this.doInit;\n    this.doInit = function() {\n        this.twoDRegisterWatch();\n        superDoInit.call(this);\n    }*/\n    this.orthoRange = function() {\n        let range;\n        switch (this.axisDirection) {\n            case 'right':\n            case 'left':\n                range = [this.contentHeight(), 0];break;\n            case 'up':\n            case 'down':\n                range = [0, this.contentWidth()];break;\n            default:\n                range = [this.contentHeight(), 0];\n        }\n        return range;\n    }\n    this.getOrthoTransform = function(update) {\n        if (!this._otransform || update) {\n            if (update) {\n                this.contentWidth(true);\n                this.contentHeight(true);\n            }\n            this._otransform = (this.orthoLoga?d3.scaleLog():d3.scaleLinear())\n                                .domain(this.orthoDomain())\n                                .range(this.orthoRange());\n        }\n        return this._otransform;\n    }\n    this.orthoDomain = function() {\n        return [this.minY, this.maxY];\n    }\n    // this.orthoRange = function() {\n    //     return [this.contentHeight(), 0];\n    // }\n    this.updateMaxY = function(newVal) {\n        this.maxY = newVal;\n        if (this.update['maxY']) \n            this.update['maxY'](newVal);\n    }\n    this.preDraw = function() {\n        if (self.autofit) {\n            self.doAutofit();\n        }\n    }\n    this.doAutofit = function() {\n        console.error('Abstract doAutofit');\n    }\n}\n\n\n//# sourceURL=webpack:///./abstract-layer-2d/index.js?");

/***/ }),

/***/ "./abstract-layer/index.js":
/*!*********************************!*\
  !*** ./abstract-layer/index.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n    component: component,\n    klass: AbstractLayer\n}\n__webpack_require__(/*! ./style.css */ \"./abstract-layer/style.css\");\nvar ResizeSensor = __webpack_require__(/*! resize-sensor */ \"../node_modules/resize-sensor/ResizeSensor.min.js\");\nif (window.ResizeObserver) {\n    // chrome only\n    ResizeSensor = resizeSensor;\n    function resizeSensor(element = document, callback = () => { }) {\n        if (element instanceof $) element = element[0];\n        this.element = element;\n        this.callback = () => setTimeout(callback);\n\n        this.resizeObserver = new ResizeObserver(this.callback)\n        this.resizeObserver.observe(this.element);\n        return this;\n    }\n    resizeSensor.prototype.detach = function () {\n        this.resizeObserver.unobserve(this.element);\n    }\n}\n\nvar debounce = __webpack_require__(/*! lodash */ \"../node_modules/lodash/lodash.js\").debounce;\nvar merge = __webpack_require__(/*! lodash */ \"../node_modules/lodash/lodash.js\").merge;\nfunction component(componentData) {\n    return {\n        controller: componentData.controller,\n        controllerAs: componentData.controllerAs || 'self',\n        template: componentData.template,\n        bindings: {\n            padding: '<',\n            hPadding: '<',\n            vPadding: '<',\n            lPadding: '<',\n            rPadding: '<',\n            tPadding: '<',\n            bPadding: '<',\n            minVal: '<',\n            maxVal: '<',\n            minDraw: '<',\n            maxDraw: '<',\n            getters: \"<\",\n            setters: \"<\",\n            loga: '<',\n            axisDirection: '<',\n            placement: '<',\n            getMinVal: '<',\n            getMaxVal: '<',\n            ...componentData.bindings\n        },\n        require: {\n            layerCollection: \"?^^layerCollection\"\n        }\n    }\n}\nfunction bindings(bindings) {\n    var defaultBindings = {\n        padding: '<',\n        hPadding: '<',\n        vPadding: '<',\n        lPadding: '<',\n        rPadding: '<',\n        tPadding: '<',\n        bPadding: '<',\n        minVal: '<',\n        maxVal: '<',\n        minDraw: '<',\n        maxDraw: '<',\n        getters: \"<\",\n        setters: \"<\",\n        loga: '<',\n        axisDirection: '<',\n        placement: '<',\n        params: '<'\n    }\n    return merge(defaultBindings,bindings);\n}\nfunction AbstractLayer($timeout, $element, $scope) {\n    let self = this;\n\n    this.leftPadding = function(){\n        return this.lPadding || this.hPadding || this.padding || (this.layerCollection || {}).lPadding || 0;\n    }\n    this.rightPadding = function(){\n        return this.rPadding || this.hPadding || this.padding || (this.layerCollection || {}).rPadding || 0;\n    }\n    this.topPadding = function() {\n        return this.tPadding || this.vPadding || this.padding || (this.layerCollection || {}).tPadding || 0;\n    }\n    this.bottomPadding = function() {\n        return this.bPadding || this.vPadding || this.padding || (this.layerCollection || {}).bPadding || 0;\n    }\n    this.paddingStr = function () {\n        return `${this.topPadding()}px ${this.rightPadding()}px ${this.bottomPadding()}px ${this.leftPadding()}px`\n    }\n    this.parentWidth = function() {\n        return $element.parent().width();\n    }\n    this.parentHeight = function() {\n        return $element.parent().height();\n    }\n    this.contentWidth = function(update) {\n        if (!this.width || update )\n            this.width = $element.find('svg,canvas').width();\n        return this.width;\n    }\n    this.contentHeight = function(update) {\n        if (!this.height || update )\n            this.height = $element.find('svg,canvas').height();\n        return this.height;\n    }\n    this.domain = function() {\n        return [this.minVal, this.maxVal];\n    }\n\n    this.range = function() {\n        let range;\n        switch (this.axisDirection) {\n            case 'right':\n                range = [0, this.contentWidth()];break;\n            case 'left':\n                range = [this.contentWidth(), 0];break;\n            case 'up':\n                range = [this.contentHeight(), 0];break;\n            case 'down':\n                range = [0, this.contentHeight()];break;\n            default:\n                range = [0, this.contentWidth()];\n        }\n        return range;\n    }\n    this.getTransform = function(update) {\n        if (!this._transform || update) {\n            if (update) {\n                this.contentWidth(true);\n                this.contentHeight(true);\n            }\n            this._transform = (this.loga?d3.scaleLog():d3.scaleLinear())\n                                .domain(this.domain())\n                                .range(this.range());\n        }\n        return this._transform;\n    }\n    this.defaultBindings = function(){\n        console.error(\"Abstract default bindings\");\n    }\n    this.drawOptimized = debounce(function () {\n        if ($scope.$$destroyed) return;\n        if (self.loga) {\n            if (self.minVal <= 0) self.minVal = 0.01;\n            if (self.maxVal <= 0) self.maxVal = 0.01;\n        } else {\n            //self.minVal = _.isFinite(self.originalMinVal) ? self.originalMinVal : self.minVal;\n            //self.maxVal = _.isFinite(self.originalMaxVal) ? self.originalMaxVal : self.maxVal;\n            self.minVal = self.getMinVal ? self.getMinVal() : self.minVal;\n            self.maxVal = self.getMaxVal ? self.getMaxVal() : self.maxVal;\n        }\n        for( let f of self.watchCallbacks) f();\n        self.getTransform(true);\n        self.preDraw();\n        self.draw();\n        self.postDraw();\n        if (!$scope.$$phase) $scope.$digest();\n    }, 300);\n    \n    this.watchCallbacks = [];\n    this.watchProperties = [\n        'minVal',\n        'maxVal',\n        'minDraw',\n        'maxDraw',\n        'loga',\n        'axisDirection',\n        'placement'\n    ]\n    this.registerWatch = function(callback) {\n        this.watchCallbacks.push(callback);\n    }\n    this.activateWatch = function() {\n        $scope.$watch(function() {\n            return self.watchProperties.map((prop) => (self[prop]));\n            //return [self.minVal, self.maxVal, self.loga, self.axisDirection];\n        }, function() {\n            // for( let f of self.watchCallbacks) f();\n            // self.getTransform(true);\n            //self.originalMinVal = self.minVal != 0.01 ? self.minVal : self.originalMinVal;\n            //self.originalMaxVal = self.maxVal != 0.01 ? self.maxVal : self.originalMaxVal;\n            self.drawOptimized();\n        }, true);\n        $scope.$on('jpanel-resized', function() {\n            self.drawOptimized();\n        });\n    }\n    this.doInit = function() {\n        this.update = {};\n        this.axisDirection = this.axisDirection || \"right\";\n        this.placement = this.placement || 0;\n\n        this.minVal = this.minVal || 0;\n        this.maxVal = _.isFinite(this.maxVal) ? this.maxVal : 100;\n        this.minDraw = this.minDraw || this.minVal;\n        this.maxDraw = this.maxDraw || this.maxVal;\n        this.defaultBindings();\n\n        let holder = $element.first();\n        new ResizeSensor(holder[0], function() {\n            // for( let f of self.watchCallbacks) f();\n            // self.getTransform(true);\n            self.drawOptimized();\n        });\n        if (this.layerCollection) {\n            // getters\n            for (let key of Object.keys(this.getters || {})) {\n                this.layerCollection.$scope.$on(this.getters[key], function(evt, value){\n                    evt.stopPropagation();\n                    evt.preventDefault();\n                    self._update = true;\n                    self[key] = value;\n                });\n            }\n            // setters\n            for (let key of Object.keys(this.setters || {})) {\n                this.update[key] = function(newVal) {\n                    self.layerCollection.$scope.$emit(self.setters[key], newVal);\n                }\n            }\n        }\n        holder.hide();\n        this.activateWatch();\n        this.getTransform(true);\n        this.preDraw();\n        this.draw();\n        this.postDraw();\n        holder.show();\n    }\n    this.preDraw = function(){\n    }\n    this.draw = function() {\n        console.error(\"Abstract draw\");\n    }\n    this.postDraw = function(){\n    }\n    this.onMouseMoveTooltip = function($event) {\n        if (this.layerCollection) this.layerCollection.tooltip(true, 'abc');\n    }\n    this.onMouseLeaveTooltip = function($event) {\n        if (this.layerCollection) this.layerCollection.tooltip(false);\n    }\n}\n\n\n//# sourceURL=webpack:///./abstract-layer/index.js?");

/***/ }),

/***/ "./abstract-layer/style.css":
/*!**********************************!*\
  !*** ./abstract-layer/style.css ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./style.css */ \"../node_modules/css-loader/dist/cjs.js!./abstract-layer/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./abstract-layer/style.css?");

/***/ }),

/***/ "./axis-layer/index.js":
/*!*****************************!*\
  !*** ./axis-layer/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = \"plot-toolkit\";\nconst name = \"axisLayer\";\nmodule.exports.name = name;\n\n__webpack_require__(/*! ./style.css */ \"./axis-layer/style.css\");\nvar AbstractLayer = __webpack_require__(/*! ../abstract-layer */ \"./abstract-layer/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar bindings = AbstractLayer.bindings;\nvar component = AbstractLayer.component;\n\nvar layerCollection = __webpack_require__(/*! ../layer-collection */ \"./layer-collection/index.js\");\nlet bestNumberFormat = __webpack_require__(/*! ../common */ \"./common.js\").bestNumberFormat;\nangular.module(moduleName).component(name, component({\n    controller: AxisLayerController, \n    template: __webpack_require__(/*! ./template.html */ \"./axis-layer/template.html\"),\n    bindings: {\n        precision: '<',\n        nTicks: '<',\n        grid: '<',\n        minorTicks: '<'\n    }\n}));\nfunction AxisLayerController($timeout, $element, $scope ) {\n    let self = this;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n\n    this.watchProperties = this.watchProperties.concat([\n        'precision',\n        'nTicks',\n        'grid',\n        'minorTicks'\n    ]);\n    this.tickValues = function() {\n        if (!this.loga) {\n            const step = (self.maxVal - self.minVal) / this.nTicks;\n            return d3.range(self.nTicks + 1).map((d, i) => self.minVal + i * step);\n            // let step = (Math.ceil(self.maxVal)- Math.floor(self.minVal))/this.nTicks;\n            // return d3.range(Math.floor(self.minVal), Math.ceil(self.maxVal), step);\n        }\n        else {\n            return genLogTickValues(_.min([self.minVal, self.maxVal]), _.max([self.minVal, self.maxVal]));\n        }\n    }\n    this.defaultBindings = function() {\n        this.grid = (this.grid === undefined)?1:this.grid;\n        this.nTicks = this.nTicks || 5;\n        this.minorTicks = this.minorTicks || 2;\n        this.precision = isNaN(this.precision) ? 1 : this.precision;\n    }\n    this.$onInit = function() {\n        this.doInit();\n        /*\n        $scope.$watch(function() {\n            return [self.maxVal, self.minVal];\n        }, function() {\n            console.log('redraw');\n            self.getTransform(true);    \n            self.drawOptimized();\n        }, true);\n        */\n    }\n    this._translate = function() {\n        switch (this.axisDirection) {\n            case 'right':\n            case 'left':\n                return this.placement?`translate(0, ${this.contentHeight()}px)`:\"translate(0,0)\";\n            case 'up':\n            case 'down':\n                return this.placement?`translate(${this.contentWidth()}px, 0)`:\"translate(0,0)\";\n        }\n        return \"translate(0,0)\";\n    }\n    this._tickSize = function() {\n        switch (this.axisDirection) {\n            case 'right':\n            case 'left':\n                return this.grid?-this.contentHeight():0;\n            case 'up':\n            case 'down':\n                return this.grid?-this.contentWidth():0;\n        }\n        return -height;\n    }\n    this._axisFunc = function() {\n        switch (this.axisDirection) {\n            case 'right':\n            case 'left':\n                return this.placement?d3.axisBottom:d3.axisTop;\n            case 'up':\n            case 'down':\n                return this.placement?d3.axisRight:d3.axisLeft;\n        }\n        return d3.axisBottom;\n    }\n    this.draw = draw;\n    function draw() {\n        // console.log('DRAW', self.axisDirection, self.maxVal);\n        let svg = $element.find('svg');\n        let transform = self.getTransform();\n\n        const tickValues = self.tickValues();\n        let axisFunc = self._axisFunc()(transform)\n            .tickValues(tickValues)\n            .tickFormat(function(value, i) {\n                if (self.loga) \n                    return Number.isInteger(Math.log10(value))?value:'';\n                if (i === tickValues.length - 1) return parseFloat(value.toFixed(self.precision));\n                return i % self.minorTicks ? '': parseFloat(value.toFixed(self.precision));\n            })\n            .tickPadding(10)\n            .tickSize(self._tickSize());\n        d3.select(svg[0]).select('g.layer')\n            .style('transform', self._translate())\n            .call(axisFunc);\n        d3.select(svg[0]).select('g.layer').selectAll(\"g\")\n            .classed('minor', false)\n            .filter((value, i) => {\n                if (self.loga) \n                    return !Number.isInteger(Math.log10(value));\n                if (i === tickValues.length - 1) return false;\n                return i % self.minorTicks;\n            })\n            .classed('minor', true);\n    }\n}\n\nfunction genLogTickValues(minVal, maxVal) {\n    var tickValues = new Array();\n    var leftExponent = Math.floor(Math.log10(minVal || 0.01));\n    var rightExponent = Math.ceil(Math.log10(maxVal || 0.01));\n    for (let i = leftExponent; i <= rightExponent; i++) {\n        for (let j = 1; j < 10; j++) {\n            let value = j * Math.pow(10, i);\n            if (value >= minVal && value <= maxVal)\n            tickValues.push(parseFloat(bestNumberFormat(value)));\n        }\n    }\n    return tickValues;\n}\n\n\n//# sourceURL=webpack:///./axis-layer/index.js?");

/***/ }),

/***/ "./axis-layer/style.css":
/*!******************************!*\
  !*** ./axis-layer/style.css ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./style.css */ \"../node_modules/css-loader/dist/cjs.js!./axis-layer/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./axis-layer/style.css?");

/***/ }),

/***/ "./axis-layer/template.html":
/*!**********************************!*\
  !*** ./axis-layer/template.html ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div>\\n    <svg style=\\\"overflow:visible;margin: {{self.paddingStr();}};width:calc(100% - {{self.leftPadding() + self.rightPadding()}}px); height:calc(100% - {{self.topPadding() + self.bottomPadding()}}px)\\\">\\n        <g class=\\\"layer\\\"></g>\\n    </svg>\\n</div>\\n\\n\";\n\n//# sourceURL=webpack:///./axis-layer/template.html?");

/***/ }),

/***/ "./barchart-layer/index.js":
/*!*********************************!*\
  !*** ./barchart-layer/index.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = 'barchartLayer';\nmodule.exports.name = name;\nmodule.exports.klass = BarchartLayerController;\nmodule.exports.component = buildComponent;\n\n__webpack_require__(/*! ./style.css */ \"./barchart-layer/style.css\");\n//var AbstractLayer = require('../abstract-layer');\nvar AbstractLayer = __webpack_require__(/*! ../abstract-layer-2d */ \"./abstract-layer-2d/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\n\nfunction buildComponent(componentData) {\n    componentData.controller = componentData.controller || BarchartLayerController;\n    componentData.template = componentData.template || __webpack_require__(/*! ./template.html */ \"./barchart-layer/template.html\");\n    componentData.bindings = {\n        bins: \"<\",\n        binGap: \"<\",\n        colorFunc: \"<\",\n        stackFuncArray: \"<\",\n        plotType: \"<\",\n        ...componentData.bindings\n    }\n    return component(componentData);\n}\nvar layerCollection = __webpack_require__(/*! ../layer-collection */ \"./layer-collection/index.js\");\nangular.module(moduleName)\n    .component(name, buildComponent({ }));\n\nfunction BarchartLayerController($timeout, $element, $scope) {\n    let self = this;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n\n    this.watchProperties = this.watchProperties.concat([ \"binGap\", \"plotType\" ]);\n\n    this.$onInit = function() {\n        this.doInit();\n    }\n    this.defaultBindings = function() {\n        this.twoDBindings(this);\n        //this.minY = this.minY || 0;\n        //this.maxY = this.maxY || 100;\n        this.nBins = this.nBins || 5;\n        this.binGap = this.binGap === undefined ? 3 : this.binGap;\n        this.stackFuncArray = this.stackFuncArray || [];\n        this.colorFunc = typeof(this.colorFunc) === \"function\" ? this.colorFunc: () => \"blue\";\n    }\n    this.doAutofit = function() {\n        this.updateMaxY(d3.max(this.bins, function(bin, binIdx) { \n            let stackLevel = d3.sum(self.stackFuncArray, (f) => f(bin, binIdx));\n            return bin.length + stackLevel; \n        }));\n    }\n    this.draw = function() {\n    }\n    this.binOffsets = function(bin, binIdx) {\n        let transform = this.getTransform();\n        let orthoTransform = this.getOrthoTransform();\n        let stackLevel = d3.sum(self.stackFuncArray, (f) => f(bin, binIdx));\n        let x = transform(bin.x0);\n        let y = orthoTransform(bin.length + stackLevel);\n        return { x:x, y:y };\n    }\n    this.binWidth = function(bin, binIdx) {\n        let transform = this.getTransform();\n        let width = Math.abs(transform(bin.x0) - transform(bin.x1));\n        return width >= this.binGap ? width - this.binGap : 0;\n    }\n    this.binHeight = function(bin, binIdx) {\n        let orthoTransform = this.getOrthoTransform();\n        let height = this.contentHeight() - orthoTransform(bin.length);\n        return height;\n    }\n    this.binColor = function(bin, binIdx) {\n        return this.colorFunc(bin);\n    }\n}\n\n\n//# sourceURL=webpack:///./barchart-layer/index.js?");

/***/ }),

/***/ "./barchart-layer/style.css":
/*!**********************************!*\
  !*** ./barchart-layer/style.css ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./style.css */ \"../node_modules/css-loader/dist/cjs.js!./barchart-layer/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./barchart-layer/style.css?");

/***/ }),

/***/ "./barchart-layer/template.html":
/*!**************************************!*\
  !*** ./barchart-layer/template.html ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div>\\n<svg style=\\\"margin: {{self.paddingStr();}};width:calc(100% - {{self.leftPadding() + self.rightPadding()}}px); height:calc(100% - {{self.topPadding() + self.bottomPadding()}}px)\\\">\\n    <g class=\\\"layer\\\">\\n        <g ng-repeat=\\\"bin in self.bins\\\" \\n            ng-offset=\\\"{{self.binOffsets(bin, $index)}}\\\">\\n            <rect ng-x=\\\"{{self.binGap/2}}\\\" ng-y=\\\"0\\\"\\n                ng-width=\\\"{{self.binWidth(bin, $index)}}\\\" \\n                ng-height=\\\"{{self.binHeight(bin, $index)}}\\\"\\n                ng-fill=\\\"{{self.binColor(bin, $index)}}\\\">\\n            </rect>\\n        </g>\\n    </g>\\n</svg>\\n</div>\\n\";\n\n//# sourceURL=webpack:///./barchart-layer/template.html?");

/***/ }),

/***/ "./canvas-barchart-layer/index.js":
/*!****************************************!*\
  !*** ./canvas-barchart-layer/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = 'canvasBarchartLayer';\nmodule.exports.name = name;\nmodule.exports.klass = CanvasBarchartLayerController;\nmodule.exports.component = buildComponent;\n\n__webpack_require__(/*! ./style.css */ \"./canvas-barchart-layer/style.css\");\nconst CanvasHelper = __webpack_require__(/*! ../canvas-helper */ \"./canvas-helper.js\");\n//var AbstractLayer = require('../abstract-layer');\nvar AbstractLayer = __webpack_require__(/*! ../abstract-layer-2d */ \"./abstract-layer-2d/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\n\nfunction buildComponent(componentData) {\n    componentData.controller = componentData.controller || CanvasBarchartLayerController;\n    componentData.template = componentData.template || __webpack_require__(/*! ./template.html */ \"./canvas-barchart-layer/template.html\");\n    componentData.bindings = {\n        bins: \"<\",\n        binGap: \"<\",\n        colorFunc: \"<\",\n        multiple: \"<\",\n        stackFuncArray: \"<\",\n        plotType: \"<\",\n        ...componentData.bindings\n    }\n    return component(componentData);\n}\nvar layerCollection = __webpack_require__(/*! ../layer-collection */ \"./layer-collection/index.js\");\nangular.module(moduleName)\n    .component(name, buildComponent({ }));\n\nfunction CanvasBarchartLayerController($timeout, $element, $scope) {\n    let self = this;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n\n    this.watchProperties = this.watchProperties.concat([ \"binGap\", \"plotType\", \"colorFunc\"]);\n\n    this.$onInit = function() {\n        this.doInit();\n        $timeout(() => {\n            self.bins = self.bins;\n        })\n    }\n    this.defaultBindings = function() {\n        this.twoDBindings(this);\n        //this.minY = this.minY || 0;\n        //this.maxY = this.maxY || 100;\n        this.nBins = this.nBins || 5;\n        this.binGap = this.binGap === undefined ? 3 : this.binGap;\n        this.stackFuncArray = this.stackFuncArray || [];\n        this.colorFunc = typeof(this.colorFunc) === \"function\" ? this.colorFunc: () => \"blue\";\n    }\n    this.doAutofit = function() {\n        this.updateMaxY(d3.max(this.bins, function(bin, binIdx) { \n            let stackLevel = d3.sum(self.stackFuncArray, (f) => f(bin, binIdx));\n            return bin.length + stackLevel; \n        }));\n    }\n\n    let _canvas;\n    function getCanvas() {\n        if (_canvas) return _canvas;\n        _canvas = $element.find('canvas')[0];\n        return _canvas;\n    }\n\n    this.draw = function() {\n        canvas = getCanvas();\n        canvas.width = this.contentWidth();\n        canvas.height = this.contentHeight();\n        let ctx = canvas.getContext('2d');\n        let symbolDefaultCfg = {\n            size: this.symbolSize,\n            fillStyle: 'blue',\n            strokeStyle: 'red'\n        }\n        let helper = new CanvasHelper(ctx, symbolDefaultCfg);\n        if (!self.multiple) {\n            canvasPlot(self.bins, helper);\n        }\n        else {\n            let stacks = [];\n            for (let i = 0; i < self.bins.length; i++) {\n                canvasPlot(self.bins[i], helper, stacks);\n                for (let j = 0; j < self.bins[i].length; j++){\n                    stacks[j] = stacks[j] || 0;\n                    stacks[j] += self.plotType !== 'percentage' ? self.bins[i][j].length : self.bins[i][j].length * 100 / _.sum(self.bins.flat().map(bin => bin.length));\n                }\n            }\n        }\n        function canvasPlot(bins, helper, stacks) {\n            for (let i = 0; i < bins.length; i++) {\n                let bin = bins[i];\n                let stack = (stacks || [])[i] || 0;\n                let w = self.binWidth(bin);\n                let h = self.binHeight(bin, i, bins);\n                let offset = self.binOffsets(bin, i, stack, bins);\n                let x = offset.x + self.binGap/2;\n                let y = offset.y;\n                let color = self.binColor(bin, i, bins);\n                helper.rect(x, y, w, h, {\n                    strokeStyle: self.multiple?'#fff':'#000',\n                    fillStyle: color\n                });\n            }\n        }\n    }\n    this.binOffsets = function(bin, binIdx, stack, bins) {\n        let transform = this.getTransform();\n        let orthoTransform = this.getOrthoTransform();\n        let stackLevel = stack || 0;\n        let x = transform(bin.x0);\n        if (self.minVal > self.maxVal) {\n            x = x - self.binWidth(bin, binIdx) - self.binGap;\n        }\n        let y = orthoTransform((self.plotType !== 'percentage' ? bin.length : bin.length * 100 / _.sum(self.bins.flat().map(bin => bin.length))) + stackLevel);\n        return { x:x, y:y };\n    }\n    this.binWidth = function(bin, binIdx) {\n        let transform = this.getTransform();\n        let width = Math.abs(transform(bin.x0) - transform(bin.x1));\n        return width >= this.binGap ? width - this.binGap : 0;\n    }\n    this.binHeight = function(bin, binIdx, bins) {\n        let orthoTransform = this.getOrthoTransform();\n        let y = self.plotType !== 'percentage' ? bin.length : bin.length * 100 / _.sum(self.bins.flat().map(bin => bin.length));\n        let height = this.contentHeight() - orthoTransform(y);\n        return height;\n    }\n    this.binColor = function(bin, binIdx, bins) {\n        return this.colorFunc(bin, bins, self.params);\n    }\n}\n\n\n//# sourceURL=webpack:///./canvas-barchart-layer/index.js?");

/***/ }),

/***/ "./canvas-barchart-layer/style.css":
/*!*****************************************!*\
  !*** ./canvas-barchart-layer/style.css ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./style.css */ \"../node_modules/css-loader/dist/cjs.js!./canvas-barchart-layer/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./canvas-barchart-layer/style.css?");

/***/ }),

/***/ "./canvas-barchart-layer/template.html":
/*!*********************************************!*\
  !*** ./canvas-barchart-layer/template.html ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div>\\n<canvas style=\\\"margin: {{self.paddingStr();}};width:calc(100% - {{self.leftPadding() + self.rightPadding()}}px); height:calc(100% - {{self.topPadding() + self.bottomPadding()}}px)\\\">\\n</canvas>\\n</div>\\n\";\n\n//# sourceURL=webpack:///./canvas-barchart-layer/template.html?");

/***/ }),

/***/ "./canvas-helper.js":
/*!**************************!*\
  !*** ./canvas-helper.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = CanvasHelper;\nfunction CanvasHelper(ctx, config) {\n    this.ctx = ctx;\n    this.fillStyle = config.fillStyle || 'transparent';\n    this.strokeStyle = config.strokeStyle || 'blue';\n    this.lineWidth = config.lineWidth || 1;\n    this.lineDash = config.lineDash || null;\n    this.size = config.size/4 || 2;\n}\n\n/************* CANVAS Drawing functions ****************/\nCanvasHelper.prototype.circle = function(x, y, opts = {}) {\n    prepare(this, opts);\n    let r = opts.pointSize || this.size;\n    this.ctx.arc(x, y, r, 0, Math.PI*2, true);\n    draw(this);\n}\n\nCanvasHelper.prototype.square = function(x, y, opts = {}) {\n    prepare(this, opts);\n    let a = opts.pointSize || this.size;\n    this.ctx.rect(x-a, y-a, a*2, a*2);\n    draw(this);\n}\n\nCanvasHelper.prototype.cross = function(x, y, opts = {}) {\n    prepare(this, opts);\n    let d = opts.pointSize || this.size;\n    this.ctx.moveTo(x-d, y-d);\n    this.ctx.lineTo(x+d, y+d);\n    this.ctx.moveTo(x-d, y+d);\n    this.ctx.lineTo(x+d, y-d);\n    draw(this);\n}\n\nCanvasHelper.prototype.diamond = function(x, y, opts = {}) {\n    prepare(this, opts);\n    let d = opts.pointSize || this.size;\n    this.ctx.moveTo(x-d, y);\n    this.ctx.lineTo(x, y+d);\n    this.ctx.lineTo(x+d, y);\n    this.ctx.lineTo(x, y-d);\n    this.ctx.closePath();\n    draw(this);\n}\n\nCanvasHelper.prototype.plus = function(x, y, opts = {}) {\n    prepare(this, opts);\n    let d = opts.pointSize || this.size;\n    this.ctx.moveTo(x-d, y);\n    this.ctx.lineTo(x+d, y);\n    this.ctx.moveTo(x, y-d);\n    this.ctx.lineTo(x, y+d);\n    draw(this);\n}\n\nCanvasHelper.prototype.star = function(x, y, opts = {}) {\n    prepare(this, opts);\n    let d = opts.pointSize || this.size;\n    this.ctx.translate(x, y);\n    for (let i = 0; i < 3; i ++) {\n        this.ctx.rotate(Math.PI / 3);\n        this.ctx.moveTo(-d, 0)\n        this.ctx.lineTo(+d, 0);\n    }\n    draw(this);\n}\n\nCanvasHelper.prototype.textSymbol = function (x, y, opts = {}) {\n    if (!opts.textContent) return;\n    let s = opts.textSize || 10;\n    this.ctx.save();\n    this.ctx.font = `${s}px ${opts.fontFamily || 'Verdana'}`;\n    this.ctx.textBaseline = opts.verticalAlign || 'top';\n    this.ctx.textAlign = opts.textAlign || 'start';\n    this.ctx.fillStyle = opts.fillStyle || this.fillStyle;\n    this.ctx.fillText(opts.textContent, x, y);\n    this.ctx.restore();\n}\n\nCanvasHelper.prototype.rect = function(x, y, width, height, opts = {}) {\n    prepare(this, opts);\n    this.ctx.rect(x, y, width, height);\n    draw(this);\n}\n\nCanvasHelper.prototype.segment = function(start, stop, opts = {}) {\n    if (!_.isFinite(start.x + start.y + stop.x + stop.y)) return;\n    prepare(this, opts);\n    this.ctx.moveTo(start.x, start.y);\n    this.ctx.lineTo(stop.x, stop.y);\n    this.ctx.stroke();\n}\n/********************** END *********************/\nfunction prepare(canvas, opts = {}) {\n    let ctx = canvas.ctx;\n    ctx.save();\n\n    ctx.beginPath();\n    ctx.fillStyle = opts.fillStyle || canvas.fillStyle;\n    ctx.strokeStyle = opts.strokeStyle || canvas.strokeStyle;\n    ctx.lineWidth = opts.lineWidth || canvas.lineWidth;\n    let lineDash = opts.lineDash || canvas.lineDash;\n    if (lineDash)\n        ctx.setLineDash(lineDash);\n}\n\nfunction draw(canvas) {\n    let ctx = canvas.ctx;\n    ctx.stroke();\n    ctx.fill();\n    ctx.restore();\n}\n\n\n//# sourceURL=webpack:///./canvas-helper.js?");

/***/ }),

/***/ "./click-layer/index.js":
/*!******************************!*\
  !*** ./click-layer/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = 'clickLayer';\nmodule.exports.name = name;\n\n//var AbstractLayer = require('../interactive-layer');\nvar AbstractLayer = __webpack_require__(/*! ../abstract-layer-2d */ \"./abstract-layer-2d/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\nconst _ = __webpack_require__(/*! lodash */ \"../node_modules/lodash/lodash.js\");\n\n__webpack_require__(/*! ./style.css */ \"./click-layer/style.css\");\nvar layerCollection = __webpack_require__(/*! ../layer-collection */ \"./layer-collection/index.js\");\nangular.module(moduleName)\n    .component(name, component({\n        template: __webpack_require__(/*! ./template.html */ \"./click-layer/template.html\"),\n        controller: ClickLayerController,\n        bindings: {\n            pointerStyle: \"<\",\n            pointerSize: \"<\",\n            coordinateX: \"<\",\n            coordinateY: \"<\",\n            clickHandler: \"<\"\n        }\n    }));\n\nfunction ClickLayerController($timeout, $element, $scope) {\n    let self = this;\n    let dragging = false;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n    this.watchProperties = this.watchProperties.concat([\n        'coordinateX', 'coordinateY', \n        'pointerSize', 'pointerStyle'\n    ]);\n    this.$onInit = function() {\n        this.doInit();\n    }\n    this.defaultBindings = function() {\n        this.pointerSize = this.pointerSize || 5;\n        this.pointerStyle =  this.pointerStyle || {stroke:'blue', 'stroke-width':1, fill:'lightblue'}\n    }\n    this.doAutofit = function() { }\n    this.draw = function() { }\n    this.getPointerStyle = function() {\n        if (!this.coordinateX || !this.coordinateY)\n        return {\n            display: 'none'\n        }\n        return this.pointerStyle;\n    }\n    this.getPointerInfoStyle = function() {\n        if (!this.coordinateX || !this.coordinateY)\n        return {\n            display: 'none'\n        }\n        return {\n            display: 'block'\n        };\n    }\n    this.pointerCoordinates = function() {\n        return `X:${this.coordinateX}; Y:${this.coordinateY}`;\n    }\n    this.pointerOffset = function() {\n        if (!_.isFinite(this.coordinateX) || !_.isFinite(this.coordinateY)) return {x:0, y:0};\n        let transformX = this.getTransform();\n        let transformY = this.getOrthoTransform();\n        return {\n            x: transformX(this.coordinateX),\n            y: transformY(this.coordinateY)\n        }\n    }\n    this.onMouseClick = function($event) {\n        let transformX = this.getTransform();\n        let transformY = this.getOrthoTransform();\n        let xPixel = $event.offsetX;\n        let yPixel = $event.offsetY;\n        let coordinateX = transformX.invert(xPixel);\n        let coordinateY = transformY.invert(yPixel);\n        this.clickHandler && this.clickHandler(coordinateX, coordinateY, transformX, transformY);\n    }\n}\n\n\n//# sourceURL=webpack:///./click-layer/index.js?");

/***/ }),

/***/ "./click-layer/style.css":
/*!*******************************!*\
  !*** ./click-layer/style.css ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./style.css */ \"../node_modules/css-loader/dist/cjs.js!./click-layer/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./click-layer/style.css?");

/***/ }),

/***/ "./click-layer/template.html":
/*!***********************************!*\
  !*** ./click-layer/template.html ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div>\\n    <svg class=\\\"clickable\\\" \\n        style=\\\"margin: {{self.paddingStr();}};width:calc(100% - {{self.leftPadding() + self.rightPadding()}}px); height:calc(100% - {{self.bottomPadding() + self.topPadding()}}px)\\\"\\n        ng-click=\\\"self.onMouseClick($event)\\\">\\n        <g class=\\\"layer\\\">\\n            <circle cx=\\\"0\\\" cy=\\\"0\\\" ng-r=\\\"{{self.pointerSize}}\\\" ng-style=\\\"self.getPointerStyle()\\\" ng-offset=\\\"{{self.pointerOffset()}}\\\"></circle>\\n        </g>\\n    </svg>\\n</div>\\n<!-- <div ng-show=\\\"self.xCoordinate && self.yCoordinate\\\" ng-bind=\\\"self.pointerCoordinates()\\\"></div> -->\\n\";\n\n//# sourceURL=webpack:///./click-layer/template.html?");

/***/ }),

/***/ "./common.js":
/*!*******************!*\
  !*** ./common.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports.bestNumberFormat = bestNumberFormat;\nmodule.exports.findLinearEqn = findLinearEqn;\nmodule.exports.parseFormulaLatex = parseFormulaLatex;\nmodule.exports.distance = distance;\nmodule.exports.findClosest = findClosest;\n\nfunction bestNumberFormat(x, digits = 0) {\n    if (!x) return x;\n    let ex = Math.abs(x / 100);\n    let n = -Math.round(Math.log10(ex));\n    n = n>=digits?n:digits;\n    return (Math.round(x*(10**n))/(10**n)).toFixed(n);\n}\n\nfunction findLinearEqn(p1, p2, loga, orthoLoga) {\n    let p1X, p1Y, p2X, p2Y;\n    if (loga) {\n        p1X = Math.log10(p1.x);\n        p1Y = Math.log10(p1.y);\n    } else {\n        p1X = p1.x;\n        p1Y = p1.y;\n    }\n    if (orthoLoga) {\n        p2X = Math.log10(p2.x);\n        p2Y = Math.log10(p2.y);\n    } else {\n        p2X = p2.x;\n        p2Y = p2.y;\n    }\n    if (p1X != p2X) {\n        let slope = (p1Y - p2Y)/(p1X - p2X);\n        let intercept = p1Y - slope * p1X;\n        return {\n            family:'linear', slope: slope, intercept: intercept\n        }\n    }\n    return {\n        family: 'const', x: p1X\n    }\n}\n//function findLinearEqn(p1, p2) {\n    //if (p1.x != p2.x) {\n        //let slope = (p1.y - p2.y)/(p1.x - p2.x);\n        //let intercept = p1.y - slope * p1.x;\n        //return {\n            //family:'linear', slope: slope, intercept: intercept\n        //}\n    //}\n    //return {\n        //family: 'const', x: p1.x\n    //}\n//}\n\nfunction parseFormulaLatex(formula) {\n    let latex = formula.latex || '';\n    switch(formula.family) {\n        case \"const\":\n            latex = `x = ${formula.x}`;\n            break;\n        case \"linear\":\n            let intercept = formula.intercept;\n            let slopeStr = bestNumberFormat(formula.slope, 4);\n            let interceptStr = bestNumberFormat(Math.abs(formula.intercept), 4);\n            latex = `y = ${slopeStr} \\\\times x ${intercept==0?'':(intercept<0 ? '-' + interceptStr:'+' + interceptStr)}; R^2=${bestNumberFormat(formula.r2, 4)}`;\n            break;\n        case \"exponential\":\n            latex = `y = ${bestNumberFormat(formula.ae, 4)} \\\\times e^\\{${bestNumberFormat(formula.b, 4)} x\\}; R^2=${bestNumberFormat(formula.r2, 4)}`;\n            break;\n        case \"power\":\n            latex = `y = ${bestNumberFormat(formula.coefficient, 4)} \\\\times x^\\{${bestNumberFormat(formula.exponent, 4)}\\}; R^2=${bestNumberFormat(formula.r2, 4)}`;\n            break;\n        case \"polynomial\":\n            let order = formula.equation.length - 1;\n            latex += `y =`;\n            formula.equation.forEach((eq, idx) => {\n                if (eq == 0) return;\n                let toConcat = !idx ? '' : (eq > 0 ? ' +' : '');\n                let up = order - idx;\n                toConcat += up ? ` ${eq}x${up < 2 ? `` : `^\\{${up}\\}`}` : ` ${eq}`;\n                latex += toConcat;\n            })\n            latex += `; R^2=${bestNumberFormat(formula.r2, 4)}`;\n            break;\n        case \"mse\":\n            latex = `MSE = ${bestNumberFormat(formula.mse, 4)}`;\n            break;\n    }\n    return latex.replace(/\\+\\-/g, '-');\n}\n\nfunction distance(p1, p2) {\n    return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);\n}\nfunction findClosest(p, points) {\n    let minDistance = 100000;\n    let minIdx = undefined;\n    for (let i = 0; i < points.length; i++) {\n        let d = distance(p, points[i]);\n        if (d < minDistance) {\n            minDistance = d;\n            minIdx = i;\n        }\n    }\n    return {\n        distance: minDistance,\n        idx : minIdx\n    }\n}\n\n\n//# sourceURL=webpack:///./common.js?");

/***/ }),

/***/ "./control-marker-layer/index.js":
/*!***************************************!*\
  !*** ./control-marker-layer/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = \"controlMarkerLayer\";\nmodule.exports.name = name;\n\n__webpack_require__(/*! ./style.css */ \"./control-marker-layer/style.css\");\nvar AbstractLayer = __webpack_require__(/*! ../abstract-layer */ \"./abstract-layer/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\n\nvar layerCollection = __webpack_require__(/*! ../layer-collection */ \"./layer-collection/index.js\");\nangular.module(moduleName).component(name, component({\n    controller: ControlMarkerLayerController, \n    template: __webpack_require__(/*! ./template.html */ \"./control-marker-layer/template.html\"),\n    bindings: {\n        markers: \"<\",\n        markersMask: '<',\n        draggable: \"<\",\n        markerStyle: \"<\",\n        getMarkerStyleFn: \"<\",\n        markerWidth: \"<\",\n        getMarkerValue: \"<\",\n        setMarkerValue: \"<\",\n        getMarkerName: \"<\",\n        orderFree: \"<\",\n        notUseBackground: '<',\n        onMarkerDragEnd: \"<\"\n    }\n}));\nfunction ControlMarkerLayerController($timeout, $element, $scope ) {\n    let self = this;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n\n    this.watchProperties = this.watchProperties.concat([\n        \"markers\",\n        \"markerStyle\",\n        \"markerWidth\",\n        \"getMarkerValue\",\n        \"setMarkerValue\",\n        \"draggable\",\n        \"notUseBackground\"\n    ]);\n    this.defaultBindings = function() {\n        this.getMarkerStyleFn = this.getMarkerStyleFn || function() {return undefined};\n        this.markerStyle = typeof(this.markerStyle) === 'object'?this.markerStyle:{stroke:\"green\", \"stroke-width\": 2,\"fill\":\"none\"};\n        this.markerWidth = this.markerWidth || 19;\n        this.draggable = this.draggable || false;\n        this.notUseBackground = this.notUseBackground === undefined ? true : this.notUseBackground;\n    }\n    this.$onInit = function() {\n        this.doInit();\n    }\n    this.draw = function() {\n    }\n    this.markerOffset = function(marker, idx) {\n        let transform = this.getTransform();\n        switch(this.axisDirection) {\n        case \"left\":\n        case \"right\":\n            return {\n                x: transform(self.getMarkerValue(marker, idx)) - self.markerWidth/2 || 0,\n                y: 0\n            }\n        case \"up\":\n        case \"down\":\n            return {\n                x: 0,\n                y: transform(self.getMarkerValue(marker, idx)) - self.markerWidth/2 || 0\n            }\n        }\n    }\n    this.dragStart = function(marker, $event, $index) {\n        if (!this.draggable) return;\n        $event.stopPropagation();\n        $event.preventDefault();\n        marker.dragging = true;\n        switch(this.axisDirection) {\n        case \"left\":\n        case \"right\":\n            marker.startX = $event.offsetX;\n            break;\n        case \"up\":\n        case \"down\":\n            marker.startY = $event.offsetY;\n            break;\n        }\n    }\n    this.dragEnd = function($event) {\n        self.onMarkerDragEnd && self.onMarkerDragEnd();\n        this.markers.forEach((m) => {\n            m.dragging = false;\n            delete m.startX;\n            delete m.startY;\n        });\n    }\n    this.dragging = function($event) {\n        switch(this.axisDirection) {\n        case \"left\":\n        case \"right\":\n            return this.xDragging($event);\n        case \"up\":\n        case \"down\":\n            return this.yDragging($event);\n        }\n    }\n    this.xDragging = function($event) {\n        for (let i = 0; i < this.markers.length; i++) {\n            if (!this.markers[i].dragging) continue;\n\n            let marker = this.markers[i];\n            let offset = $event.offsetX - marker.startX;\n            let x = this.getTransform()(this.getMarkerValue(marker, i)) - this.markerWidth/2 + offset;\n            let value = this.getTransform().invert(x + this.markerWidth/2);\n            let lowerMarkerVal = this.minVal;\n            let higherMarkerVal = this.maxVal;\n            if (!self.orderFree) {\n                lowerMarkerVal = this.markers[i-1] ? this.getMarkerValue(this.markers[i-1], i-1):this.minVal;\n                higherMarkerVal = this.markers[i+1] ? this.getMarkerValue(this.markers[i+1], i+1):this.maxVal;\n            }\n            if ( (value - lowerMarkerVal) * ( value -  higherMarkerVal) >= 0) continue;\n            this.setMarkerValue(marker, i, value);\n            marker.startX = $event.offsetX;\n        }\n    }\n    this.yDragging = function($event) {\n        for (let i = 0; i < this.markers.length; i++) {\n            if (!this.markers[i].dragging) continue;\n\n            let marker = this.markers[i];\n            let offset = $event.offsetY - marker.startY;\n            let y = this.getTransform()(this.getMarkerValue(marker, i)) - this.markerWidth/2 + offset;\n            let value = this.getTransform().invert(y + this.markerWidth/2);\n\n            let lowerMarkerVal = this.minVal;\n            let higherMarkerVal = this.maxVal;\n            if (!self.orderFree) {\n                lowerMarkerVal = this.markers[i-1] ? this.getMarkerValue(this.markers[i-1], i-1):this.minVal;\n                higherMarkerVal = this.markers[i+1] ? this.getMarkerValue(this.markers[i+1], i+1):this.maxVal;\n            }\n\n           // let lowerMarkerVal = this.markers[i - 1]?this.getMarkerValue(this.markers[i - 1], i - 1):this.minVal;\n           // let higherMarkerVal = this.markers[i + 1]?this.getMarkerValue(this.markers[i + 1], i + 1):this.maxVal;\n            if ( (value - lowerMarkerVal) * ( value -  higherMarkerVal) >= 0) continue;\n            this.setMarkerValue(marker, i, value);\n            marker.startY = $event.offsetY;\n        }\n    }\n    this.markerMouseOver = function($event, marker, idx) {\n        if (!this.draggable) return;\n        marker.opacity = 1; \n        $timeout(() => {\n            switch(self.axisDirection) { \n                case \"left\":\n                case \"right\":\n                    marker.handlePos = $event.offsetY - self.markerWidth/2;\n                    break;\n                case \"up\":\n                case \"down\":\n                    marker.handlePos = $event.offsetX - self.markerWidth/2;\n                    break;\n            }\n        }); \n    }\n    let __cursorStyle = {};\n    this.getCursorStyle = function() {\n        Object.keys(__cursorStyle).forEach(key => delete __cursorStyle[key]);\n        if (!this.draggable) {\n            Object.assign(__cursorStyle, { cursor: 'default'});\n            return __cursorStyle;\n        }\n        switch (this.axisDirection) {\n        case \"left\":\n        case \"right\":\n            Object.assign(__cursorStyle, {cursor: 'ew-resize'});\n            return __cursorStyle;\n        case \"up\":\n        case \"down\":\n            Object.assign(__cursorStyle, {cursor: 'ns-resize'});\n            return __cursorStyle;\n        }\n    }\n    this.getSVGStyle = function() {\n        return {\n            'background-color': !self.notUseBackground ? 'rgba(255, 249, 160, 0.6)' : 'transparent'\n        };\n    }\n\n    this.getMarkerStyle = function(marker, idx) {\n        return self.getMarkerStyleFn(marker, idx) || self.markerStyle;\n    }\n    let __markerKnobStyle = {};\n    this.markerKnobStyle = function(marker, idx) {\n        Object.keys(__markerKnobStyle).forEach(key => delete __markerKnobStyle);\n        Object.assign(__markerKnobStyle, {\n            opacity: marker.opacity || 0,\n            ...(this.getMarkerStyle(marker, idx))\n        });\n        return __markerKnobStyle;\n    }\n\n    this.isMarkerVisible = function($index) {\n        if (!self.markersMask || !self.markersMask.length) {\n            return true;\n        }\n        return self.markersMask[$index];\n    }\n}\n\n\n\n//# sourceURL=webpack:///./control-marker-layer/index.js?");

/***/ }),

/***/ "./control-marker-layer/style.css":
/*!****************************************!*\
  !*** ./control-marker-layer/style.css ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./style.css */ \"../node_modules/css-loader/dist/cjs.js!./control-marker-layer/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./control-marker-layer/style.css?");

/***/ }),

/***/ "./control-marker-layer/template.html":
/*!********************************************!*\
  !*** ./control-marker-layer/template.html ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div>\\n    <svg style=\\\"margin: {{self.paddingStr();}};width:calc(100% - {{self.leftPadding() + self.rightPadding()}}px); height:calc(100% - {{self.topPadding() + self.bottomPadding()}}px); background-color: {{self.getSVGStyle()['background-color']}}\\\"\\n        ng-mouseup=\\\"self.dragEnd($event)\\\" ng-mousemove=\\\"self.dragging($event)\\\">\\n        <g ng-repeat=\\\"marker in self.markers track by $index\\\"\\n            ng-show=\\\"self.isMarkerVisible($index)\\\"\\n            ng-style=\\\"self.getCursorStyle()\\\"\\n            ng-offset=\\\"{{self.markerOffset(marker, $index)}}\\\"\\n            ng-mousedown=\\\"self.dragStart(marker, $event, $index)\\\"\\n            ng-mouseover=\\\"self.markerMouseOver($event, marker,$index)\\\" ng-mouseleave=\\\"marker.opacity = null;\\\">\\n            <line ng-if=\\\"self.axisDirection === 'right' || self.axisDirection === 'left'\\\"\\n                ng-x1=\\\"{{self.markerWidth/2}}\\\" \\n                ng-x2=\\\"{{self.markerWidth/2}}\\\" \\n                y1=\\\"0\\\" \\n                ng-y2=\\\"{{self.contentHeight(true)}}\\\" \\n                ng-style=\\\"{{self.getMarkerStyle(marker, $index)}}\\\"/>\\n            <line ng-if=\\\"self.axisDirection === 'up' || self.axisDirection === 'down'\\\"\\n                ng-y1=\\\"{{self.markerWidth/2}}\\\" \\n                ng-y2=\\\"{{self.markerWidth/2}}\\\" \\n                x1=\\\"0\\\" \\n                ng-x2=\\\"{{self.contentWidth(true)}}\\\" \\n                ng-style=\\\"{{self.getMarkerStyle(marker, $index)}}\\\"/>\\n            <rect ng-if=\\\"self.axisDirection === 'right' || self.axisDirection === 'left'\\\" \\n                x=\\\"0\\\" y=\\\"0\\\" \\n                ng-width=\\\"{{self.markerWidth}}\\\" ng-height=\\\"{{self.markerWidth}}\\\"\\n                ng-offset=\\\"{{ {x: 0, y: marker.handlePos || (self.contentHeight() - self.markerWidth)/2 } }}\\\"\\n                ng-style=\\\"self.markerKnobStyle(marker, $index)\\\"/>\\n            <rect ng-if=\\\"self.axisDirection === 'up' || self.axisDirection === 'down'\\\" \\n                x=\\\"0\\\" y=\\\"0\\\" \\n                ng-width=\\\"{{self.markerWidth}}\\\" ng-height=\\\"{{self.markerWidth}}\\\"\\n                ng-offset=\\\"{{ {y: 0, x: marker.handlePos || (self.contentWidth() - self.markerWidth)/2 } }}\\\"\\n                ng-style=\\\"self.markerKnobStyle(marker, $index)\\\"/>\\n            <text ng-if=\\\"self.getMarkerName\\\" ng-offset=\\\"{{ {x: 20, y:20 * ($index + 1)} }}\\\" fill=\\\"black\\\">\\n                {{self.getMarkerName(marker, $index)}}\\n            </text>\\n        </g>\\n    </svg>\\n</div>\\n\";\n\n//# sourceURL=webpack:///./control-marker-layer/template.html?");

/***/ }),

/***/ "./curve-view-layer/index.js":
/*!***********************************!*\
  !*** ./curve-view-layer/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = 'curveViewLayer';\nmodule.exports.name = name;\nmodule.exports.klass = curveViewLayerController;\nmodule.exports.component = buildComponent;\n\n__webpack_require__(/*! ./style.css */ \"./curve-view-layer/style.css\");\nconst AbstractLayer = __webpack_require__(/*! ../abstract-layer-2d */ \"./abstract-layer-2d/index.js\");\nconst AbstractLayerController = AbstractLayer.klass;\nconst component = AbstractLayer.component;\n\nfunction buildComponent(componentData) {\n    componentData.controller = componentData.controller || curveViewLayerController;\n    componentData.template = componentData.template || __webpack_require__(/*! ./template.html */ \"./curve-view-layer/template.html\");\n    componentData.bindings = {\n        curveData: \"<\",\n        ...componentData.bindings\n    }\n    return component(componentData);\n}\nangular.module(moduleName)\n    .component(name, buildComponent({ }));\n\nfunction curveViewLayerController($timeout, $element, $scope) {\n    const self = this;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n    this.watchProperties = this.watchProperties.concat([\"curveData\"]);\n    this.$onInit = function() {\n        this.doInit();\n    }\n\n    let _canvas;\n    function getCanvas() {\n        if (_canvas) return _canvas;\n        _canvas = $element.find('canvas')[0];\n        return _canvas;\n    }\n\n    this.defaultBindings = function() {\n        this.twoDBindings(this);\n    }\n\n    this.draw = function() {\n        console.log(self.curveData);\n        canvas = getCanvas();\n        canvas.width = self.contentWidth();\n        canvas.height = self.contentHeight();\n        let ctx = canvas.getContext('2d');\n        const tfX = self.getTransform();    \n        const tfY = self.getOrthoTransform();\n        ctx.strokeStyle = 'black';\n        ctx.beginPath();\n        self.curveData.forEach((datum, i) => {\n            if (i == 0) {\n                ctx.moveTo(tfX(datum.x), tfY(datum.y));\n            } else {\n                ctx.lineTo(tfX(datum.x), tfY(datum.y));\n            }\n        })\n        ctx.stroke();\n    }\n}\n\n//# sourceURL=webpack:///./curve-view-layer/index.js?");

/***/ }),

/***/ "./curve-view-layer/style.css":
/*!************************************!*\
  !*** ./curve-view-layer/style.css ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./style.css */ \"../node_modules/css-loader/dist/cjs.js!./curve-view-layer/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./curve-view-layer/style.css?");

/***/ }),

/***/ "./curve-view-layer/template.html":
/*!****************************************!*\
  !*** ./curve-view-layer/template.html ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div>\\n<canvas style=\\\"margin: {{self.paddingStr();}};width:calc(100% - {{self.leftPadding() + self.rightPadding()}}px); height:calc(100% - {{self.topPadding() + self.bottomPadding()}}px)\\\">\\n</canvas>\\n</div>\";\n\n//# sourceURL=webpack:///./curve-view-layer/template.html?");

/***/ }),

/***/ "./heat-map/index.js":
/*!***************************!*\
  !*** ./heat-map/index.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = 'heatMap';\nmodule.exports.name = name;\nmodule.exports.klass = heatMapController;\nmodule.exports.component = buildComponent;\n\n__webpack_require__(/*! ./style.css */ \"./heat-map/style.css\");\nconst AbstractLayer = __webpack_require__(/*! ../abstract-layer-2d */ \"./abstract-layer-2d/index.js\");\nconst AbstractLayerController = AbstractLayer.klass;\nconst component = AbstractLayer.component;\nvar CanvasHelper = __webpack_require__(/*! ../canvas-helper */ \"./canvas-helper.js\");\n\nfunction buildComponent(componentData) {\n    componentData.controller = componentData.controller || heatMapController;\n    componentData.template = componentData.template || __webpack_require__(/*! ./template.html */ \"./heat-map/template.html\");\n    componentData.bindings = {\n        nRow: \"<\",\n        nCol: \"<\",\n        cellColorFn: \"<\",\n        cellValueFn: \"<\",\n        updateTrigger: \"<\",\n        ...componentData.bindings\n    }\n    return component(componentData);\n}\nangular.module(moduleName)\n    .component(name, buildComponent({ }));\n\nfunction heatMapController($timeout, $element, $scope) {\n    const self = this;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n    this.watchProperties = this.watchProperties.concat([\"nRow\", \"nCol\", \"cellColorFn\", \"cellValueFn\", \"updateTrigger\"]);\n    this.$onInit = function() {\n        this.doInit();\n    }\n\n    let _canvas;\n    function getCanvas() {\n        if (_canvas) return _canvas;\n        _canvas = $element.find('canvas')[0];\n        return _canvas;\n    }\n\n    this.defaultBindings = function() {\n        this.twoDBindings(this);\n        this.nRow = this.nRow || 0;\n        this.nCol = this.nCol || 0;\n        this.cellColorFn = typeof(this.cellColorFn) == \"function\" ? this.cellColorFn : () => \"transparent\";\n        this.cellValueFn = typeof(this.cellValueFn) == \"function\" ? this.cellValueFn : () => 0;\n    }\n\n    this.draw = function() {\n        canvas = getCanvas();\n        canvas.width = self.contentWidth();\n        canvas.height = self.contentHeight();\n        let ctx = canvas.getContext('2d');\n        let helper = new CanvasHelper(ctx, {\n            fillStyle: '#000',\n            strokeStyle: '#000'\n        });\n\n        const textConfig = {\n            textAlign: 'center',\n            verticalAlign: 'middle',\n            fontFamily: \"Sans Serif\",\n            textSize: 14\n        }\n        if (canvas.width > 0 && canvas.height > 0 && self.nRow > 0 && self.nCol > 0) {\n            const arr = new Array(self.nRow * self.nCol).fill(0);\n            const xTf = self.getTransform();\n            const yTf = self.getOrthoTransform();\n            const xStep = (self.maxVal - self.minVal) / self.nCol;\n            const yStep = (self.maxY - self.minY) / self.nRow;\n            const xTicks = d3.range(self.minVal, self.maxVal + xStep, xStep);\n            const yTicks = d3.range(self.minY, self.maxY + yStep, yStep);\n            xTicks.forEach((xValue, iCol) => {\n                yTicks.forEach((yValue, iRow) => {\n                    const iCell = iRow * self.nCol + iCol;\n                    const x = xTf(xValue);\n                    const y = yTf(yValue);\n                    const nextXValue = xTicks[iCol + 1];\n                    const nextYValue = yTicks[iRow + 1];\n                    if (nextXValue && nextYValue) {\n                        arr[iCell] = self.cellValueFn(iCell, iRow, iCol);\n                        const nextX = xTf(nextXValue);\n                        const nextY = yTf(nextYValue);\n                        const width = nextX - x;\n                        const height = nextY - y;\n                        helper.rect(x, y, width, height, { fillStyle: self.cellColorFn(iCell, iRow, iCol), strokeStyle: 'transparent' });\n                        helper.textSymbol( x + width / 2, y + height / 2, { textContent: arr[iCell], ...textConfig });\n                    }\n                })\n            })\n        }\n    }\n\n}\n\n\n//# sourceURL=webpack:///./heat-map/index.js?");

/***/ }),

/***/ "./heat-map/style.css":
/*!****************************!*\
  !*** ./heat-map/style.css ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./style.css */ \"../node_modules/css-loader/dist/cjs.js!./heat-map/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./heat-map/style.css?");

/***/ }),

/***/ "./heat-map/template.html":
/*!********************************!*\
  !*** ./heat-map/template.html ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div>\\n<canvas style=\\\"margin: {{self.paddingStr();}};width:calc(100% - {{self.leftPadding() + self.rightPadding()}}px); height:calc(100% - {{self.topPadding() + self.bottomPadding()}}px)\\\">\\n</canvas>\\n</div>\";\n\n//# sourceURL=webpack:///./heat-map/template.html?");

/***/ }),

/***/ "./histogram-layer/index.js":
/*!**********************************!*\
  !*** ./histogram-layer/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = 'histogramLayer';\nmodule.exports.name = name;\n\nvar AbstractLayer = __webpack_require__(/*! ../barchart-layer */ \"./barchart-layer/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\n\nvar layerCollection = __webpack_require__(/*! ../layer-collection */ \"./layer-collection/index.js\");\nangular.module(moduleName)\n    .component(name, component({\n        controller: HistogramLayerController,\n        bindings: {\n            points: \"<\",\n            getPointVal: \"<\",\n            binCount: \"<\"\n        }\n    }));\n\nfunction HistogramLayerController($timeout, $element, $scope) {\n    let self = this;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n\n    this.watchProperties = this.watchProperties.concat([ 'binCount' ]);\n\n    function refresh() {\n        self.getTransform(true);\n        self.genBins();\n    }\n    this.registerWatch(() => refresh());\n    this.$onInit = function() {\n        this.doInit();\n    }\n    this.genBins = function () {\n        if (!this.points || !this.points.length) return;\n        let thresholds;\n        if (!this.loga)\n            thresholds = d3.range(this.minVal, this.maxVal, (this.maxVal - this.minVal)/this.binCount);\n        else {\n            let logMinVal = Math.log10(this.minVal || 0.01);\n            let logMaxVal = Math.log10(this.maxVal || 0.01);\n            thresholds = d3.range(logMinVal, logMaxVal, (logMaxVal - logMinVal)/this.binCount).map(v => Math.pow(10, v)); \n        }\n        let histGen = d3.histogram().domain([this.minVal, this.maxVal]).thresholds(thresholds);\n        this.bins = histGen(this.points.map(function(p, i) { return self.getPointVal(p,i); }));\n    }\n}\n\n\n//# sourceURL=webpack:///./histogram-layer/index.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./plot-toolkit-module */ \"./plot-toolkit-module.js\");\nmodule.exports = {\n    AxisLayer: __webpack_require__(/*! ./axis-layer */ \"./axis-layer/index.js\"),\n    BarchartLayer : __webpack_require__(/*! ./barchart-layer */ \"./barchart-layer/index.js\"),\n    CanvasBarchartLayer : __webpack_require__(/*! ./canvas-barchart-layer */ \"./canvas-barchart-layer/index.js\"),\n    HistogramLayer : __webpack_require__(/*! ./histogram-layer */ \"./histogram-layer/index.js\"),\n    LineBinLayer : __webpack_require__(/*! ./line-bin-layer */ \"./line-bin-layer/index.js\"),\n    LinePointLayer : __webpack_require__(/*! ./line-point-layer */ \"./line-point-layer/index.js\"),\n    LineFormulaLayer : __webpack_require__(/*! ./line-formula-layer */ \"./line-formula-layer/index.js\"),\n    LineGaussianLayer : __webpack_require__(/*! ./line-gaussian-layer */ \"./line-gaussian-layer/index.js\"),\n    ControlMarkerLayer : __webpack_require__(/*! ./control-marker-layer */ \"./control-marker-layer/index.js\"),\n    ScatterLayer : __webpack_require__(/*! ./scatter-layer */ \"./scatter-layer/index.js\"),\n    SegmentLayer : __webpack_require__(/*! ./segment-layer */ \"./segment-layer/index.js\"),\n    ClickLayer : __webpack_require__(/*! ./click-layer */ \"./click-layer/index.js\"),\n    PolygonLayer : __webpack_require__(/*! ./polygon-layer */ \"./polygon-layer/index.js\"),\n    OverlayLineLayer: __webpack_require__(/*! ./overlay-line-layer */ \"./overlay-line-layer/index.js\"),\n    TooltipLayer: __webpack_require__(/*! ./tooltip-layer */ \"./tooltip-layer/index.js\"),\n    heatMap: __webpack_require__(/*! ./heat-map */ \"./heat-map/index.js\"),\n    curveViewLayer: __webpack_require__(/*! ./curve-view-layer */ \"./curve-view-layer/index.js\"),\n    RGraph: {\n        core: __webpack_require__(/*! ../vendor/RGraph.common.core */ \"../vendor/RGraph.common.core.js\"),\n        rose: __webpack_require__(/*! ../vendor/RGraph.rose */ \"../vendor/RGraph.rose.js\"),\n        rscatter: __webpack_require__(/*! ../vendor/RGraph.rscatter */ \"../vendor/RGraph.rscatter.js\")\n    },\n    RoseLayer: __webpack_require__(/*! ./rose-layer */ \"./rose-layer/index.js\"),\n    RscatterRoseLayer: __webpack_require__(/*! ./rscatter-rose-layer */ \"./rscatter-rose-layer/index.js\")\n// \t,\n//    LayerWrapper : require('./layer-wrapper'),\n//    LayerArray : require('./layer-array')\n}\nwindow.mathGeo = __webpack_require__(/*! ./common */ \"./common.js\");\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./interactive-layer/index.js":
/*!************************************!*\
  !*** ./interactive-layer/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports.name = name;\nmodule.exports.klass = InteractiveLayerController;\nmodule.exports.component = buildComponent;\n\nvar AbstractLayer = __webpack_require__(/*! ../abstract-layer-2d */ \"./abstract-layer-2d/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\n\nlet bestNumberFormat = __webpack_require__(/*! ../common */ \"./common.js\").bestNumberFormat;\n\n__webpack_require__(/*! ./style.css */ \"./interactive-layer/style.css\");\nfunction buildComponent(componentData) {\n    componentData.template = componentData.template || __webpack_require__(/*! ./template.html */ \"./interactive-layer/template.html\");\n    componentData.bindings = {\n        fillStyle: \"<\",\n        draggerStyle: '<',\n        strokeStyle: \"<\",\n        strokeWidth: \"<\",\n        editPointIdx: \"<\",\n        points: \"<\",\n        getXFn: \"<\",\n        getYFn: \"<\",\n        setXFn: \"<\",\n        setYFn: \"<\",\n        getPointLabel: \"<\",\n        mode : \"<\",\n        showVertex: '<',\n        showCoordinates: '<',\n        ...componentData.bindings\n    }\n    return component(componentData);\n}\n\nfunction InteractiveLayerController($timeout, $element, $scope) {\n    let self = this;\n    let dragging = false;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n    this.watchProperties = this.watchProperties.concat([ \"fillStyle\", \"strokeStyle\", 'strokeWidth' ]);\n    this.interactiveBindings = function() {\n        this.twoDBindings();\n        this.fillStyle = this.fillStyle || \"rgba(255,255, 64, 0.5)\";\n        this.strokeStyle = this.strokeStyle || \"teal\";\n        this.strokeWidth = this.strokeWidth || \"2\";\n        this.editPointIdx = this.editPointIdx || null;\n        this.mode = this.mode || null;\n        this.points = this.points || [];\n        this.getXFn = this.getXFn || function(point, idx, points) {\n            return point.x;\n        }\n        this.getYFn = this.getYFn || function(point, idx, points) {\n            return point.y;\n        }\n        this.setXFn = this.setXFn || function(point, value) {\n            point.x = value;\n        }\n        this.setYFn = this.setYFn || function(point, value) {\n            point.y = value;\n        }\n        this.getPointLabel = this.getPointLabel || function(point) {\n            return `${point.x}-${point.y}`;\n        }\n    }\n\n    this.mouseDownAddPoint = function($event) {\n    }\n    this.mouseDownDelPoint = function($event) {\n    }\n\n    this.onMouseDown = function($event) {\n        this.shiftKey = $event.shiftKey;\n        this.altKey = $event.altKey;\n        if ($event.altKey) {\n            this.mouseDownDelPoint($event);\n        }\n        else if ($event.shiftKey) {\n            this.mouseDownAddPoint($event);\n        }\n        else {\n            dragging = true;\n            let transformX = this.getTransform().invert;\n            let transformY = this.getOrthoTransform().invert;\n            startX = $event.offsetX;\n            startY = $event.offsetY;\n        }\n    }\n    this.onMouseUp = function($event) {\n        this.shiftKey = $event.shiftKey;\n        this.altKey = $event.altKey;\n        dragging = false;\n    }\n    this.onMouseMove = function($event) {\n        this.shiftKey = $event.shiftKey;\n        this.altKey = $event.altKey;\n        this.onMouseMoveTooltip($event);\n        if (dragging) {\n            this.mouseMoveDragging($event);\n        }\n        else {\n            this.mouseMoveNoDragging($event);\n        }\n        return true;\n    }\n    this.mouseMoveDragging = function($event) {\n        if (!_.isFinite(this.editPointIdx)) return;\n        if (!this.points[this.editPointIdx]) return;\n        let transformX = this.getTransform();\n        let transformY = this.getOrthoTransform();\n        let offsetX = $event.offsetX - startX;\n        let offsetY = $event.offsetY - startY;\n        let pixelX = transformX(self.getXFn(this.points[this.editPointIdx], this.editPointIdx, this.points));\n        let pixelY = transformY(self.getYFn(this.points[this.editPointIdx], this.editPointIdx, this.points));\n        pixelX += offsetX;\n        pixelY += offsetY;\n        this.setXFn(this.points[this.editPointIdx], transformX.invert(pixelX));\n        this.setYFn(this.points[this.editPointIdx], transformY.invert(pixelY));\n        //this.points[this.editPointIdx].x = transformX.invert(pixelX);\n        //this.points[this.editPointIdx].y = transformY.invert(pixelY);\n        startX = $event.offsetX;\n        startY = $event.offsetY;\n    }\n    let invertX, invertY;\n    this.mouseMoveNoDragging = function($event) {\n        //$event.stopPropagation();\n        //$event.preventDefault();\n        let transformX = this.getTransform();\n        let transformY = this.getOrthoTransform();\n        let x = $event.offsetX;\n        let y = $event.offsetY;\n        invertX = transformX.invert(x);\n        invertY = transformY.invert(y);\n        this.editPointIdx = null;\n        let result = findClosest({x,y}, this.points, transformX, transformY);\n        if (result.distance < 10) {\n            $timeout(() => {\n                self.editPointIdx = result.idx;\n            });\n        }\n    }\n    this.onMouseLeave = function($event) {\n        this.onMouseLeaveTooltip($event);\n        this.shiftKey = $event.shiftKey;\n        this.altKey = $event.altKey;\n        dragging = false;\n        invertX = undefined;\n        invertY = undefined;\n    }\n    this.vertexOffset = function(p, index, points) {\n        let transformX = this.getTransform();\n        let transformY = this.getOrthoTransform();\n        let toRet = {\n            x: transformX(self.getXFn(p, index, points)),\n            y: transformY(self.getYFn(p, index, points))\n        };\n        return toRet;\n    }\n    let vertexStyleList = [];\n    this.vertexStyle = function(p, idx) {\n        let vertexStyle = vertexStyleList[idx];\n        if (!vertexStyle) {\n            vertexStyleList[idx] = {\n                fill: 'transparent',\n                stroke: 'blue',\n                \"stroke-width\": 1\n            };\n            vertexStyle = vertexStyleList[idx];\n        }\n        return vertexStyle;\n    }\n    this.draggerStyleFn = function() {\n        if (this.editPointIdx === null || !this.mode) \n            return {\n                fill: 'none', stroke: 'none'\n            }\n        return {\n            fill: \"lightblue\",\n            stroke: 'blue',\n            \"stroke-width\": 1\n        }\n    }\n//    const draggerOffset = {}\n    this.draggerOffset = function() {\n        if (!_.isFinite(this.editPointIdx)) return {x: 0, y: 0};\n        let transformX = this.getTransform();\n        let transformY = this.getOrthoTransform();\n        let toRet = {\n            x: transformX(self.getXFn(this.points[this.editPointIdx], this.editPointIdx, this.points)),\n            y: transformY(self.getYFn(this.points[this.editPointIdx], this.editPointIdx, this.points))\n        };\n        return toRet;\n    }\n    this.getPoints = function() {\n        let transformX = this.getTransform();\n        //let range = d3.extent(transformX.range());\n        //if (range[1] - range[0] < 0.000001) {\n            //transformX = this.getTransform(true);\n        //}\n        let transformY = this.getOrthoTransform();\n        //range = d3.extent(transformY.range());\n        //if (range[1] - range[0] < 0.000001) {\n            //transformY = this.getOrthoTransform(true);\n        //}\n        let pointCoordinates = this.points.map((p, idx) => ({\n            x: transformX(self.getXFn(p, idx, this.points)),\n            y: transformY(self.getYFn(p, idx, this.points))\n        }));\n        return JSON.stringify(pointCoordinates);\n    }\n    this.getCoordinates = function() {\n        if (this.mode && _.isFinite(this.editPointIdx)) {\n            let p = this.points[this.editPointIdx];\n            return `X:${bestNumberFormat(self.getXFn(p, this.editPointIdx, this.points))}\n            Y:${bestNumberFormat(self.getYFn(p, this.editPointIdx, this.points))}`\n        } else {\n            if (!invertX || !invertY)\n                return '';\n            return `X:${bestNumberFormat(invertX)}\n            Y:${bestNumberFormat(invertY)}`;\n        }\n    }\n    this.distance = distance;\n    function distance(p1, p2, tX, tY) {\n        return Math.sqrt((p1.x - tX(self.getXFn(p2.p, p2.idx, this.points)))**2 + (p1.y - tY(self.getYFn(p2.p, p2.idx, this.points)))**2);\n    }\n    this.findClosest = findClosest;\n    function findClosest(p, points, tX, tY) {\n        let minDistance = 100000;\n        let minIdx = undefined;\n        for (let i = 0; i < points.length; i++) {\n            let d = distance(p, {p:points[i], idx:i}, tX, tY);\n            if (d < minDistance) {\n                minDistance = d;\n                minIdx = i;\n            }\n        }\n        return {\n            distance: minDistance,\n            idx : minIdx\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./interactive-layer/index.js?");

/***/ }),

/***/ "./interactive-layer/style.css":
/*!*************************************!*\
  !*** ./interactive-layer/style.css ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./style.css */ \"../node_modules/css-loader/dist/cjs.js!./interactive-layer/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./interactive-layer/style.css?");

/***/ }),

/***/ "./interactive-layer/template.html":
/*!*****************************************!*\
  !*** ./interactive-layer/template.html ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div style=\\\"position: absolute; width: 100%; height: 100%; top: 0; left: 0;\\\">\\n<svg ng-class=\\\"{'edit-point': self.mode, 'add-point': self.shiftKey, 'del-point': self.altKey}\\\" \\n    style=\\\"margin: {{self.paddingStr();}};width:calc(100% - {{self.leftPadding() + self.rightPadding()}}px); height:calc(100% - {{self.bottomPadding() + self.topPadding()}}px)\\\"\\n    ng-mouseleave=\\\"self.onMouseLeave($event)\\\"\\n    ng-mouseup=\\\"self.onMouseUp($event)\\\"\\n    ng-mousedown=\\\"self.onMouseDown($event)\\\"\\n    ng-mousemove=\\\"self.onMouseMove($event)\\\">\\n    <g class=\\\"layer\\\">\\n        <polygon ng-points=\\\"{{self.getPoints()}}\\\" ng-fill=\\\"{{self.fillStyle}}\\\" ng-stroke=\\\"{{self.strokeStyle}}\\\" ng-stroke-width=\\\"{{self.strokeWidth}}\\\">\\n        </polygon>\\n        <g ng-if=\\\"self.showVertex\\\" class=\\\"sub-layer\\\" ng-repeat=\\\"p in self.points\\\" ng-offset=\\\"{{ self.vertexOffset(p, $index) }}\\\">\\n            <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"5\\\" ng-style='{fill:\\\"transparent\\\", stroke:\\\"green\\\", \\\"stroke-width\\\":1}'></circle>\\n            <text>\\n            {{self.getPointLabel(p)}} \\n            </text>\\n        </g>\\n        <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"5\\\" ng-style=\\\"self.draggerStyleFn()\\\" ng-offset=\\\"{{self.draggerOffset()}}\\\"></circle>\\n    </g>\\n</svg>\\n<div ng-if=\\\"self.showCoordinates\\\" class=\\\"status\\\" ng-bind=\\\"self.getCoordinates()\\\" ng-style=\\\"\\\"></div>\\n</div>\\n\";\n\n//# sourceURL=webpack:///./interactive-layer/template.html?");

/***/ }),

/***/ "./layer-collection/index.js":
/*!***********************************!*\
  !*** ./layer-collection/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = 'layerCollection';\nmodule.exports.name = name;\n__webpack_require__(/*! ./style.css */ \"./layer-collection/style.css\");\n\nangular.module(moduleName)\n    .component(name, {\n        controller: LayerCollectionController,\n        controllerAs: 'self',\n        template: __webpack_require__(/*! ./template.html */ \"./layer-collection/template.html\"),\n        bindings: {\n            padding: '<',\n            hPadding: '<',\n            vPadding: '<',\n            lPadding: '<',\n            rPadding: '<',\n            tPadding: '<',\n            bPadding: '<'\n        },\n        transclude: true\n    });\n\nfunction LayerCollectionController($timeout, $element, $scope) {\n    let self = this;\n    this.notiOpacity = 0;\n    this.msg = \"\";\n\n    this.tooltips = [];\n\n    this.$onInit = function() {\n        this.lPadding = this.leftPadding();\n        this.rPadding = this.rightPadding();\n        this.tPadding = this.topPadding();\n        this.bPadding = this.bottomPadding();\n        this.$timeout = $timeout;\n        this.$scope = $scope;\n    }\n    this.leftPadding = function(){\n        return this.lPadding || this.hPadding || this.padding || 0;\n    }\n    this.rightPadding = function(){\n        return this.rPadding || this.hPadding || this.padding || 0;\n    }\n    this.topPadding = function() {\n        return this.tPadding || this.vPadding || this.padding || 0;\n    }\n    this.bottomPadding = function() {\n        return this.bPadding || this.vPadding || this.padding || 0;\n    }\n    this.notify = function(msg, iconClass, duration) {\n        $timeout(() => {\n            this.notiOpacity = 1;\n            this.iconClass = iconClass || this.iconClass || 'ti-check';\n            this.msg = msg;\n        });\n        $timeout(() => {\n            this.notiOpacity = 0;\n        }, duration || 1000);\n    }\n    this.tooltip = function(on, msg) {\n        if (on) {\n            this.tooltips[0] = msg;\n        }\n        else {\n            this.tooltips.length = 0;\n        }\n    }\n    this.tooltipStyle = function() {\n        return {\n            bottom: 0, left: 0\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./layer-collection/index.js?");

/***/ }),

/***/ "./layer-collection/style.css":
/*!************************************!*\
  !*** ./layer-collection/style.css ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./style.css */ \"../node_modules/css-loader/dist/cjs.js!./layer-collection/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./layer-collection/style.css?");

/***/ }),

/***/ "./layer-collection/template.html":
/*!****************************************!*\
  !*** ./layer-collection/template.html ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div ng-transclude></div>\\n<div class=\\\"notification\\\">\\n    <div style=\\\"opacity: {{self.notiOpacity}};\\\">\\n        <span class=\\\"{{self.iconClass}}\\\"></span>\\n        <div style=\\\"font-size:14px;\\\">{{self.msg}}</div>\\n    </div>\\n</div>\\n\\n<div ng-show=\\\"self.tooltips.length\\\" class=\\\"tooltip\\\" ng-style=\\\"self.tooltipStyle();\\\">\\n    <div ng-repeat=\\\"line in self.tooltips\\\">{{line}}</div>\\n</div>\\n\";\n\n//# sourceURL=webpack:///./layer-collection/template.html?");

/***/ }),

/***/ "./line-bin-layer/index.js":
/*!*********************************!*\
  !*** ./line-bin-layer/index.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = \"lineBinLayer\";\nmodule.exports.name = name;\n\nvar AbstractLayer = __webpack_require__(/*! ../line-layer */ \"./line-layer/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\n\nvar layerCollection = __webpack_require__(/*! ../layer-collection */ \"./layer-collection/index.js\");\nangular.module(moduleName).component(name, component({\n    controller: LineBinLayerController, \n    bindings: { }\n}));\n\nfunction LineBinLayerController($timeout, $element, $scope) {\n    let self = this;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n    this.defaultBindings = function() {\n        this.lineStyleDefault();\n    }\n    this.$onInit = function() {\n        this.doInit();\n    }\n    this.getLine = function() {\n        let transform = this.getTransform();\n        let orthoTransform = this.getOrthoTransform();\n        let line = d3.line().curve(d3.curveBasis)\n            .x((d, i) => {\n                return transform((d.x0 + d.x1)/2);\n            })\n            .y((d, i) => {\n                return orthoTransform(d.length);\n            });\n        return line;\n    }\n    this.doAutofit = function() {\n        this.updateMaxY(d3.max(this.getData(), function(bin) {return bin.length;}));\n    }\n}\n\n\n//# sourceURL=webpack:///./line-bin-layer/index.js?");

/***/ }),

/***/ "./line-formula-layer/index.js":
/*!*************************************!*\
  !*** ./line-formula-layer/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = \"lineFormulaLayer\";\nmodule.exports.name = name;\n\nvar AbstractLayer = __webpack_require__(/*! ../line-layer */ \"./line-layer/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\nvar parseFormulaLatex = __webpack_require__(/*! ../common */ \"./common.js\").parseFormulaLatex;\n__webpack_require__(/*! ./style.css */ \"./line-formula-layer/style.css\");\n\nvar layerCollection = __webpack_require__(/*! ../layer-collection */ \"./layer-collection/index.js\");\nangular.module(moduleName).component(name, component({\n    controller: LFLayerController, \n    template: __webpack_require__(/*! ./template.html */ \"./line-formula-layer/template.html\"),\n    bindings: {\n        formula: \"<\",\n        resolution: \"<\",\n        eqnOffsets: \"<\",\n        showEquation: '<',\n        eqnName: \"<\",\n        inverted: \"<\",\n        mse: '<',\n        lineLabel: '<',\n        lineLabelStyle: '<'\n    }\n}));\nfunction LFLayerController($scope, $timeout, $element) {\n    let self = this;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n\n    this.watchProperties = this.watchProperties.concat([\n        \"resolution\",\n        \"eqnOffsets\",\n        \"inverted\",\n    ]);\n\n    this.defaultBindings = function() {\n        this.lineStyleDefault();\n        this.resolution = this.resolution || 50;\n        this.eqnOffsets = this.eqnOffsets || [0,0];\n        this.showEquation = this.showEquation || false;\n        this.formula = this.formula || {};\n        this.lineLabelStyle = this.lineLabelStyle || {};\n        this.prefixId = `Pickett-${self.label}-${Date.now()}`;\n    }\n    function showEquation() {\n        if (!self.showEquation) return;\n        let html = katex.renderToString(self.parseFormulaLatex(),{displayMode: false});\n        $element.find('.equation').empty().append(html);\n    }\n    function showMSE() {\n        if (!self.mse) return;\n        let html = katex.renderToString(self.parseMSELatex(),{displayMode: false});\n        $element.find('.mse').empty().append(html);\n    }\n\n    this.registerWatch(function() {\n        showEquation();\n        showMSE();\n    });\n    this.doAutofit = function() {\n        this.updateMaxY(d3.max(this.getData(), function(point) {return self.getY(point);}));\n    }\n    this.getLine = function() {\n        let transform = this.getTransform();\n        let orthoTransform = this.getOrthoTransform();\n        let line = d3.line().curve(d3.curveBasis)\n            .x((d, i) => {\n                return transform(self.getX(d));\n            })\n            .y((d, i) => {\n                return orthoTransform(self.getY(d));\n            })\n            .defined(function (d) {\n                return !isNaN(d.x) && !isNaN(d.y)                                   \n                    && d.y != Infinity && d.y != -Infinity                          \n                    && !isNaN(transform(d.x)) && !isNaN(orthoTransform(d.y))           \n                    && transform(d.x) != -Infinity && transform(d.x) != Infinity  \n                    && orthoTransform(d.y) != -Infinity && orthoTransform(d.y) != Infinity  \n            });\n        return line;\n    }\n\n    function parseFormula(formula) {\n        switch(formula.family) {\n            case \"linear\":\n                formula.text = `${formula.slope} * x + ${formula.intercept}`;\n                return function(x) {\n                    return formula.slope * x + formula.intercept;\n                }\n            case \"exponential\":\n                formula.text = `${formula.ae} * Math.exp(${formula.b} * x)`;\n                return function(x) {\n                    return formula.ae * Math.exp(formula.b*x);\n                }\n            case \"power\":\n                formula.text = `${formula.coefficient} * (x ** ${formula.exponent})`;\n                return function(x) {\n                    return formula.coefficient * (x ** formula.exponent);\n                }\n            case \"polynomial\":\n                return function(x) {\n                    return formula.predict(x)[1];\n                }\n            case \"pickett\":\n                return function(x) {\n                    //let result = Math.pow(10, (-formula.m) * (Math.log10(x) - Math.log10(formula.a*formula.rw) - Math.log10(1 / (formula.sw ** formula.n))));\n                    let result = Math.pow(10, (-formula.m) * (Math.log10(x)) + Math.log10((formula.a*formula.rw) / (formula.sw ** formula.n)));\n                    if (formula.isSwap) {\n                        result = Math.pow(10, (Math.log10(x) - (Math.log10((formula.a*formula.rw) / (formula.sw ** formula.n)))) / (-formula.m));\n                    }\n                    if (isNaN(result)) return undefined;\n                    return result;\n                }\n            default: return formula.fn;\n        }\n    }\n    this.parseFormulaLatex = function() {\n        return parseFormulaLatex(this.formula) || '';\n    }\n    this.parseMSELatex = function() {\n        return parseFormulaLatex(this.mse) || '';\n    }\n    /*\n    function parseFormulaLatex(formula) {\n        switch(formula.family) {\n            case \"linear\":\n                let intercept = formula.intercept;\n                return `y = ${formula.slope} \\\\times x ${intercept==0?'':(intercept<0 ? '-' + (-intercept):'+' + intercept)}`;\n            case \"exponential\":\n                return `y = ${formula.ae} \\\\times e^\\{${formula.b} x\\}`;\n\n        }\n    }*/\n\n    this.getData = function() {\n        if (!this.lineData || this._update) {\n            this._update = false;\n            this.lineData = [];\n            let f = parseFormula(this.formula);\n            if (!f) return this.lineData;\n            if (self.inverted) {\n                let step = (this.maxDrawY - this.minDrawY) / this.resolution;\n                for (let y = this.minDrawY; (y - this.minDrawY) * (y - this.maxDrawY) <= 0; y += step) {\n                    let x = f(y);\n                    if (!x) continue;\n                    if (this.autofit || (x - this.minDraw) * (x - this.maxDraw) <= 0)\n                        this.lineData.push({ x, y })\n                }\n            }\n            else {\n                let step = (this.maxDraw - this.minDraw) / this.resolution;\n                for (let x = this.minDraw; (x - this.minDraw) * (x - this.maxDraw) <= 0; x += step) {\n                    let y = f(x);\n                    if (!x) continue;\n                    if (this.autofit || (y - this.minDrawY) * (y - this.maxDrawY) <= 0)\n                        this.lineData.push({ x, y })\n                }\n            }\n        }\n        return this.lineData;\n    }\n    this.eqnStyle = function() {\n        return {\n            transform: 'translate(' + this.eqnOffsets[0] + \", \" + this.eqnOffsets[1] + \")\",\n            color: this.lineColor\n        }\n    }\n    this.eqnCopySuccess = function() {\n        console.log(\"Copy success\");\n        if (this.layerCollection) {\n            this.layerCollection.notify(\"Coppied\", 'ti-clip', 1000);\n        }\n    }\n    this.parentDraw = this.draw;\n    this.draw = function() {\n        self._update = true;\n        self.parentDraw();\n    }\n    this.labelOffset = function() {\n        let transform = self.getTransform();\n        let orthoTransform = self.getOrthoTransform();\n        const idx = 0;\n        let x = self.lineData[idx].x;\n        let y = self.lineData[idx].y;\n        if (_.isFinite(x) && _.isFinite(y)\n            && _.isFinite(transform(x)) && _.isFinite(orthoTransform(y))) {\n            return {\n                x: transform(x) + 7, \n                y: orthoTransform(y) - 7\n            }\n        }\n        return {x:0,y:0};\n    }\n    this.$onInit = function() {\n        $scope.$watch(function() {\n            return JSON.stringify(self.formula);\n        }, function () {\n            self._update = true;\n            self.drawOptimized();\n            showEquation();\n            showMSE();\n        });\n        this.doInit();\n    }\n}\n\n\n//# sourceURL=webpack:///./line-formula-layer/index.js?");

/***/ }),

/***/ "./line-formula-layer/style.css":
/*!**************************************!*\
  !*** ./line-formula-layer/style.css ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./style.css */ \"../node_modules/css-loader/dist/cjs.js!./line-formula-layer/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./line-formula-layer/style.css?");

/***/ }),

/***/ "./line-formula-layer/template.html":
/*!******************************************!*\
  !*** ./line-formula-layer/template.html ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div>\\n<svg style=\\\"margin: {{self.paddingStr();}};width:calc(100% - {{self.leftPadding() + self.rightPadding()}}px); height:calc(100% - {{self.topPadding() + self.bottomPadding()}}px)\\\">\\n    <g class=\\\"layer\\\">\\n        <path id='{{self.prefixId}}' fill='none' stroke=\\\"{{self.lineColor}}\\\" stroke-dasharray=\\\"{{self.lineDash}}\\\" stroke-width=\\\"{{self.lineWidth}}\\\" />\\n        <text ng-style=\\\"self.lineLabelStyle\\\" x=\\\"0\\\" y=\\\"0\\\">\\n            <textPath href=\\\"#{{self.prefixId}}\\\" startOffset='3%'>\\n                {{self.lineLabel}}\\n            </textPath>\\n        </text>\\n    </g>\\n</svg>\\n<div class=\\\"equation-holder\\\" ng-style='self.eqnStyle();'>\\n    <span ng-if=\\\"self.eqnName\\\">{{self.eqnName}}</span>\\n    <span ng-if=\\\"self.eqnName && self.showEquation\\\"> : </span>\\n    <span class='equation' ng-show=\\\"self.showEquation\\\"\\n        ngclipboard ngclipboard-success=\\\"self.eqnCopySuccess(e);\\\"\\n        data-clipboard-text=\\\"{{self.formula.text || self.parseFormulaLatex()}}\\\">\\n    </span>\\n    <span ng-if=\\\"self.mse\\\">; </span>\\n    <span class='mse' ng-if=\\\"self.mse\\\"\\n        ngclipboard data-clipboard-text=\\\"{{self.parseMSELatex()}}\\\">\\n    </span>\\n</div>\\n\";\n\n//# sourceURL=webpack:///./line-formula-layer/template.html?");

/***/ }),

/***/ "./line-gaussian-layer/index.js":
/*!**************************************!*\
  !*** ./line-gaussian-layer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = \"lineGaussianLayer\";\nmodule.exports.name = name;\n\nvar AbstractLayer = __webpack_require__(/*! ../line-layer */ \"./line-layer/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\n__webpack_require__(/*! ./style.css */ \"./line-gaussian-layer/style.css\");\n\nvar layerCollection = __webpack_require__(/*! ../layer-collection */ \"./layer-collection/index.js\");\nangular.module(moduleName).component(name, component({\n    controller: LGLayerController, \n    template: __webpack_require__(/*! ./template.html */ \"./line-gaussian-layer/template.html\"),\n    bindings: {\n        mean: \"<\",\n        sigma: \"<\",\n        resolution: \"<\",\n        lineColorSecond: \"<\",\n        lineWidthSecond: \"<\",\n        lineDashSecond: \"<\"\n    }\n}));\nfunction LGLayerController($scope, $timeout, $element) {\n    let self = this;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n\n    this.watchProperties = this.watchProperties.concat([\n        \"mean\",\n        \"sigma\",\n        \"resolution\",\n        \"lineColorSecond\",\n        \"lineWidthSecond\",\n        \"lineDashSecond\"\n    ]);\n\n    this.defaultBindings = function() {\n        this.lineColorSecond = this.lineColorSecond || this.lineColor || \"purple\";\n        this.lineDashSecond = this.lineDashSecond || this.lineDash || \"5 3\";\n        this.lineWidthSecond = this.lineWidthSecond || this.lineWidth || 1;\n        this.resolution = this.resolution || 500;\n        this.mean = this.mean || 0;\n        this.sigma = this.sigma || 1;\n        this.lineStyleDefault();\n    }\n    this.doAutofit = function() {\n        this.updateMaxY(d3.max(this.getData(), function(point) {return self.getY(point);}));\n    }\n\n    this.watchProperties = this.watchProperties.concat(['mean', 'sigma', \n        'resolution', 'lineColorSecond', 'lineWidthSecond', 'lineDashSecond'\n    ]);\n    this.getLine = function() {\n        let transform = this.getTransform();\n        let orthoTransform = this.getOrthoTransform();\n        let line = d3.line().curve(d3.curveBasis)\n            .x((d, i) => {\n                return transform(self.getX(d));\n            })\n            .y((d, i) => {\n                return orthoTransform(self.getY(d));\n            });\n        return line;\n    }\n\n    //taken from Jason Davies science library\n    // https://github.com/jasondavies/science.js/\n    function gaussian(x, mean, sigma) {\n        let gaussianConstant = 1 / Math.sqrt(2 * Math.PI);\n\n        x = (x - mean) / sigma;\n        return gaussianConstant * Math.exp(-.5 * x * x) / sigma;\n    }\n\n    function normal(mean, sigma) {\n        let x = 0, y = 0, rds, c;\n        let xSample;\n        do {\n            do {\n                x = (Math.random() * 2 - 1);\n                y = (Math.random() * 2 - 1);\n                rds = x * x + y * y;\n            } while (rds == 0 || rds > 1);\n            c = Math.sqrt(-2 * Math.log(rds) / rds); // Box-Muller transform\n            xSample = mean + sigma * x * c;\n        } while ((xSample - self.minVal)*(xSample - self.maxVal) > 0 );\n\n        return xSample;\n    }\n\n    function getData(numSamples, mean, sigma) {\n        let x,y;\n        let data = new Array();\n        x = self.minVal;\n        y = gaussian(x, mean, sigma);\n        data.push({x, y});\n        x = self.maxVal;\n        y = gaussian(x, mean, sigma);\n        data.push({x, y});\n        for (let i = 0; i < numSamples; i++) {\n            x = normal(mean, sigma); // calc random draw from normal dist\n            y = gaussian(x, mean, sigma) // calc prob of rand draw\n            data.push({x, y});\n        };\n        // need to sort for plotting\n        data.sort(function (x, y) {\n            return x.x - y.x;\n        });\n        return data;\n    }\n    \n    this.getData = function() {\n        return getData(this.resolution, this.mean, this.sigma);\n    }\n    this.$onInit = function() {\n        this.doInit();\n    }\n    this.sigmaLineStyle = function() {\n        return {\n            \"stroke\": this.lineColorSecond,\n            \"stroke-width\": this.lineWidthSecond,\n            \"stroke-dasharray\": this.lineDashSecond\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./line-gaussian-layer/index.js?");

/***/ }),

/***/ "./line-gaussian-layer/style.css":
/*!***************************************!*\
  !*** ./line-gaussian-layer/style.css ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./style.css */ \"../node_modules/css-loader/dist/cjs.js!./line-gaussian-layer/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./line-gaussian-layer/style.css?");

/***/ }),

/***/ "./line-gaussian-layer/template.html":
/*!*******************************************!*\
  !*** ./line-gaussian-layer/template.html ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div>\\n<svg style=\\\"margin: {{self.paddingStr();}};width:calc(100% - {{self.leftPadding() + self.rightPadding()}}px); height:calc(100% - {{self.topPadding() + self.bottomPadding()}}px)\\\">\\n    <g class=\\\"layer\\\">\\n        <path fill='none' stroke=\\\"{{self.lineColor}}\\\" stroke-dasharray=\\\"{{self.lineDash}}\\\" stroke-width=\\\"{{self.lineWidth}}\\\" />\\n        <line ng-x1=\\\"{{self.getTransform()(self.mean - self.sigma)}}\\\" ng-y1=\\\"0\\\" \\n            ng-x2=\\\"{{self.getTransform()(self.mean - self.sigma)}}\\\" \\n            ng-y2=\\\"{{self.contentHeight(true);}}\\\"\\n            ng-style=\\\"self.sigmaLineStyle()\\\" />\\n        <line ng-x1=\\\"{{self.getTransform()(self.mean + self.sigma)}}\\\" ng-y1=\\\"0\\\" \\n            ng-x2=\\\"{{self.getTransform()(self.mean + self.sigma)}}\\\" \\n            ng-y2=\\\"{{self.contentHeight(true);}}\\\" \\n            ng-style=\\\"self.sigmaLineStyle()\\\" />\\n    </g>\\n</svg>\\n</div>\\n\\n\";\n\n//# sourceURL=webpack:///./line-gaussian-layer/template.html?");

/***/ }),

/***/ "./line-layer/index.js":
/*!*****************************!*\
  !*** ./line-layer/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const name = \"lineLayer\";\nmodule.exports.name = name;\nmodule.exports.klass = LineLayerController;\nmodule.exports.component = buildComponent;\n\n__webpack_require__(/*! ./style.css */ \"./line-layer/style.css\");\nvar AbstractLayer = __webpack_require__(/*! ../abstract-layer-2d */ \"./abstract-layer-2d/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\n\nfunction buildComponent(componentData) {\n    componentData.template = componentData.template || __webpack_require__(/*! ./template.html */ \"./line-layer/template.html\");\n    componentData.bindings = {\n        lineColor: \"<\",\n        lineDash: \"<\",\n        lineWidth: \"<\",\n        lineData: \"<\",\n        getX : \"<\",\n        getY : \"<\",\n        ...componentData.bindings\n    }\n    return component(componentData);\n}\n\nfunction LineLayerController($timeout, $element, $scope) {\n    let self = this;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n\n    this.watchProperties = this.watchProperties.concat([\n        \"lineColor\",\n        \"lineDash\",\n        \"lineWidth\"\n    ]);\n    this.lineStyleDefault = function () {\n        this.twoDBindings();\n        this.lineColor = this.lineColor || 'black';\n        this.lineDash = this.lineDash || \"0\";\n        this.lineWidth = this.lineWidth || 1;\n        this.getX = typeof(this.getX) === \"function\" ? this.getX: (d) => {return d.x;};\n        this.getY = typeof(this.getY) === \"function\" ? this.getY: (d) => {return d.y;};\n    }\n    this.getLine = function() {\n        console.error(\"Abstract getLine\");\n    }\n    this.getData = function() {\n        return this.lineData;\n    }\n    this.draw = draw;\n    function draw() {\n        let line = this.getLine();\n        const data = this.getData() || [];\n        d3.select($element.find('path')[0])\n            .datum(data)\n            .attr('d', line);\n    }\n}\n\n\n//# sourceURL=webpack:///./line-layer/index.js?");

/***/ }),

/***/ "./line-layer/style.css":
/*!******************************!*\
  !*** ./line-layer/style.css ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./style.css */ \"../node_modules/css-loader/dist/cjs.js!./line-layer/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./line-layer/style.css?");

/***/ }),

/***/ "./line-layer/template.html":
/*!**********************************!*\
  !*** ./line-layer/template.html ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div>\\n<svg style=\\\"margin: {{self.paddingStr();}};width:calc(100% - {{self.leftPadding() + self.rightPadding()}}px); height:calc(100% - {{self.topPadding() + self.bottomPadding()}}px)\\\">\\n    <g class=\\\"layer\\\">\\n        <path fill='none' stroke=\\\"{{self.lineColor}}\\\" stroke-dasharray=\\\"{{self.lineDash}}\\\" stroke-width=\\\"{{self.lineWidth}}\\\" />\\n    </g>\\n</svg>\\n</div>\\n\\n\";\n\n//# sourceURL=webpack:///./line-layer/template.html?");

/***/ }),

/***/ "./line-point-layer/index.js":
/*!***********************************!*\
  !*** ./line-point-layer/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = \"linePointLayer\";\nmodule.exports.name = name;\n\nvar AbstractLayer = __webpack_require__(/*! ../line-layer */ \"./line-layer/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\n\nvar layerCollection = __webpack_require__(/*! ../layer-collection */ \"./layer-collection/index.js\");\nangular.module(moduleName).component(name, component({\n    controller: LPLayerController, \n    bindings: {\n    }\n}));\nfunction LPLayerController($scope, $timeout, $element) {\n    let self = this;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n    this.watchProperties = this.watchProperties.concat([\n        \"lineData\",\n    ]);\n    this.defaultBindings = function() {\n        this.lineStyleDefault();\n    }\n    this.doAutofit = function() {\n        this.updateMaxY(d3.max(this.getData(), function(point,i) {return self.getY(point,i);}));\n    }\n    this.getLine = function() {\n        let transform = this.getTransform();\n        let orthoTransform = this.getOrthoTransform();\n        let line = d3.line().curve(d3.curveBasis)\n            .x((d, i) => {\n                return transform(self.getX(d, i));\n            })\n            .y((d, i) => {\n                return orthoTransform(self.getY(d, i));\n            })\n            .defined(function (d, i) {\n                let x = self.getX(d, i);\n                let y = self.getY(d, i);\n                return !isNaN(x) && !isNaN(y)\n                    && y != Infinity && y != -Infinity\n                    && !isNaN(transform(x)) && !isNaN(orthoTransform(y))\n                    && transform(x) != -Infinity && transform(x) != Infinity\n                    && orthoTransform(y) != -Infinity && orthoTransform(y) != Infinity\n            });\n        return line;\n    }\n    this.$onInit = function() {\n        this.doInit();\n    }\n}\n\n\n//# sourceURL=webpack:///./line-point-layer/index.js?");

/***/ }),

/***/ "./overlay-line-layer/index.js":
/*!*************************************!*\
  !*** ./overlay-line-layer/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = \"overlayLineLayer\";\nmodule.exports.name = name;\n\nvar AbstractLayer = __webpack_require__(/*! ../abstract-layer-2d */ \"./abstract-layer-2d/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\n\nconst CanvasHelper = __webpack_require__(/*! ../canvas-helper */ \"./canvas-helper.js\");\nvar layerCollection = __webpack_require__(/*! ../layer-collection */ \"./layer-collection/index.js\");\nfunction buildComponent(componentData) {\n    componentData.controller = componentData.controller || OverlayLineController;\n    componentData.template = componentData.template || __webpack_require__(/*! ./template.html */ \"./overlay-line-layer/template.html\");\n    componentData.bindings = {\n        overlayLineSpec: '<',\n        ...componentData.bindings\n    }\n    return component(componentData);\n}\nangular.module(moduleName).component(name, buildComponent({}));\nfunction OverlayLineController($scope, $timeout, $element) {\n    let self = this;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n    this.watchProperties = this.watchProperties.concat([\n        \"overlayLineSpec\",\n    ]);\n    let _canvas;\n    function getCanvas() {\n        if (_canvas) return _canvas;\n        _canvas = $element.find('canvas')[0];\n        return _canvas;\n    }\n    function drawTick(startX, startY, endX, endY, length, helper, position, options) {\n        let fullLength = Math.sqrt((startX - endX)**2 + (startY - endY)**2);\n        let factor = Math.ceil(fullLength / length);\n        startX = startX - (endX - startX)/(factor * 2);\n        startY = startY - (endY - startY)/(factor * 2);\n        let stopX = startX + (endX - startX)/factor;\n        let stopY = startY + (endY - startY)/factor;\n        let point1 = {x: startX, y: startY};\n        let point2 = {x: stopX, y: stopY};\n        let rotatePoint;\n        if (position === 'start') {\n            rotatePoint = {x: startX, y: startY};\n        } else if (position === 'end') {\n            rotatePoint = {x: endX, y: endY};\n        } else {\n            rotatePoint = {x: (startX + stopX) / 2, y: (startY + stopY) / 2};\n        }\n        moveToOrigin(point1, rotatePoint);\n        moveToOrigin(point2, rotatePoint);\n        rotate(point1);\n        rotate(point2);\n        moveToOriginInv(point1, rotatePoint);\n        moveToOriginInv(point2, rotatePoint);\n        helper.segment(point1, point2, options);\n        function moveToOrigin(point, center) {\n            point.x -= center.x;\n            point.y -= center.y;\n        }\n        function moveToOriginInv(point, center) {\n            point.x += center.x;\n            point.y += center.y;\n        }\n        function rotate(point) {\n            let x = point.x;\n            let y = point.y;\n            point.x = -y;\n            point.y = x;\n        }\n    }\n    this.draw = function() {\n        let transform = this.getTransform();\n        let othorTransform = this.getOrthoTransform();\n        canvas = getCanvas();\n        canvas.width = this.contentWidth();\n        canvas.height = this.contentHeight();\n        if (canvas.width === 0 || canvas.height === 0) return;\n        let ctx = canvas.getContext('2d');\n        let penDefaultCfg = {\n            size: 10,\n            fillStyle: 'Yellow',\n            strokeStyle: 'Green',\n            strokeWidth: 2\n        }\n        let getTextCfg = (point) => ({\n            textSize: 15,\n            textContent: point.type,\n            fillStyle: point.color || 'Black',\n        }) \n        let helper = new CanvasHelper(ctx, penDefaultCfg);\n        self.overlayLineSpec.lines.forEach(line => {\n            let fillStyle = line.color.replace('Dk', 'Dark') || getLineColor(line.names) || penDefaultCfg.strokeStyle;\n            let strokeStyle = line.color.replace('Dk', 'Dark') || getLineColor(line.names) || penDefaultCfg.strokeStyle;\n            let lineWidth = penDefaultCfg.strokeWidth;\n            ctx.beginPath();\n            ctx.fillStyle = fillStyle;\n            ctx.strokeStyle = strokeStyle;\n            ctx.lineWidth = lineWidth;\n            line.data = line.data.filter(point => {\n                return point.x != '-' || point.y != '-';\n            })\n            line.data.forEach((point, pIdx, pointArr) => {\n                let startX = transform(parseFloat(point.x));\n                let startY = othorTransform(parseFloat(point.y));\n                if (!pointArr[pIdx + 1]) {\n                    let preX = transform(parseFloat(pointArr[pIdx - 1].x));\n                    let preY = othorTransform(parseFloat(pointArr[pIdx - 1].y));\n                    let endX = preX + (startX - preX) * 2;\n                    let endY = preY + (startY - preY) * 2;\n                    drawTick(startX, startY, endX, endY, 10, helper, 'center', {fillStyle, strokeStyle, lineWidth});\n                    if (!isNaN(point.type)) {\n                        helper.textSymbol(startX + 7, startY + 5, getTextCfg(point));\n                    }\n                    ctx.stroke();\n                    return;\n                }\n                let endX = transform(parseFloat(pointArr[pIdx + 1].x));\n                let endY = othorTransform(parseFloat(pointArr[pIdx + 1].y));\n                drawTick(startX, startY, endX, endY, 10, helper, 'center', {fillStyle, strokeStyle, lineWidth});\n                ctx.moveTo(startX, startY);\n                ctx.lineTo(endX, endY);\n                if (pIdx == 0) {\n                    helper.textSymbol(startX - 20, startY - 20, getTextCfg({\n                        type: line.names,\n                        color: line.color.replace('Dk', 'Dark') || getLineColor(line.names) \n                    }));\n                }\n                if (!isNaN(point.type)) {\n                    helper.textSymbol(startX + 7, startY + 5, getTextCfg({\n                        ...point,\n                    }));\n                }\n                ctx.stroke();\n            })\n        })\n    }\n    function getLineColor(name) {\n        let color;\n        if (name == 'SS') color = 'Green';                               \n        if (name == 'LS') color = 'Blue';                                \n        if (name == 'DOL') color = 'Pink';                               \n        return color;\n    }\n    this.defaultBindings = function() {\n        self.overlayLineSpec = self.overlayLineSpec || {};\n    }\n    this.$onInit = function() {\n        this.doInit();\n    }\n}\n\n\n//# sourceURL=webpack:///./overlay-line-layer/index.js?");

/***/ }),

/***/ "./overlay-line-layer/template.html":
/*!******************************************!*\
  !*** ./overlay-line-layer/template.html ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div>\\n<canvas style=\\\"margin: {{self.paddingStr();}};width:calc(100% - {{self.leftPadding() + self.rightPadding()}}px); height:calc(100% - {{self.topPadding() + self.bottomPadding()}}px)\\\">\\n</canvas>\\n</div>\\n\";\n\n//# sourceURL=webpack:///./overlay-line-layer/template.html?");

/***/ }),

/***/ "./plot-toolkit-module.js":
/*!********************************!*\
  !*** ./plot-toolkit-module.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const moduleName = 'plot-toolkit';\nangular.module(moduleName, [ 'ngclipboard', /*'katexView'*/ ])\n    .directive('ngOffset', function() {\n        return function(scope, elem, attrs) {\n            attrs.$observe('ngOffset', function(o) {\n                let offset = JSON.parse(o);\n                elem.attr('transform', `translate(${offset.x}, ${offset.y})`);\n            });\n        };\n    })\n    .directive(\"ngPoints\", function() {\n        return function(scope, elem, attrs) {\n            attrs.$observe(\"ngPoints\", function(pointsS) {\n                let pointsStr = \"\";\n                let points = JSON.parse(pointsS);\n                for (let p of points) {\n                    pointsStr += `${p.x},${p.y} `;\n                }\n                elem.attr(\"points\", pointsStr);\n            });\n        }\n    })\n    .directive('ngX', function() {\n        return function(scope, elem, attrs) {\n            attrs.$observe('ngX', function(x) {\n                elem.attr('x', x);\n            });\n        };\n    })\n    .directive('ngY', function() {\n        return function(scope, elem, attrs) {\n            attrs.$observe('ngY', function(y) {\n                elem.attr('y', y);\n            });\n        };\n    })\n    .directive('ngWidth', function() {\n        return function(scope, elem, attrs) {\n            attrs.$observe('ngWidth', function(width) {\n                elem.attr('width', width);\n            });\n        };\n    })\n    .directive('ngHeight', function() {\n        return function(scope, elem, attrs) {\n            attrs.$observe('ngHeight', function(height) {\n                elem.attr('height', height);\n            });\n        };\n    })\n    .directive('ngFill', function() {\n        return function(scope, elem, attrs) {\n            attrs.$observe('ngFill', function(fill){\n                elem.attr('fill', fill);\n            });\n        };\n    })\n    .directive('ngX1', function() {\n        return function(scope, elem, attrs) {\n            attrs.$observe('ngX1', function(fill){\n                elem.attr('x1', fill);\n            });\n        };\n    })\n    .directive('ngX2', function() {\n        return function(scope, elem, attrs) {\n            attrs.$observe('ngX2', function(fill){\n                elem.attr('x2', fill);\n            });\n        };\n    })\n    .directive('ngY1', function() {\n        return function(scope, elem, attrs) {\n            attrs.$observe('ngY1', function(fill){\n                elem.attr('y1', fill);\n            });\n        };\n    })\n    .directive('ngY2', function() {\n        return function(scope, elem, attrs) {\n            attrs.$observe('ngY2', function(fill){\n                elem.attr('y2', fill);\n            });\n        };\n    })\n    .directive('ngR', function() {\n        return function(scope, elem, attrs) {\n            attrs.$observe('ngR', function(r){\n                elem.attr('r', r);\n            });\n        };\n    })\n    .directive('ngStroke', function() {\n        return function(scope, elem, attrs) {\n            attrs.$observe('ngStroke', function(strokeColor){\n                elem.attr('stroke', strokeColor);\n            });\n        };\n    })\n    .directive('ngStrokeWidth', function() {\n        return function(scope, elem, attrs) {\n            attrs.$observe('ngStrokeWidth', function(strokeWidth){\n                elem.attr('stroke-width', strokeWidth);\n            });\n        };\n    });\n\n\n//# sourceURL=webpack:///./plot-toolkit-module.js?");

/***/ }),

/***/ "./polygon-layer/index.js":
/*!********************************!*\
  !*** ./polygon-layer/index.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = 'polygonLayer';\nmodule.exports.name = name;\n\nvar AbstractLayer = __webpack_require__(/*! ../interactive-layer */ \"./interactive-layer/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\nconst _ = __webpack_require__(/*! lodash */ \"../node_modules/lodash/lodash.js\");\n\nvar layerCollection = __webpack_require__(/*! ../layer-collection */ \"./layer-collection/index.js\");\nangular.module(moduleName)\n    .component(name, component({\n        controller: PolygonLayerController,\n        bindings: { }\n    }));\n\nfunction PolygonLayerController($timeout, $element, $scope) {\n    let self = this;\n    let dragging = false;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n\n    this.$onInit = function() {\n        this.doInit();\n    }\n    this.defaultBindings = function() {\n        this.interactiveBindings();\n    }\n    this.doAutofit = function() { }\n    this.draw = function() { }\n    this.mouseDownAddPoint = function($event) {\n        let transformX = this.getTransform();\n        let transformY = this.getOrthoTransform();\n        let x = $event.offsetX;\n        let y = $event.offsetY;\n        let result = this.findClosest({x,y}, this.points, transformX, transformY);\n        if (!_.isFinite(result.idx)) this.points.push({x:transformX.invert(x), y:transformY.invert(y)});\n        else if (this.points.length === 1) {\n            this.points.push({x:transformX.invert(x), y:transformY.invert(y)});\n        }\n        else {\n            let prevIdx = (result.idx + 1) % this.points.length;\n            let nextIdx = (result.idx + this.points.length - 1) % this.points.length;\n            let prevDist = this.distance({x,y}, {p: this.points[prevIdx], idx: prevIdx}, transformX, transformY);\n            let nextDist = this.distance({x,y}, {p:this.points[nextIdx], idx: nextIdx}, transformX, transformY);\n            if (prevDist < nextDist) {\n                this.points.splice(prevIdx, 0, {x:transformX.invert(x), y:transformY.invert(y)});\n            }\n            else {\n                this.points.splice(result.idx, 0, {x:transformX.invert(x), y:transformY.invert(y)});\n            }\n        }\n    }\n    this.mouseDownDelPoint = function($event) {\n        if (_.isFinite(this.editPointIdx)) {\n            this.points.splice(this.editPointIdx, 1);\n            this.editPointIdx = undefined;\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./polygon-layer/index.js?");

/***/ }),

/***/ "./rose-layer/index.js":
/*!*****************************!*\
  !*** ./rose-layer/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = \"roseLayer\";\nmodule.exports = {\n    name: name,\n    component: component,\n    klass: RoseLayerController\n}\n\nfunction component(componentData = {}) {\n    return {\n        controller: componentData.controller || RoseLayerController,\n        controllerAs: componentData.controllerAs || 'self',\n        template: componentData.template || __webpack_require__(/*! ./template.html */ \"./rose-layer/template.html\"),\n        bindings: {\n            plotId: '<',\n            roseData: '<',\n            roseColors: '<',\n            labels: '<',\n            labelsPosition: '<',\n            tooltips: '<',\n            labelsAxesColor: '<',\n            labelsAxesCount: '<',\n            colorStroke: '<',\n            showAxes: '<',\n            arcMargin: '<',\n            scaleMax: '<',\n            scaleDecimals: '<',\n            backgroundGridCirclesCount: '<',\n            cvsWidth: '<',\n            cvsHeight: '<',\n            ...((componentData || {}).bindings || {})\n        }\n    }\n}\n\nangular.module(moduleName).component(name, component());\n\nfunction RoseLayerController($scope, $element, $timeout) {\n    let self = this;\n    this.canvasId = this.plotId || 'cvs';\n\n    this.watchProperties = [\n        'roseData',\n        'roseColors',\n        'labels',\n        'labelsPosition',\n        'tooltips',\n        'labelsAxesColor',\n        'labelsAxesCount',\n        'colorStroke',\n        'showAxes',\n        'arcMargin',\n        'scaleMax',\n        'scaleDecimals',\n        'backgroundGridCirclesCount'\n    ]\n    this.activateWatch = function() {\n        $scope.$watch(function() {\n            return self.watchProperties.map((prop) => (self[prop]));\n        }, function() {\n            self.redraw();\n        }, true);\n    }\n    this.doInit = function() {\n        self.cvsWidth = self.cvsWidth || 600;\n        self.cvsHeight = self.cvsHeight || 400;\n        self.activateWatch();\n    }\n    this.$onInit = function() {\n        self.doInit();\n    }\n\n    function getRoseCfg() {\n        return {\n            id: self.canvasId,\n            data: self.roseData || [],\n            options: {\n                colors: self.roseColors || [],\n                gutterBottom: 35,\n                margin: self.arcMargin || 0,\n                labels: self.labels || [],\n                labelsAxes: 'n',\n                textAccessible: false,\n                tooltips: self.tooltips || false,\n                axes: self.showAxes || false,\n                labelsAxesColor: self.labelsAxesColor || 'red',\n                labelsAxesCount: self.labelsAxesCount || 3,\n                colorStroke: self.colorStroke || 'transprent',\n                labelsPosition: self.labelsPosition || 'edge',\n                scaleMax: self.scaleMax || null,\n                scaleDecimals: self.scaleDecimals || 1,\n                backgroundGridCirclesCount: self.backgroundGridCirclesCount || 3\n            }\n        }\n    }\n\n    this.redraw = function()  {\n        if (!self.roseData || !self.roseData.length) return;\n        $timeout(() => {\n            RGraph.clear(document.getElementById(self.canvasId));\n            self.rose = new RGraph.Rose(getRoseCfg());\n            self.rose.draw();\n        })\n    }\n}\n\n\n//# sourceURL=webpack:///./rose-layer/index.js?");

/***/ }),

/***/ "./rose-layer/template.html":
/*!**********************************!*\
  !*** ./rose-layer/template.html ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<canvas id=\\\"{{ self.plotId || 'cvs' }}\\\" width=\\\"{{ self.cvsWidth }}\\\" height=\\\"{{ self.cvsHeight }}\\\"></canvas>\\n\";\n\n//# sourceURL=webpack:///./rose-layer/template.html?");

/***/ }),

/***/ "./rscatter-rose-layer/index.js":
/*!**************************************!*\
  !*** ./rscatter-rose-layer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = \"rscatterRoseLayer\";\nmodule.exports.name = name;\n\n\nvar AbstractLayer = __webpack_require__(/*! ../rose-layer */ \"./rose-layer/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\n\nangular.module(moduleName).component(name, component({\n    controller: RscatterRoseLayerController, \n    bindings: {\n        rscatterData: '<',\n        tickmarks: '<',\n        tickmarksSize: '<',\n        rscatterLabelsAxesCount: '<',\n        rscatterBackgroundGridCirclesCount: '<'\n    }\n}));\n\nfunction RscatterRoseLayerController($scope, $element, $timeout) {\n    let self = this;\n    AbstractLayerController.call(this, $scope, $element, $timeout);\n\n    this.watchProperties = this.watchProperties.concat([\n        'rscatterData',\n        'tickmarks',\n        'tickmarksSize',\n        'rscatterLabelsAxesCount',\n        'rscatterBackgroundGridCirclesCount'\n    ]);\n\n    this.$onInit = function() {\n        self.doInit($scope, $element, $timeout);\n    }\n\n    function getRscatterCfg() {\n        return {\n            id: self.canvasId,\n            data: self.rscatterData || [],\n            options: {\n                labelsAxes: 'n',\n                tickmarks: self.tickmarks || 'circle',\n                tickmarksSize: self.tickmarksSize || 10,\n                labelsAxesCount: self.rscatterLabelsAxesCount || 0,\n                backgroundGridCirclesCount: self.rscatterBackgroundGridCirclesCount || 0,\n                scaleMax: self.scaleMax\n            }\n        }\n    }\n\n    this.parentRedraw = this.redraw;\n    this.redraw = function() {\n        self.parentRedraw.call(this);\n        if (!self.rscatterData || !self.rscatterData.length) return;\n        $timeout(() => {\n            self.scatter = new RGraph.RScatter(getRscatterCfg());\n            self.scatter.draw();\n        })\n    }\n}\n\n\n//# sourceURL=webpack:///./rscatter-rose-layer/index.js?");

/***/ }),

/***/ "./scatter-layer/index.js":
/*!********************************!*\
  !*** ./scatter-layer/index.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = \"scatterLayer\";\nmodule.exports.name = name;\n\n\nvar AbstractLayer = __webpack_require__(/*! ../abstract-layer-2d */ \"./abstract-layer-2d/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\n\nvar isFinite = __webpack_require__(/*! lodash */ \"../node_modules/lodash/lodash.js\").isFinite;\n\nvar layerCollection = __webpack_require__(/*! ../layer-collection */ \"./layer-collection/index.js\");\nvar CanvasHelper = __webpack_require__(/*! ../canvas-helper */ \"./canvas-helper.js\");\nangular.module(moduleName).component(name, component({\n    controller: ScatterLayerController, \n    template: __webpack_require__(/*! ./template.html */ \"./scatter-layer/template.html\"),\n    bindings: {\n        myDataX: \"<\",\n        myDataY: \"<\",\n        colorFunc: \"<\",\n        pointSizeFunc: \"<\",\n        symbolFunc: \"<\",\n        symbol: \"<\",\n        symbolSize: \"<\",\n        symbolFillStyle: \"<\",\n        symbolStrokeStyle: \"<\",\n        symbolStyle: \"<\",\n        getVal: \"<\",\n        getX: \"<\",\n        getY: \"<\"\n    }\n}));\n\nfunction ScatterLayerController($timeout, $element, $scope) {\n    let self = this;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n\n    this.watchProperties = this.watchProperties.concat([\n        \"symbol\",\n        \"symbolSize\",\n        \"symbolFillStyle\",\n        \"symbolStrokeStyle\",\n    ]);\n    this.defaultBindings = function() {\n        this.pointSizeFunc = checkFn(this.pointSizeFunc) || function(d, i) {return 9;};\n        this.getX = checkFn(this.getX) || checkFn(this.getVal) || asIs;\n        this.getY = checkFn(this.getY) || checkFn(this.getVal) || asIs;\n        this.symbol = this.symbol || 'circle';\n        this.symbolSize = this.symbolSize || 5;\n        this.symbolFillStyle = this.symbolFillStyle || 'blue';\n        this.symbolStrokeStyle = this.symbolStrokeStyle || 'blue';\n        this.colorFunc = checkFn(this.colorFunc) || function (d, i) {\n            return self.symbolFillStyle || \"blue\";\n        };\n        this.symbolFunc= checkFn(this.symbolFunc) || function (d, i) {\n            return null;\n        };\n    }\n    this.$onInit = function() {\n        $scope.$watch(function() {\n            return self.myDataX;\n        }, function() {\n            self.getPoints(true);\n            self.draw();\n        });\n        $scope.$watch(function() {\n            return self.myDataY;\n        }, function() {\n            self.getPoints(true);\n            self.draw();\n        });\n        this.doInit();\n    }\n    this.doAutofit = function() {\n        this.updateMaxY(d3.max(this.myDataY, function(point) {return self.getY(point, i)}));\n    }\n    this.getPoints = function(update) {\n        if (!update && this.points) return this.points;\n        this.points = [];\n        if (this.myDataX && this.myDataX.length && this.myDataY && this.myDataY.length) {\n            let n = Math.max(this.myDataX.length, this.myDataY.length);\n            for (let i = 0; i < n; i++) {\n                let x = this.getX(this.myDataX[i], i);\n                let y = this.getY(this.myDataY[i], i);\n                if (isFinite(x) && isFinite(y)) {\n                    this.points.push({\n                        fillStyle: this.colorFunc({x, y}, i),\n                        size: this.pointSizeFunc({x, y}, i),\n                        symbolStyle: this.symbolFunc({x, y}, i),\n                        idx: i, x, y\n                    });\n                }\n            }\n        }\n        return this.points;\n    }\n    let _canvas;\n    function getCanvas() {\n        if (_canvas) return _canvas;\n        _canvas = $element.find('canvas')[0];\n        return _canvas;\n    }\n    function isNullRange(transform) {\n        let range = transform.range();\n        return !(range[1] - range[0]);\n    }\n    this.draw = function() {\n        let transformX = this.getTransform();\n        let transformY = this.getOrthoTransform();\n        if (isNullRange(transformX) || isNullRange(transformY)) return;\n        canvas = getCanvas();\n        canvas.width = this.contentWidth();\n        canvas.height = this.contentHeight();\n        let ctx = canvas.getContext('2d');\n        let symbolDefaultCfg = {\n            size: this.symbolSize,\n            fillStyle: this.symbolFillStyle,\n            strokeStyle: this.symbolStrokeStyle,\n            ...this.symbolStyle,\n        }\n        let helper = new CanvasHelper(ctx, symbolDefaultCfg);\n        let plotFunc = helper[this.symbol];\n        let points = this.getPoints();\n        for (let p of points) {\n            plotFunc.call(helper, transformX(p.x), transformY(p.y), {\n                fillStyle: p.fillStyle,\n                pointSize: p.size / 4,\n                textSize: this.pointSizeFunc ? p.size * 1.5 : p.size / 4 * 1.5,\n                textContent: p.symbolStyle\n            });\n        }\n    }\n}\nfunction asIs(d,i) {\n    return d;\n}\nfunction checkFn(f) {\n    return typeof(f) === \"function\" ? f : null;\n}\n\n\n\n//# sourceURL=webpack:///./scatter-layer/index.js?");

/***/ }),

/***/ "./scatter-layer/template.html":
/*!*************************************!*\
  !*** ./scatter-layer/template.html ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div>\\n<canvas style=\\\"margin: {{self.paddingStr();}};width:calc(100% - {{self.leftPadding() + self.rightPadding()}}px); height:calc(100% - {{self.topPadding() + self.bottomPadding()}}px)\\\">\\n</canvas>\\n</div>\\n\\n\";\n\n//# sourceURL=webpack:///./scatter-layer/template.html?");

/***/ }),

/***/ "./segment-layer/index.js":
/*!********************************!*\
  !*** ./segment-layer/index.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = 'segmentLayer';\nmodule.exports.name = name;\n\nlet common = __webpack_require__(/*! ../common */ \"./common.js\");\nlet findLinearEqn = common.findLinearEqn;\nlet parseFormulaLatex = common.parseFormulaLatex;\nvar AbstractLayer = __webpack_require__(/*! ../interactive-layer */ \"./interactive-layer/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\nconst _ = __webpack_require__(/*! lodash */ \"../node_modules/lodash/lodash.js\");\n\n__webpack_require__(/*! ./style.css */ \"./segment-layer/style.css\");\nvar layerCollection = __webpack_require__(/*! ../layer-collection */ \"./layer-collection/index.js\");\nangular.module(moduleName)\n    .component(name, component({\n        controller: SegmentLayerController,\n        template: __webpack_require__(/*! ./template.html */ \"./segment-layer/template.html\"),\n        bindings: {\n            eqnOffsets: \"<\",\n            showEquation: \"<\",\n            onEqnChanged: \"<\"\n        }\n    }));\n\nfunction SegmentLayerController($timeout, $element, $scope) {\n    let self = this;\n    let dragging = false;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n\n    this.watchProperties = this.watchProperties.concat([\n        \"eqnOffsets\"\n    ]);\n    this.$onInit = function() {\n        this.doInit();\n        $scope.$watch(function() {\n            return self.points;\n        }, function() {\n            showEquation();\n        }, true);\n    }\n    this.defaultBindings = function() {\n        this.interactiveBindings();\n        this.eqnOffsets = this.eqnOffsets || [0,0];\n    }\n    this.doAutofit = function() { }\n    this.draw = function() { }\n    this.mouseDownAddPoint = function($event) {\n        let transformX = this.getTransform();\n        let transformY = this.getOrthoTransform();\n        let x = $event.offsetX;\n        let y = $event.offsetY;\n        let result = this.findClosest({x,y}, this.points, transformX, transformY);\n        if (!_.isFinite(result.idx)) {\n            this.points = [{x:transformX.invert(x), y:transformY.invert(y)}];\n        }\n        else if (this.points.length === 1) {\n            this.points.push({x:transformX.invert(x), y:transformY.invert(y)});\n        }\n        else {\n            this.points.splice(result.idx, 1, {x:transformX.invert(x), y:transformY.invert(y)});\n        }\n    }\n    this.mouseDownDelPoint = function($event) {\n        if (_.isFinite(this.editPointIdx)) {\n            this.points.splice(this.editPointIdx, 1);\n            this.editPointIdx = undefined;\n        }\n    }\n    this.calcEquation = function() {\n        if (this.points.length !== 2) return \"\";\n        else {\n            let formula = findLinearEqn(this.points[0], this.points[1], self.loga, self.orthoLoga);\n            let latex = parseFormulaLatex(formula);\n            self.onEqnChanged && self.onEqnChanged(formula);\n            return latex;\n        }\n    }\n    this.eqnStyle = function() {\n        return {\n            transform: 'translate(' + this.eqnOffsets[0] + \", \" + this.eqnOffsets[1] + \")\",\n            color: this.strokeStyle\n        }\n    }\n    this.eqnCopySuccess = function() {\n        console.log(\"Copy success\");\n        if (this.layerCollection) {\n            this.layerCollection.notify(\"Coppied\", 'ti-clip', 1000);\n        }\n    }\n    function showEquation() {\n        let html = katex.renderToString(self.calcEquation(), {throwOnError: false});\n        $element.find('.equation').empty().append(html);\n    }\n    this.registerWatch(function() {\n        showEquation();\n    });\n}\n\n\n//# sourceURL=webpack:///./segment-layer/index.js?");

/***/ }),

/***/ "./segment-layer/style.css":
/*!*********************************!*\
  !*** ./segment-layer/style.css ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./style.css */ \"../node_modules/css-loader/dist/cjs.js!./segment-layer/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./segment-layer/style.css?");

/***/ }),

/***/ "./segment-layer/template.html":
/*!*************************************!*\
  !*** ./segment-layer/template.html ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div>\\n<svg ng-class=\\\"{'edit-point': self.mode, 'add-point': self.shiftKey, 'del-point': self.altKey}\\\" \\n    style=\\\"margin: {{self.paddingStr();}};width:calc(100% - {{self.leftPadding() + self.rightPadding()}}px); height:calc(100% - {{self.bottomPadding() + self.topPadding()}}px)\\\"\\n    ng-mouseleave=\\\"self.onMouseLeave($event)\\\"\\n    ng-mouseup=\\\"self.onMouseUp($event)\\\"\\n    ng-mousedown=\\\"self.onMouseDown($event)\\\"\\n    ng-mousemove=\\\"self.onMouseMove($event)\\\">\\n    <g class=\\\"layer\\\">\\n        <polygon ng-points=\\\"{{self.getPoints()}}\\\" ng-fill=\\\"{{self.fillStyle}}\\\" ng-stroke=\\\"{{self.strokeStyle}}\\\" ng-stroke-width=\\\"{{self.strokeWidth}}\\\">\\n        </polygon>\\n        <g class=\\\"sub-layer\\\" ng-repeat=\\\"p in self.points\\\" ng-offset=\\\"{{ self.vertexOffset(p, $index) }}\\\">\\n            <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"5\\\" ng-style='{fill:\\\"transparent\\\", stroke:\\\"green\\\", \\\"stroke-width\\\":1}'></circle>\\n            <text>\\n            {{self.getPointLabel(p)}} \\n            </text>\\n        </g>\\n        <circle cx=\\\"0\\\" cy=\\\"0\\\" r=\\\"5\\\" ng-style=\\\"self.draggerStyleFn()\\\" ng-offset=\\\"{{self.draggerOffset()}}\\\"></circle>\\n    </g>\\n</svg>\\n</div>\\n<div ng-if=\\\"self.showCoordinates\\\" class=\\\"status\\\" ng-bind=\\\"self.getCoordinates()\\\" ng-style=\\\"\\\"></div>\\n<div class='equation' ng-if=\\\"self.showEquation\\\"\\n    ng-style='self.eqnStyle();' \\n    ngclipboard ngclipboard-success=\\\"self.eqnCopySuccess(e);\\\"\\n    data-clipboard-text=\\\"{{self.calcEquation();}}\\\"></div>\\n</div>\\n\";\n\n//# sourceURL=webpack:///./segment-layer/template.html?");

/***/ }),

/***/ "./tooltip-layer/index.js":
/*!********************************!*\
  !*** ./tooltip-layer/index.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const moduleName = 'plot-toolkit';\nconst name = 'tooltipLayer';\nmodule.exports.name = name;\n\nvar AbstractLayer = __webpack_require__(/*! ../abstract-layer-2d */ \"./abstract-layer-2d/index.js\");\nvar AbstractLayerController = AbstractLayer.klass;\nvar component = AbstractLayer.component;\nconst _ = __webpack_require__(/*! lodash */ \"../node_modules/lodash/lodash.js\");\nconst bestNumberFormat = __webpack_require__(/*! ../common */ \"./common.js\").bestNumberFormat;\n\n__webpack_require__(/*! ./style.css */ \"./tooltip-layer/style.css\");\nvar layerCollection = __webpack_require__(/*! ../layer-collection */ \"./layer-collection/index.js\");\nangular.module(moduleName)\n    .component(name, component({\n        controller: TooltipLayerController,\n        template: __webpack_require__(/*! ./template.html */ \"./tooltip-layer/template.html\"),\n        bindings: {\n            frequencyXFn: '<',\n            frequencyYFn: '<'\n        }\n    }));\n\nfunction TooltipLayerController($timeout, $element, $scope) {\n    let self = this;\n    let dragging = false;\n    AbstractLayerController.call(this, $timeout, $element, $scope);\n\n    this.$onInit = function() {\n        this.doInit();\n    }\n    this.defaultBindings = function() {}\n    this.draw = function() {}\n\tlet invertX, invertY;\n    this.onMouseMove = function($event) {\n        this.shiftKey = $event.shiftKey;\n        this.altKey = $event.altKey;\n        this.onMouseMoveTooltip($event);\n        let transformX = this.getTransform();\n        let transformY = this.getOrthoTransform();\n        let x = $event.offsetX;\n        let y = $event.offsetY;\n        invertX = transformX.invert(x);\n        invertY = transformY.invert(y);\n        return true;\n    }\n    this.onMouseLeave = function($event) {\n        invertX = undefined;\n        invertY = undefined;\n    }\n    this.getCoordinates = function() {\n        if (!invertX || !invertY)\n            return '';\n        return `X: ${invertX ? bestNumberFormat(invertX) : 0}\n        Y:${invertY ? bestNumberFormat(invertY) : 0}`;\n    }\n    this.getFrequencyX = function() {\n        if (!invertX || !invertY)\n            return '';\n        return self.frequencyXFn(invertX ? bestNumberFormat(invertX) : 0);\n    }\n    this.getFrequencyY = function() {\n        if (!invertX || !invertY)\n            return '';\n        return self.frequencyYFn(invertY ? bestNumberFormat(invertY) : 0);\n    }\n}\n\n\n//# sourceURL=webpack:///./tooltip-layer/index.js?");

/***/ }),

/***/ "./tooltip-layer/style.css":
/*!*********************************!*\
  !*** ./tooltip-layer/style.css ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./style.css */ \"../node_modules/css-loader/dist/cjs.js!./tooltip-layer/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./tooltip-layer/style.css?");

/***/ }),

/***/ "./tooltip-layer/template.html":
/*!*************************************!*\
  !*** ./tooltip-layer/template.html ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<div style=\\\"position: absolute; width: 100%; height: 100%; top: 0; left: 0;\\\">\\n<svg style=\\\"margin: {{self.paddingStr();}};width:calc(100% - {{self.leftPadding() + self.rightPadding()}}px); height:calc(100% - {{self.bottomPadding() + self.topPadding()}}px)\\\"\\n    ng-mouseleave=\\\"self.onMouseLeave($event)\\\"\\n    ng-mouseup=\\\"self.onMouseUp($event)\\\"\\n    ng-mousedown=\\\"self.onMouseDown($event)\\\"\\n    ng-mousemove=\\\"self.onMouseMove($event)\\\">\\n</svg>\\n<div class=\\\"status\\\" ng-bind=\\\"self.getCoordinates()\\\" style=\\\"\\\"></div>\\n<div style=\\\"position: absolute; bottom: -5px; left: 15px;\\\">\\n    <div class=\\\"\\\" ng-bind=\\\"self.getFrequencyX()\\\" ng-style=\\\"\\\"></div>\\n    <div class=\\\"\\\" ng-bind=\\\"self.getFrequencyY()\\\" ng-style=\\\"\\\"></div>\\n</div>\\n</div>\\n\";\n\n//# sourceURL=webpack:///./tooltip-layer/template.html?");

/***/ }),

/***/ "dll-reference library":
/*!**************************!*\
  !*** external "library" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = library;\n\n//# sourceURL=webpack:///external_%22library%22?");

/***/ })

/******/ });